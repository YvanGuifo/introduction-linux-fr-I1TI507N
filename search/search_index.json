{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"TI507N - Introduction au syst\u00e8me Linux","text":""},{"location":"#description","title":"Description","text":"<p>Ce cours est une introduction au concept de syst\u00e8me d'exploitation, et en particulier aux syst\u00e8mes d'exploitation bas\u00e9s sur GNU/Linux. Vous d\u00e9couvrirez la philosophie, le fonctionnement, les composants de base et les outils puissants pr\u00e9sents sur les syst\u00e8mes GNU/Linux \u00e0 travers l'une de ses distributions : Debian.</p> <p>Cette ann\u00e9e le coordinateur de ce module sera M. Yvan GUIFO. Vous pouvez le contacter \u00e0 <code>yvan.guifo-fodjo@efrei.fr</code>.</p>"},{"location":"#sequencement","title":"S\u00e9quencement","text":"<p>Ce module se d\u00e9roulera en 15 heures de cours sous forme de Cours - TP.</p> <ul> <li>Semaine 39: 3 heures de TP</li> <li>Semaine 40: 3 heures de TP</li> <li>Semaine 41: 3 heures de TP + 25 minutes d'\u00e9valuation (CC)</li> <li>Semaine 43: 3 heures de TP </li> <li>Semaine 45: 2 heures de TP dont 1 heure d'\u00e9valuation (TP not\u00e9)</li> <li>Semaine 46: 1 heure d'examen final (DE)</li> </ul>"},{"location":"#modalite-devaluation","title":"Modalit\u00e9 d'\u00e9valuation","text":"Modalit\u00e9 d'\u00e9valuation Dur\u00e9e (en minutes) Pond\u00e9ration. Contr\u00f4le continu 25 minutes 20% TP not\u00e9 60 minutes 20% Devoir \u00e9crit (DE) 60 minutes 60%"},{"location":"#repartition-des-groupes","title":"R\u00e9partition des groupes","text":"Groupe Enseignant Contact A Yvan Guifo yvan.guifo-fodjo@efrei.fr B, D Walid Gaaloul walid.gaaloul@intervenants.efrei.net"},{"location":"#contenu-du-cours","title":"Contenu du cours","text":"<ol> <li>Installation d'une distribution Linux</li> <li>Lecture pr\u00e9liminaire</li> <li>Introduction \u00e0 MarioNum</li> <li>TP1 - Premi\u00e8res commandes</li> <li>TP2 - Syst\u00e8me de fichiers et permissions</li> <li>TP3 - Environnement de travail et Compilateur C</li> <li>TP4 - TP4 - Canaux standards et redirections | Processus et t\u00e2ches | Signaux</li> </ol>"},{"location":"contenus/Intro-MarioNum/","title":"Introduction \u00e0 MarioNum","text":""},{"location":"contenus/Intro-MarioNum/#cest-quoi-marionum","title":"C'est quoi MarioNum ?","text":"<p>MarioNum est une plateforme interactive d\u2019auto-formation au num\u00e9rique d\u00e9velopp\u00e9e par le MESRI (Minist\u00e8re de l\u2019Enseignement Sup\u00e9rieur, de la Recherche et de l\u2019Innovation). Il a \u00e9t\u00e9 con\u00e7u comme un cloud \u00e9ducatif, incluant au c\u0153ur de son projet des innovations technologiques et p\u00e9dagogiques, une inclusivit\u00e9 multi-dimensionnelle, l\u2019\u00e9conomie et la sobri\u00e9t\u00e9 \u00e9nerg\u00e9tique et num\u00e9rique.</p> <p>MarioNUM a \u00e9t\u00e9 construit autour des objectifs suivants :</p> <ul> <li>Enrichir la palette des outils de virtualisation des laboratoires pour couvrir d\u2019autres domaines du num\u00e9rique les objets connect\u00e9s, les r\u00e9seaux sans fil et la cybers\u00e9curit\u00e9 sont les premi\u00e8res \u00e9tapes planifi\u00e9es dans ce projet.</li> <li>Rendre accessible ces innovations au plus grand nombre  d\u2019apprenants et d\u2019enseignants, en tenant compte d\u2019objectifs de sobri\u00e9t\u00e9 \u00e9conomique, num\u00e9rique et environnementale et d\u2019inclusivit\u00e9 (apprenants \u00e9loign\u00e9s g\u00e9ographiquement, temporellement ou par des handicaps). Le projet sera donc h\u00e9berg\u00e9 en cloud dans le Datacenter labellis\u00e9 par le Minist\u00e8re de l\u2019Enseignement Sup\u00e9rieur et de la Recherche, un choix anim\u00e9 par ce besoin de sobri\u00e9t\u00e9, de mutualisation des moyens et d\u2019ouverture des applicatifs \u00e0 l\u2019ensemble de l\u2019\u00e9cosyst\u00e8me de l\u2019Enseignement Sup\u00e9rieur. La refonte de l\u2019interface utilisateur (UX/UI) favorisera aussi son accessibilit\u00e9 et son inclusivit\u00e9 aupr\u00e8s d\u2019un large public.</li> <li>Fournir un contenu p\u00e9dagogique riche et innovant au travers de capsules p\u00e9dagogiques vari\u00e9es, mais aussi en fournissant un support r\u00e9el de situations d\u2019apprentissage et d\u2019auto-\u00e9valuation. D\u2019une part, l\u2019exploration de techniques IA pour la recommandation des parcours p\u00e9dagogiques permettra aux apprenants d\u2019am\u00e9liorer leurs r\u00e9sultats. D\u2019autre part, l\u2019enrichissement des contenus p\u00e9dagogiques est pr\u00e9vu en mode collaboratif et certains acteurs nationaux ont d\u2019ores et d\u00e9j\u00e0 t\u00e9moign\u00e9 de leur int\u00e9r\u00eat comme l\u2019ADIUT, l\u2019universit\u00e9 num\u00e9rique IUT en Ligne et l\u2019Assembl\u00e9 des d\u00e9partement R\u00e9seaux &amp; t\u00e9l\u00e9coms de France.</li> </ul> <p>Pourquoi MarioNum dans le cadre de ce cours ?</p> <p>L\u2019objectif du cours est de ma\u00eetriser les fondamentaux de Linux \u00e0 travers des manipulations concr\u00e8tes en ligne de commande. MarioNum est une excellente passerelle p\u00e9dagogique vers cet objectif.</p> <p>MarioNum nous permettra :</p> <ul> <li>\u00catre initi\u00e9 \u00e0 l\u2019environnement Linux de mani\u00e8re guid\u00e9e.</li> <li>Apprendre \u00e0 son rythme avec des modules progressifs.</li> <li>Gagner en efficacit\u00e9 d\u00e8s les premiers TP.</li> </ul>"},{"location":"contenus/Intro-MarioNum/#prise-en-main-de-marionum","title":"Prise en main de MarioNum","text":"<p>Notez bien</p> <p>Avant le d\u00e9but de chaque TP, vous recevrez des identifiants de connexion pour acc\u00e9der \u00e0 MarioNum.</p> <ol> <li>Ouvrir un navigateur (Firefox, Chrome, Edge\u2026).</li> <li>Acc\u00e9der au site MarioNum via le lien qui vous sera fourni et aller en bas de la page et vous verrez l'image ci-dessous. Cliquer sur \"Efrei\" </li> <li>Entrer vos param\u00e8tres d'authetification de myEFREI (Login + mot de passe)</li> <li>Ensuite cliquer sur \"Rejoindre le TP\". </li> <li>Vous obtiendrez la page ci-dessous. Cliquer sur connecter et introduisez le mot de passe qui vous a \u00e9t\u00e9 fourni en d\u00e9but de TP. </li> <li>L'interface suivante s'affichera  </li> <li>Faites un clic sur \"Applications\" --&gt; \"\u00c9mulateur de terminal\" --&gt; Puis tapez les commandes suivantes  <pre><code>   whoami\n   hostname\n   ls /\n   uname -a\n</code></pre></li> </ol> <p>Info</p> <p>Ne vous inquietez pas, nous reviendrons plus en d\u00e9tail sur ces commandes durant le cours!</p>"},{"location":"contenus/corrige-tp2/","title":"TP2 - Syst\u00e8me de fichiers et permissions (corrig\u00e9)","text":"<p>Instructions</p> <ul> <li>On rappelle que dans tous les exercices le <code>$</code> en d\u00e9but de commande repr\u00e9sente le prompt, il n'est pas \u00e0 saisir lorsque vous \u00e9crivez une ligne de commande.</li> <li>Pour chaque nouvelle commande, n'h\u00e9sitez pas \u00e0 consulter sa page de manuel avec la commande <code>man</code>, ou \u00e0 utiliser l'option <code>--help</code> pour savoir ce qu'elle fait.</li> </ul>"},{"location":"contenus/corrige-tp2/#systeme-de-fichiers","title":"Syst\u00e8me de fichiers","text":"<p>Le syst\u00e8me de fichiers Linux</p> <p>Le syst\u00e8me de fichiers Linux est une arborescence ou une hi\u00e9rarchie de fichiers et de r\u00e9pertoires. Le r\u00e9pertoire racine est <code>/</code> et tous les autres r\u00e9pertoires sont des sous-r\u00e9pertoires de celui-ci. Les r\u00e9pertoires sont s\u00e9par\u00e9s par des <code>/</code> et les fichiers sont des noms de fichiers. </p> <p>Quand vous lancez un shell (i.e. ouvrez un terminal), celui-ci se trouve dans un r\u00e9pertoire. Ce r\u00e9pertoire est appel\u00e9 votre r\u00e9pertoire courant ou r\u00e9pertoire de travail. </p> <p>Un syst\u00e8me Linux typique comporte des dixaines de milliers de r\u00e9pertoires syst\u00e8me et de fichiers. La plupart de ces r\u00e9pertoires et fichiers sont cach\u00e9s et ne sont pas visibles par d\u00e9faut. Ces fichiers et r\u00e9pertoires cach\u00e9s sont utilis\u00e9s par le syst\u00e8me d'exploitation pour stocker des informations de configuration et d'autres informations syst\u00e8me.</p> <p>Les sous-r\u00e9pertoires de la racine sont g\u00e9n\u00e9ralement r\u00e9serv\u00e9s aux fichiers syst\u00e8me. Les r\u00e9pertoires <code>/home</code> et <code>/tmp</code> sont utilis\u00e9s pour stocker des fichiers temporaires et des fichiers personnels.</p> <p>\u00c0 moins d'\u00eatre un administrateur syst\u00e8me, vous n'avez pas besoin de vous soucier de la plupart des fichiers et r\u00e9pertoires syst\u00e8me. Toutefois il est important de comprendre comment les r\u00e9pertoires et les fichiers sont organis\u00e9s afin de pouvoir naviguer dans le syst\u00e8me de fichiers et de pouvoir trouver les fichiers dont vous avez besoin.</p> <p>Le tableau d\u00e9crit le contenu des principaux r\u00e9pertoires du syst\u00e8me de fichiers Linux.</p> R\u00e9pertoire Description <code>/</code> R\u00e9pertoire racine. Tous les autres r\u00e9pertoires sont des sous-r\u00e9pertoires de celui-ci. <code>/bin</code> Contient les programmes essentiels au fonctionnement du syst\u00e8me. <code>/boot</code> Contient les fichiers n\u00e9cessaires au d\u00e9marrage du syst\u00e8me. <code>/dev</code> Contient les fichiers repr\u00e9sentant les p\u00e9riph\u00e9riques. <code>/etc</code> Contient les fichiers de configuration du syst\u00e8me. <code>/home</code> Contient les r\u00e9pertoires personnels des utilisateurs. <code>/lib</code> Contient les biblioth\u00e8ques partag\u00e9es et les modules du noyau. <code>/media</code> Contient les points de montage des p\u00e9riph\u00e9riques amovibles. <code>/mnt</code> Contient les points de montage des syst\u00e8mes de fichiers temporaires. <code>/opt</code> Contient les logiciels additionnels. <code>/proc</code> Contient les informations sur les processus et le syst\u00e8me. <code>/root</code> R\u00e9pertoire personnel de l'administrateur. <code>/run</code> Contient les fichiers d'ex\u00e9cution des applications. <code>/sbin</code> Contient les programmes essentiels au fonctionnement du syst\u00e8me. <code>/srv</code> Contient les donn\u00e9es des services fournis par le syst\u00e8me. <code>/sys</code> Contient les informations sur les p\u00e9riph\u00e9riques. <code>/tmp</code> Contient les fichiers temporaires. <code>/usr</code> Contient les programmes, les biblioth\u00e8ques et les fichiers de configuration. <code>/var</code> Contient les fichiers variables comme les logs, les mails, les bases de donn\u00e9es, etc. <code>/lost+found</code> Contient les fichiers r\u00e9cup\u00e9r\u00e9s lors d'un crash du syst\u00e8me."},{"location":"contenus/corrige-tp2/#exercice-1-id-et-etcpasswd","title":"Exercice 1 : <code>id</code> et <code>/etc/passwd</code>","text":"<ol> <li> <p>Entrez les commandes suivantes dans un terminal et notez les r\u00e9sultats :     <pre><code>$ id\n</code></pre></p> <p>R\u00e9ponse</p> <p>Affiche le UID et le GID de l'utilisateur courant, ansi que tous les GID des groupes dans lequel l'utilisateur courant appartient.</p> </li> <li> <p>Ensuite tapez la m\u00eame commande, mais cette fois-ci avec l'argument <code>root</code>, notez les r\u00e9sultats.     <pre><code>$ id root\n</code></pre></p> <p>R\u00e9ponse</p> <p>M\u00eame chose mais pour l'user root.</p> </li> <li> <p>Affichez ensuite le contenu du fichier <code>/etc/passwd</code> avec la commande <code>cat</code>.</p> <p>R\u00e9ponse</p> <p>Chaque ligne repr\u00e9sente les informations des utilisateurs : UID, GID, r\u00e9pertoire personnel, shell ... . Les champs sont s\u00e9par\u00e9s par des <code>;</code>.</p> </li> <li> <p>Recherchez les lignes o\u00f9 appara\u00eessent votre nom d'utilisateur et celui de l'utilisateur <code>root</code>. Quelles sont les diff\u00e9rences ?</p> <p>R\u00e9ponse</p> <p>La ligne de root a un UID de 0, un GID de 0, un r\u00e9pertoire personnel <code>/root</code> et un shell <code>/bin/bash</code>. La ligne de l'utilisateur courant a un UID et un GID diff\u00e9rents, un r\u00e9pertoire personnel diff\u00e9rent et un shell diff\u00e9rent.</p> </li> <li> <p>Pouvez-vous d\u00e9duire \u00e0 quoi sert le fichier <code>/etc/passwd</code> ?</p> <p>R\u00e9ponse</p> <p>Le fichier <code>/etc/passwd</code> contient les informations des utilisateurs du syst\u00e8me. Il est utilis\u00e9 par le syst\u00e8me pour associer un UID \u00e0 un nom d'utilisateur, un GID \u00e0 un nom de groupe, un r\u00e9pertoire personnel \u00e0 un utilisateur et un shell \u00e0 un utilisateur.</p> </li> </ol>"},{"location":"contenus/corrige-tp2/#permissions-associees-aux-fichiers","title":"Permissions associ\u00e9es aux fichiers","text":"<p>Protection des fichiers</p> <p>Un syst\u00e8me Linux peut permettre \u00e0 de nombreux utilisateurs d'acc\u00e9der aux fichiers et aux r\u00e9pertoires. Pour prot\u00e9ger les fichiers et les r\u00e9pertoires, Linux utilise un syst\u00e8me de permissions. Les permissions sont des droits d'acc\u00e8s aux fichiers et aux r\u00e9pertoires. Les permissions sont associ\u00e9es \u00e0 des utilisateurs et \u00e0 des groupes. Les utilisateurs sont des personnes qui ont un compte sur le syst\u00e8me.</p> <p>Pour les fichiers normaux, les permissions sont associ\u00e9es \u00e0 trois cat\u00e9gories d'utilisateurs : le propri\u00e9taire du fichier (g\u00e9n\u00e9ralement celui qui a cr\u00e9e le fichier), le groupe propri\u00e9taire du fichier et les autres utilisateurs. </p> <p>Les cat\u00e9gories de permissions pour un fichier sont les suivantes :</p> <ul> <li>read <code>r</code>: permet de lire le contenu du fichier.</li> <li>write <code>w</code>: permet de modifier le contenu du fichier.</li> <li>execute <code>x</code>: permet d'ex\u00e9cuter le fichier (si c'est un programme ou un script).</li> </ul> <p>L'option <code>-l</code> de la commande <code>ls</code> les m\u00e9ta-donn\u00e9es associ\u00e9es \u00e0 un fichier, son nom, sa taille, son propri\u00e9taire, son groupe, ... et en particuler ses permissions, par exemple :</p> <pre><code>$ ls -l fichier\n-rw-r--r-- 1 user group 0 2019-09-09 10:00 fichier\n</code></pre> <p>La cha\u00eene <code>-rw-r--r--</code> repr\u00e9sente les permissions associ\u00e9es au fichier. Le premier caract\u00e8re d\u00e9signe le type du fichier, les trois suivants repr\u00e9sentent les permissions du propri\u00e9taire, les trois suivants celles du groupe propri\u00e9taire et les trois derniers celles des autres utilisateurs. Les permissions sont repr\u00e9sent\u00e9es par les caract\u00e8res <code>r</code>, <code>w</code> et <code>x</code> pour les permissions respectivement en lecture, \u00e9criture et ex\u00e9cution. Si la permission n'est pas accord\u00e9e, le caract\u00e8re <code>-</code> est utilis\u00e9 \u00e0 la place.</p> <p>Les permissions peuvent \u00eatre repr\u00e9sent\u00e9es par des chiffres (repr\u00e9sentation en octal) ou des lettres (repr\u00e9sentation symbolique).</p> <p>Le tableau suivant donne la correspondance entre les deux repr\u00e9sentations :</p> Chiffre Lettre Description 0 --- Aucune permission 1 --x Ex\u00e9cution 2 -w- \u00c9criture 3 -wx \u00c9criture et ex\u00e9cution 4 r-- Lecture 5 r-x Lecture et ex\u00e9cution 6 rw- Lecture et \u00e9criture 7 rwx Lecture, \u00e9criture et ex\u00e9cution"},{"location":"contenus/corrige-tp2/#exercice-2-permissions-associees-aux-fichiers","title":"Exercice 2 : Permissions associ\u00e9es aux fichiers","text":"<ol> <li> <p>Cr\u00e9ez un r\u00e9pertoire vide et un fichier vide (ces deux derniers doivent \u00eatre au m\u00eame niveau). Utilisez la commande <code>ls</code> et les options <code>-l</code> et <code>-d</code> sur chacun de ces deux nouveaux fichiers pour d\u00e9terminer les permissions que vous (respectivement votre groupe et les autres) avez sur ces fichiers. Comment reconnaissez-vous un r\u00e9pertoire ?</p> <p>R\u00e9ponse</p> <p>Le r\u00e9sultat d\u00e9pend du masque utilisateur (<code>umask</code>, voir le dernier exo), mais fr\u00e9quemment on trouve:</p> <ul> <li><code>-rw-r--r--</code> pour un fichier normal</li> <li><code>drwxr-xr-x</code> pour un r\u00e9pertoire.</li> </ul> <p>Pour le fichier normal, le propri\u00e9taire a donc la permission de lire (<code>r</code> pour read), d\u2019\u00e9crire (<code>w</code> pour write) ; le groupe et les autres ont le droit de le lire.</p> <p>Pour le r\u00e9pertoire (qu\u2019on rep\u00e8re au <code>d</code>, pour directory, avant les permissions), l\u2019utilisateur a le droit de le traverser (<code>x</code> pour cross, on dit aussi search), de le lire (par exemple avec <code>ls</code>) et de modifier son contenu (supprimer ou cr\u00e9er des fichiers dedans). Le groupe et les autres ont le droit de le traverser et de le lire.</p> </li> <li> <p>Les lignes suivantes donnent la r\u00e9ponse de la commande <code>ls -ld</code> sur un certain r\u00e9pertoire (pour les besoins de l'exercice nous n'avons report\u00e9 que le premier et le dernier champ du r\u00e9sultat de <code>ls -ld</code>).     <pre><code>drwxr-xr-x a\ndr-xr--r-- b\n-rw-r--r-- c.txt\n--w--w-r-- d.c\n-rwxr-xr-x op\n</code></pre>     Parmi ces fichiers, quels sont les r\u00e9pertoires ?</p> <p>R\u00e9ponse</p> <p>Les fichiers a et b sont des r\u00e9pertoires, les autres des fichiers normaux. </p> </li> <li> <p>Pour chacun des fichiers ci-dessus, donnez les permissions associ\u00e9es \u00e0 chacun des utilisateurs (propri\u00e9taire, groupe propri\u00e9taire et autres utilisateurs) en utilisant la repr\u00e9sentation symbolique et la repr\u00e9sentation octale.</p> <p>R\u00e9ponse</p> <ul> <li>Pour le r\u00e9pertoire <code>a</code> tout le monde peut le traverser mais seul son propri\u00e9taire peut le modifier. La repr\u00e9sentation octale de ces permissions est 0755. </li> <li>Le propri\u00e9taire du r\u00e9pertoire <code>b</code> peut le lire et le traverser mais pas le modifier. Les autres utilisateurs peuvent seulement le lire. Repr\u00e9sentation octale 0544. </li> <li>Le fichier <code>c.txt</code> est lisible par tous, modifiable par son propri\u00e9taire, repr\u00e9sentation octale 0644. </li> <li>Le fichier <code>d.c</code> est seulement modifiable par l\u2019utilisateur et le groupe et seulement consultable par les autres, repr\u00e9sentation octale 114.</li> <li>Enfin, le fichier <code>op</code> peut \u00eatre lu et ex\u00e9cut\u00e9 par tous et peut \u00eatre modifi\u00e9 par son propri\u00e9taire.</li> </ul> </li> <li> <p>Donnez la repr\u00e9sentation symbolique et la repr\u00e9sentation octale des permissions associ\u00e9es au fichier <code>/etc/passwd</code>, \u00e0 la commande <code>ls</code> et \u00e0 votre r\u00e9pertoire personnel.</p> <p>R\u00e9ponse</p> <p>La commande \u00e0 taper est la suivante: <pre><code>$ ls -ld /etc/passwd /bin/ls ~ \n# Ce qui renvoie chez moi\n-rw-r--r-- 1  root    root    /etc/passwd\n-rwxr-xr-x 1  root    root    /bin/ls\ndrwxr-xr-x 19 debian  deian   /home/debian\n</code></pre> En octal \u00e7a donne respectivement 0644, 0755 et 0755. Rappeler que root peut tout faire</p> </li> </ol>"},{"location":"contenus/corrige-tp2/#exercice-3-modification-des-permissions-chmod","title":"Exercice 3 : Modification des permissions <code>chmod</code>","text":"<ol> <li> <p>Testez les commandes suivantes dans un terminal et essayez de comprendre comment fonctionne la commande <code>chmod</code> (avec la repr\u00e9sentation symbolique).     <pre><code>$ touch f; ls -l f\n$ chmod a= f; ls -l f\n$ chmod o+rw f; ls -l f\n$ chmod u=o f; ls -l f\n$ chmod o-wx f; ls -l f\n$ chmod g+u f; ls -l f\n$ chmod a+x,g-w f; ls -l f\n</code></pre></p> <p>R\u00e9ponse</p> <p>La syntaxe est : l\u2019une des lettres <code>augo</code> (all, user, group, others) suivi d\u2019un des caract\u00e8res <code>=+-</code> (affecter les permissions, ajouters des permissions, retirer des permissions) suivi d\u2019une partie de <code>rwx</code> (qui peut \u00eatre vide) ou bien, d\u2019un caract\u00e8re parmi ugo, pour \u00e9galer, ajouter ou supprimer les permissions d\u2019une de ces cat\u00e9gories d\u2019utilisateurs. </p> <p>Enfin, on peut juxtaposer ces modifications en les s\u00e9parant par une virgule (sans espace, car cela doit \u00eatre un seul argument).</p> </li> <li> <p>Testez la commande <code>chmod 644 f; ls -l f</code>. Que fait cette commande ?</p> <p>R\u00e9ponse</p> <p>On a donn\u00e9 la permission de lire pour tous et la permission d\u2019\u00e9crire pour le propri\u00e9taire.</p> </li> <li> <p>Avec les deux modes d'utilisation de <code>chmod</code> (octale et symbolique), modifiez les permissions du fichier <code>f</code> de la mani\u00e8re suivante :</p> <ul> <li>ex\u00e9cution pour tous, lecture et \u00e9criture uniquement pour le propri\u00e9taire.</li> <li>lecture et ex\u00e9cution pour tous, personne ne peut \u00e9crire.</li> <li>toutes les permissions pour tous, pas d'\u00e9criture pour les autres.</li> <li>lecture et \u00e9criture pour le propri\u00e9taire, ex\u00e9cution pour le groupe et aucune pour les autres.</li> </ul> <p>R\u00e9ponse</p> <ul> <li><code>chmod a=x,u+rw f</code> (par exemple) et <code>chmod 711 f</code></li> <li><code>chmod a=rx f</code> (par exemple) et <code>chmod 555 f</code></li> <li><code>chmod a=rwx,o- f</code> (par exemple) et <code>chmod 775 f</code></li> <li><code>chmod u=rw,g=x,o= f</code> et <code>chmod 610 f</code></li> </ul> </li> </ol>"},{"location":"contenus/corrige-tp2/#exercice-4-permissions-associees-aux-fichiers-normaux","title":"Exercice 4 : Permissions associ\u00e9es aux fichiers normaux","text":"<ol> <li>Dans un r\u00e9pertoire de votre choix, cr\u00e9er deux fichiers <code>f</code> et <code>g</code>. Puis entrer (par exemple avec un \u00e9diteur de texte) du texte dans ces fichiers.</li> <li>Pour vous (propri\u00e9taire), retirer la permission de lire dans le fichier <code>f</code> et la permission d'\u00e9crire dans le fichier <code>g</code>.</li> <li>Testez ensuite les commandes suivantes, puis notez les r\u00e9sultats :     <pre><code>$ cat f\n$ cat g\n</code></pre></li> <li>Essayer de modifier <code>g</code> avec un \u00e9diteur de texte. Que se passe-t-il ?</li> <li>Tester les commandes:     <pre><code>$ cp f h\n$ cp g h\n</code></pre>     Puis observer le contenu du fichier <code>h</code> ainsi que les permissions associ\u00e9es \u00e0 ce fichier.</li> <li>La commande suivante permet d'\u00e9crire la cha\u00eene <code>toto</code> \u00e0 la fin du fichier <code>f</code> (nous la verrons plus en d\u00e9tail dans un prochain TP) :     <pre><code>$ echo \"toto\" &gt;&gt; f\n</code></pre>     Tester cette commande, puis redonnez-vous les droits de lecture sur le fichier <code>f</code>. Enfin affichez le contenu du fichier <code>f</code> gr\u00e2ce \u00e0 la commande <code>cat</code>.</li> <li>Tester la commande:     <pre><code>$ rm g\n</code></pre> Tapez <code>n</code> pour refuser. Enfin tester la commande suivante:     <pre><code>$ rm -f g\n</code></pre>     A-t-elle r\u00e9ussie ? Que pouvez vous en d\u00e9duire ?</li> </ol> <p>Correction globale</p> <p><pre><code>$ touch f g\n$ echo \"fichier f\" &gt; f; echo \"fichier g\" &gt; g\n$ chmod u-r f; chmod u-w g\n$ cat f\ncat: f: Permission non accord\u00e9e\n$ cat g\nfichier g\n$ echo \"toto\" &gt;&gt; g\nbash: g: Permission non accord\u00e9e\n$ cp f h\ncp: impossible d ouvrir f en lecture: Permission non accord\u00e9e\n$ cp g h\n$ cat h\nfichier g\n$ ls -l h\n-r--r--r-- 1 debian debian 9 2021-09-09 10:00 h\n$ echo \"toto\" &gt;&gt; f\n$ chmod u+r f\n$ cat f\nfichier f\ntoto\n$ rm g\nrm: supprimer g prot\u00e9g\u00e9 en \u00e9criture r\u00e9gulier ? n\n$ rm -f g\n$ ls -l g\nls: impossible d'acc\u00e9der \u00e0 g: Aucun fichier ou dossier de ce type\n</code></pre> Insister sur le fait qu'un fichier prot\u00e9g\u00e9 en \u00e9criture peut \u00eatre supprim\u00e9.</p>"},{"location":"contenus/corrige-tp2/#permissions-associees-aux-repertoires","title":"Permissions associ\u00e9es aux r\u00e9pertoires","text":"<p>Qu'est-ce qu'un r\u00e9pertoire ?</p> <p>Un r\u00e9pertoire est une table de noms de fichiers associ\u00e9s \u00e0 un num\u00e9ro d'index appel\u00e9 num\u00e9ro d'inode qui permet de conna\u00eetre les informations (contenues dans l'inode) concernant ce fichier (taille, permissions, horodatage, o\u00f9 trouver le contenu du fichier, ...).</p> <p>Dans un r\u00e9pertoire, les permissions ne sont pas associ\u00e9es aux fichiers mais au r\u00e9pertoire lui-m\u00eame. Les permissions associ\u00e9es \u00e0 un r\u00e9pertoire sont :</p> <ul> <li>read <code>r</code>: permet de lister le contenu du r\u00e9pertoire.</li> <li>write <code>w</code>: permet de modifier le contenu du r\u00e9pertoire (cr\u00e9er ou supprimer des fichiers).</li> <li>execute <code>x</code>: permet d'ouvrir le r\u00e9pertoire (avec la commande <code>cd</code> par exemple).</li> </ul>"},{"location":"contenus/corrige-tp2/#exercice-5-permissions-associees-aux-repertoires","title":"Exercice 5 : Permissions associ\u00e9es aux r\u00e9pertoires","text":"<ol> <li> <p>Cr\u00e9ez un r\u00e9pertoire <code>rep</code> et deux fichiers normaux <code>a</code> et <code>b</code> \u00e0 l'int\u00e9rieur de ce r\u00e9pertoire.</p> <p>R\u00e9ponse</p> <p>$ mkdir rep; touch rep/a rep/b</p> </li> <li> <p>Retirez toutes les permissions sur le r\u00e9pertoire <code>rep</code> et essayez les commandes suivantes :     <pre><code>$ cd rep\n$ ls rep\n$ cat rep/a\n$ touch rep/c\n$ rm rep/a\n</code></pre></p> <p>R\u00e9ponse</p> <p><pre><code>$ chmod 000 rep\n</code></pre> On ne peut rien faire de ces commandes.</p> </li> <li> <p>Redonnez la permission read uniquement sur le r\u00e9pertoire <code>rep</code> et essayez les toutes les commandes de la question 2. Notez les diff\u00e9rences.</p> <p>R\u00e9ponse</p> <p>Avec la permission r, on peut lister le contenu de rep et c\u2019est tout.</p> </li> <li> <p>M\u00eame question mais avec seulement la permission write sur <code>rep</code>. Notez les diff\u00e9rences.</p> <p>R\u00e9ponse</p> <p>Avec w tout seul, on ne peut rien faire du tout.</p> </li> <li> <p>Cette fois-ci avec uniquement la permission execute sur <code>rep</code>. Testez les commandes suivantes :     <pre><code>$ cd rep\n$ ls rep\n$ echo \"toto\" &gt;&gt; rep/a\n$ cat rep/c\n$ ls -l rep/a\n$ touch rep/c\n$ rm rep/a\n</code></pre></p> <p>R\u00e9ponse</p> <p>Avec x tout seul, on peut <code>cd</code> dans le r\u00e9pertoire, lire et modifier les fichiers qu\u2019il contient (\u00e0 condition d\u2019avoir les permissions ad\u00e9quates sur ces fichiers). On ne peut pas cr\u00e9er ou supprimer de fichier.</p> </li> <li> <p>Avec l'ensemble de permissions <code>-wx</code> sur <code>rep</code> pour tous les utilisateurs, essayez de:</p> <ul> <li>cr\u00e9er un fichier d dans <code>rep</code></li> <li>renommer le fichier b</li> <li>retirer toutes les permissions associ\u00e9es au fichier d</li> <li>supprimer le fichier d</li> </ul> <p>R\u00e9ponse</p> <p>Avec <code>-wx</code> on peut tout faire, sauf lister le contenu du r\u00e9pertoire. On insiste encore sur le fait que pour supprimer un fichier, il suffit d\u2019avoir les permissions <code>-wx</code> sur le r\u00e9pertoire qui le contient, peu importent les permissions associ\u00e9es au fichier.</p> </li> </ol>"},{"location":"contenus/corrige-tp2/#exercice-6-les-repertoires-du-path","title":"Exercice 6 : Les r\u00e9pertoires du <code>PATH</code>","text":"<p>Attention</p> <p>Cet exercice de type exp\u00e9rimentation est d\u00e9licat et important. Il faut le traiter avec un soin particulier et en prenant son temps.</p> <ol> <li> <p>Ouvrir un nouveau terminal et entrer la commande suivante :     <pre><code>$ echo $PATH\n</code></pre>     Observer le r\u00e9sultat, \u00e0 votre avis \u00e0 quoi correspondent les \u00e9l\u00e9ments s\u00e9par\u00e9s par des <code>:</code> ?</p> <p>R\u00e9ponse</p> <p>Les \u00e9l\u00e9ments s\u00e9par\u00e9s par des <code>:</code> sont les r\u00e9pertoires o\u00f9 le shell va chercher les commandes \u00e0 ex\u00e9cuter. Le premier r\u00e9pertoire est le r\u00e9pertoire personnel de l'utilisateur, puis les r\u00e9pertoires <code>/usr/local/bin</code>, <code>/usr/bin</code>, <code>/bin</code>, <code>/usr/sbin</code>, <code>/sbin</code> et d\u2019autres encore.</p> </li> <li> <p>Cr\u00e9er un r\u00e9pertoire <code>bin</code> dans votre r\u00e9pertoire personnel et entrer les commandes suivantes:     <pre><code>$ PATH=~/bin:$PATH\n$ echo $PATH\n</code></pre>     Quelle est la diff\u00e9rence avec d'affichage avec le r\u00e9sultat de la question 1 ?</p> <p>R\u00e9ponse</p> <p>Le r\u00e9pertoire <code>~/bin</code> a \u00e9t\u00e9 ajout\u00e9 au d\u00e9but du <code>PATH</code>.</p> </li> <li> <p>\u00c0 l\u2019aide de la commande <code>type</code>, chercher les chemin absolus des programmes <code>cat</code> et <code>rm</code> et les noter.</p> <p>R\u00e9ponse</p> <pre><code>$ type cat\ncat is /bin/cat\n$ type rm\nrm is /bin/rm # ou bien /usr/bin/rm (d\u00e9pend du syst\u00e8me)\n</code></pre> </li> <li> <p>Faire une copie de <code>cat</code> dans <code>~/bin</code> en le renommant <code>rm</code>.</p> <p>R\u00e9ponse</p> <pre><code>$ cp /bin/cat ~/bin/rm\n</code></pre> </li> <li> <p>Cr\u00e9er un fichier <code>fic</code>, y mettre quelques caract\u00e8res et cr\u00e9er deux copies <code>fic2</code> et <code>fic3</code> de <code>fic</code>.</p> <p>R\u00e9ponse</p> <pre><code>$ echo \"toto\" &gt; fic\n$ cp fic fic2\n$ cp fic fic3\n</code></pre> </li> <li> <p>Essayer de d\u00e9truire <code>fic</code> avec la commande <code>rm</code>. Que s\u2019est-il pass\u00e9 ?</p> <p>R\u00e9ponse</p> <p>Le contenu de <code>fic</code> est affich\u00e9 \u00e0 l\u2019\u00e9cran, mais le fichier n\u2019est pas supprim\u00e9.</p> </li> <li> <p>Entrer la commande <code>$ type rm</code>.</p> <p>R\u00e9ponse</p> <p>rm is ~/bin/rm</p> </li> <li> <p>Lancer la commande     <pre><code>$ &lt;chemin vers rm&gt; fic\n</code></pre>     en rempla\u00e7ant <code>&lt;chemin vers rm&gt;</code> par le chemin absolu vers la commande <code>rm</code> not\u00e9 \u00e0 la question 3. Que s\u2019est-il pass\u00e9 ?</p> <p>R\u00e9ponse</p> <p>Le fichier <code>fic</code> a \u00e9t\u00e9 supprim\u00e9.</p> </li> <li> <p>Enlever la permission <code>x</code> sur le fichier <code>~/bin/rm</code> et essayer de supprimer <code>fic2</code>.</p> <p>R\u00e9ponse</p> <pre><code>$ chmod -x ~/bin/rm\n$ rm fic2\nrm: impossible de supprimer 'fic2': Permission non accord\u00e9e\n</code></pre> </li> <li> <p>Demander au shell d\u2019oublier les emplacements enregistr\u00e9s (\u00ab hach\u00e9s \u00bb) avec la commande <code>$ hash -r</code>, puis entrer les commandes     <pre><code>$ type rm\n$ rm fic2\n</code></pre></p> <p>R\u00e9ponse</p> <pre><code>rm is /bin/rm\n</code></pre> <p>fic2 a \u00e9t\u00e9 supprim\u00e9. En demandant au shell d\u2019oublier les emplacements enregistr\u00e9s, il va rechercher de nouveau dans les r\u00e9pertoires du <code>PATH</code> un fichier ex\u00e9cutable qui s\u2019appelle <code>rm</code>. Comme <code>~/bin/rm</code> ne l\u2019est plus, il va trouver <code>/bin/rm</code>, qui va donc supprimer fic2.</p> </li> <li> <p>Remettre la permission <code>x</code> sur <code>~/bin/rm</code> puis entrer les commandes suivantes (o\u00f9 <code>&lt;chemin vers rm&gt;</code> d\u00e9signe le chemin absolu not\u00e9 \u00e0 la question 3) :     <pre><code>$ ~/bin/rm fic3\n$ cd ~/bin\n$ ./rm fic3\n$ &lt;chemin vers rm&gt; rm\n$ rm fic3\n</code></pre></p> <p>R\u00e9ponse</p> <p>Si un nom de commande contient un slash, le <code>PATH</code> n\u2019est pas utilis\u00e9, et le nom de commande est interpr\u00e9t\u00e9 comme un chemin vers un fichier qui contient le programme qui sera lanc\u00e9. Ainsi, la commande <code>~/bin/rm fic3</code> lance le programmme <code>~/bin/rm</code> (qui est une copie de <code>cat</code>). De m\u00eame pour <code>./rm</code> avec un chemin relatif si l\u2019on est dans le r\u00e9pertoire <code>~/bin</code>.</p> <p>En revanche, <code>rm</code> ne contient pas d\u2019oblique donc le shell cherche dans le <code>PATH</code>. Comme <code>~/bin/rm</code> n\u2019existe plus, c\u2019est <code>/bin/rm</code> (ou <code>/usr/bin/rm</code>, d\u00e9pend du syst\u00e8me) qui est trouv\u00e9 et fic3 est supprim\u00e9.</p> </li> <li> <p>Faire le bilan de cet exercice en r\u00e9pondant aux questions suivantes :</p> <ul> <li>Qu'est-ce qui est contenu dans <code>PATH</code> ?</li> <li>Dans quel cas est-ce qu\u2019un nom de commande est cherch\u00e9 dans les r\u00e9pertoires du <code>PATH</code> ?</li> <li>S\u2019il y a plusieurs programmes correspondants dans les r\u00e9pertoires du <code>PATH</code>, lequel est choisi ?</li> </ul> <p>R\u00e9ponse</p> <ul> <li><code>PATH</code> contient les r\u00e9pertoires o\u00f9 le shell va chercher les commandes \u00e0 ex\u00e9cuter.</li> <li>Un nom de commande est cherch\u00e9 dans les r\u00e9pertoires du <code>PATH</code> si le nom de commande ne contient pas de slash.</li> <li>Si plusieurs programmes correspondent, c\u2019est le premier trouv\u00e9 dans le <code>PATH</code> qui est choisi.</li> </ul> </li> </ol>"},{"location":"contenus/corrige-tp2/#recapitulatif-sur-permissions-et-permissions-par-defaut","title":"R\u00e9capitulatif sur permissions et permissions par d\u00e9faut","text":""},{"location":"contenus/corrige-tp2/#exercice-7-on-lache-le-clavier","title":"Exercice 7: On lache le clavier","text":"<p>Consigne</p> <p>Cet exercice est \u00e0 faire \u00e0 l\u2019\u00e9crit, on l\u00e2che le clavier !</p> <p>Pour chacune des commandes suivantes, dire quelles permissions sont n\u00e9cessaires pour qu\u2019elle r\u00e9ussisse (on suppose que tous les r\u00e9pertoires et fichiers existent, sauf ceux qu\u2019on veut cr\u00e9er).</p> <pre><code>$ cat /usr/include/stdio.h\n$ cd /usr/include/\n$ ls /usr/include/\n$ echo '/* fin */' &gt;&gt; /usr/include/stdio.h\n$ rm /usr/include/stdio.h\n$ touch /usr/include/ma_bib.h\n$ chmod u+w /usr/include/stdio.h\n$ /usr/bin/uname\n</code></pre> <p>R\u00e9ponses</p> <p>Pour toutes les questions, on doit au minimum avoir la permission <code>x</code> sur les r\u00e9pertoires <code>/</code> et <code>/usr</code> pour pouvoir les traverser. Ensuite, pour les commandes :</p> <ul> <li><code>cat /usr/include/stdio.h</code> : il faut la permission de lecture sur <code>/usr/include/stdio.h</code> et <code>x</code> sur <code>/usr/include/</code>.</li> <li><code>cd /usr/include/</code> : il faut la permission <code>x</code> sur <code>/usr/include/</code>.</li> <li><code>ls /usr/include/</code> : il faut la permission <code>r</code> sur <code>/usr/include/</code>.</li> <li><code>echo '/* fin */' &gt;&gt; /usr/include/stdio.h</code> : il faut la permission <code>w</code> sur <code>/usr/include/stdio.h</code> et <code>x</code> sur <code>/usr/include/</code>.</li> <li><code>rm /usr/include/stdio.h</code> : il faut la permission <code>wx</code> sur <code>/usr/include/</code>.</li> <li><code>touch /usr/include/ma_bib.h</code> : il faut la permission <code>wx</code> sur <code>/usr/include/</code>.</li> <li><code>chmod u+w /usr/include/stdio.h</code> : il faut la permission <code>x</code> sur <code>/usr/include/</code> et \u00eatre soit root soit le propri\u00e9taire de <code>/usr/include/stdio.h</code>.</li> <li><code>/usr/bin/uname</code> : il faut la permission <code>x</code> sur <code>/usr/bin/</code> et <code>x</code> sur <code>/usr/bin/uname</code>.</li> </ul>"},{"location":"contenus/corrige-tp2/#exercice-5-umask-en-plus","title":"Exercice 5 : <code>umask</code> (en plus)","text":"<ol> <li> <p>Dans un terminal, tapez la commande <code>umask</code> et notez le r\u00e9sultat.</p> <p>R\u00e9ponse</p> <p>La r\u00e9ponse d\u00e9pend du syst\u00e8me, les valeurs 0022 et 0002 sont les plus courantes.</p> </li> <li> <p>Cr\u00e9ez un r\u00e9pertoire <code>rep</code> et un fichier <code>f</code> au m\u00eame niveau que <code>rep</code>. Affichez les permissions associ\u00e9es \u00e0 <code>rep</code> et <code>f</code> avec la commande <code>ls -ld rep f</code>. Convertissez ces permissions en repr\u00e9sentation octale et notez-les. Enfin, supprimez <code>rep</code> et <code>f</code>.</p> <p>R\u00e9ponse</p> <ul> <li>Dans le cas 0022 on trouve pour le fichier normal 0644 et pour le r\u00e9pertoire 0755. </li> <li>Dans le cas 0002 on trouve 0664 et 0775.</li> </ul> </li> <li> <p>Changez la valeur du masque avec la commande     <pre><code>$ umask 240\n</code></pre>     puis refaites la question pr\u00e9c\u00e9dente.</p> <p>R\u00e9ponse</p> <p>0426 pour le fichier normal, et 0537 pour le r\u00e9pertoire.</p> </li> <li> <p>Changez la valeur du masque avec la commande     <pre><code>$ umask 121\n</code></pre>     puis refaites la question 2.</p> <p>R\u00e9ponse</p> <p>0646 pour le fichier normal, et 0656 pour le r\u00e9pertoire.</p> </li> <li> <p>Changez la valeur du masque avec la commande     <pre><code>$ umask 666\n</code></pre>     puis refaites la question 2.</p> <p>R\u00e9ponse</p> <p>0000 pour le fichier normal, et 0111 pour le r\u00e9pertoire.</p> </li> <li> <p>De toutes les questions pr\u00e9c\u00e9dentes, pouvez-vous d\u00e9duire comment la valeur de l'umask agit sur les permissions associ\u00e9es aux r\u00e9pertoires et aux fichiers que vous cr\u00e9ez ?</p> <p>R\u00e9ponse</p> <p>Les fichiers normaux cr\u00e9\u00e9s ont des permissions qui sont le r\u00e9sultat de l\u2019op\u00e9ration bit \u00e0 bit <code>0666 &amp; ~umask</code>, c\u2019est-\u00e0-dire qu\u2019on enl\u00e8ve les permissions pr\u00e9sentes dans le masque \u00e0 celle de 0666. Pour le r\u00e9pertoire, on enl\u00e8ve les permissions pr\u00e9sentes dans le masque \u00e0 <code>0777</code>. Peut-\u00eatre qu\u2019en passant en binaire, c\u2019est davantage compr\u00e9hensible.</p> <p>Par exemple pour le umask 240, on a <pre><code>umask (240) 000 010 100 000\n~umask      111 101 011 111\n\n0666        000 110 110 110   # &amp; logique\n~umask      111 101 011 111\n---------------------------\n            000 100 010 110   # Ce qui donne 0426\n</code></pre></p> </li> <li> <p>Donnez \u00e0 l'umask sa valeur initiale.</p> </li> </ol>"},{"location":"contenus/corrige-tp3/","title":"TP3 - Environnement de travail et Compilateur C (Corrig\u00e9)","text":""},{"location":"contenus/corrige-tp3/#les-variables-du-shell","title":"Les variables du shell","text":""},{"location":"contenus/corrige-tp3/#exercice-1-les-variables-du-shell","title":"Exercice 1 : Les variables du Shell","text":"<ol> <li>Tapez les commandes suivantes dans un terminal:     <pre><code>$ nom_fich=hello.c\n$ echo nom_fich\n$ echo $nom_fich\n$ echo ${nom_fich}\n$ touch $nom_fich\n$ echo $nom_fichpp\n$ echo ${nom_fich}pp\n$ rm ${nom_fich}\n</code></pre></li> <li> <p>Rappelez ce que fait la commande <code>echo</code>. \u00c0 votre avis que fait la commande \u00e0 quoi sert le caract\u00e8re <code>$</code> devant le nom de la variable <code>nom_fich</code>?</p> <p>R\u00e9ponse</p> <p><code>echo</code> affiche sur la sortie standard ses arguments. Le <code>$</code> devant le nom de variable <code>nom_fich</code> permet le d\u00e9veloppement de celle-ci par le shell.</p> </li> <li> <p>Que se passe-t-il si on demande au shell d'afficher le contenu d'une variable qui n'existe pas?</p> <p>R\u00e9ponse</p> <p>Le r\u00e9sultat du d\u00e9veloppement d'une variable non d\u00e9finie est une cha\u00eene vide.</p> </li> <li> <p>Que se passe-t-il si vous mettez un espace entre le nom de la variable et le signe \u00e9gal <code>=</code>? Et entre le signe \u00e9gal et la valeur?</p> <p>R\u00e9ponse</p> <p>On aura une \u00ab commande \u00bb inconnue sur le premier mot. Il ne doit pas y avoir d\u2019espace d\u2019un c\u00f4t\u00e9 ou de l\u2019autre du signe <code>=</code>.</p> </li> <li> <p>Entrez les commandes suivantes et essayez de commenter leur effet:     <pre><code>$ sujet=Alice verbe=aime cod=piscine\n$ phrase =\"$sujet $verbe la $cod.\"\n$ echo $phrase\n$ sujet=Bob verbe=mange cod=salade\n$ echo $phrase\n$ echo \"$sujet $verbe la $cod.\"\n</code></pre></p> <p>R\u00e9ponse</p> <p>Au moment de l\u2019affectation de <code>phrase</code>, les variables <code>sujet</code>, <code>verbe</code> et <code>cod</code> sont d\u00e9velopp\u00e9es, donc la variable <code>phrase</code> ne change pas de valeur, m\u00eame si ces premi\u00e8res en changent.</p> <p>Autre remarque : on peut affecter plusieurs variables sur la m\u00eame ligne (ce n\u2019est pas forc\u00e9ment utile tout de suite mais \u00e7a le sera lorsqu\u2019on voudra changer l\u2019environnement d\u2019une commande).</p> </li> </ol>"},{"location":"contenus/corrige-tp3/#caracteres-speciaux-et-inhibitions","title":"Caract\u00e8res sp\u00e9ciaux et inhibitions","text":"<p>Caract\u00e8res sp\u00e9ciaux du shell</p> <p>Certains caract\u00e8res ont une signification particuli\u00e8re pour le shell : on dit qu\u2019ils sont sp\u00e9ciaux. \u00c0 l\u2019inverse, on dit d\u2019un caract\u00e8re qui n\u2019a pas d\u2019autre signification que lui-m\u00eame, qu\u2019il a son sens litt\u00e9ral. Nous listons ci-dessous les caract\u00e8res sp\u00e9ciaux ; la plupart d\u2019entre eux seront vus en d\u00e9tail plus tard dans le cours.</p> <ul> <li><code>; &lt;newline&gt; | &amp;</code> ils mettent fin \u00e0 la commande qui les pr\u00e9c\u00e8de. On a utilis\u00e9 <code>&lt;newline&gt;</code> pour repr\u00e9senter le caract\u00e8re nouvelle ligne qu\u2019on saisit avec la touche Entr\u00e9e. Le caract\u00e8re sp\u00e9cial <code>|</code> est saisi avec la combinaison de touches <code>Alt Gr-6</code>, on l\u2019appelle pipe ou conduite.</li> <li><code>&lt; &gt;</code> appel\u00e9s chevrons, ils permettent les redirections.</li> <li><code>( )</code> pour regrouper des commandes et les lancer dans un sous-shell.</li> <li><code>$</code> pour le d\u00e9veloppement de variables, le d\u00e9veloppement arithm\u00e9tique et la substitution de commande.</li> <li><code>`</code> l\u2019accent grave (en anglais, backtick ou backquote) pour la substitution de commandes (ancienne syntaxe). Il est saisi au clavier avec la combinaison de touches <code>Alt Gr-7</code> suivie d\u2019un espace.</li> <li><code>&lt;space&gt; &lt;tab&gt;</code> d\u00e9limitent les noms de commandes et arguments.</li> <li><code>\\ ' \"</code> la contre-oblique (aussi appel\u00e9e backslash ou antislash), l\u2019apostrophe (en anglais single quote) et le guillemet anglais (en anglais double quote) qui permettent justement d\u2019inhiber les caract\u00e8res sp\u00e9ciaux, c\u2019est-\u00e0-dire leur rendre leur sens litt\u00e9ral.</li> </ul> <p>Enfin, les caract\u00e8res suivants ont une signification particuli\u00e8re dans certains contextes et doivent donc parfois \u00eatre inhib\u00e9s:</p> <ul> <li><code>* ? ]</code> Pour le d\u00e9veloppement de noms de chemins.</li> <li><code>#</code> Pour \u00e9crire des commentaires (sauf s\u2019il est au milieu d\u2019un mot).</li> <li><code>~</code> Pour le d\u00e9veloppement du tilde (r\u00e9pertoire personnel).</li> <li><code>=</code> Pour l\u2019affectation de variables.</li> <li><code>%</code> Pour le contr\u00f4le des t\u00e2ches (job control).</li> </ul>"},{"location":"contenus/corrige-tp3/#exercice-2-inhibition-de-caracteres-speciaux-la-contre-oblique","title":"Exercice 2 : Inhibition de caract\u00e8res sp\u00e9ciaux (la contre-oblique <code>\\</code>)","text":"<ol> <li> <p>Testez les commandes suivantes.     <pre><code>$ echo a b\n$ echo a\\ \\ \\ b\n$ touch fichier\\ vide\n$ rm fichier vide\n$ rm fichier\\ vide\n$ echo 3$canadiens\n$ echo 3\\$canadiens\n$ echo ; echo *\n$ echo \\; echo \\*\n$ echo \"salut\"\n$ echo \\\"salut\\\"\n$ echo 'salut'\n$ echo \\'salut\\'\n$ echo \\\n$ echo \\\\\n</code></pre></p> <p>R\u00e9ponse</p> <ul> <li>Deux arguments : a et b.</li> <li>Un seul argument car les 3 blancs ont \u00e9t\u00e9 inhib\u00e9s.</li> <li>Un seul argument (blanc inhib\u00e9).</li> <li>Deux arguments, la commande \u00e9choue.</li> <li>Un seul argument.</li> <li>La variable non d\u00e9finie $canadiens est d\u00e9velopp\u00e9e en la cha\u00eene vide.</li> <li>Le caract\u00e8re <code>$</code> est inhib\u00e9 donc litt\u00e9ral.</li> <li>Deux commandes, le <code>;</code> a son r\u00f4le sp\u00e9cial de terminateur de commande (on dit aussi op\u00e9rateur de contr\u00f4le) et l\u2019ast\u00e9risque a son r\u00f4le sp\u00e9cial de caract\u00e8re joker. On aura deux lignes affich\u00e9es, la premi\u00e8re est vide, la seconde contient la liste des fichiers du r\u00e9pertoire courant.</li> <li>Une seule commande echo avec trois arguments : un <code>;</code>, le mot <code>echo</code> et un caract\u00e8re <code>*</code>.</li> <li>Les guillemets anglais sont sp\u00e9ciaux, ils inhibent certains caract\u00e8res sp\u00e9ciaux dans salut (en l\u2019occurence il n\u2019y en a pas) puis sont enlev\u00e9s par le shell.</li> <li>Ils sont inhib\u00e9s, donc trait\u00e9s comme n\u2019importe quel caract\u00e8re et apparaissent dans la cha\u00eene affich\u00e9e.</li> <li>Idem avec l\u2019apostrophe.</li> <li>Idem avec l\u2019apostrophe.</li> <li>Un prompt secondaire appara\u00eet, on doit appuyer sur entr\u00e9e pour terminer la commande : on a en fait une commande sur deux lignes qui est un <code>echo</code> sans argument.</li> <li>La contre-oblique retrouve son sens litt\u00e9ral.</li> </ul> </li> <li> <p>En vous r\u00e9f\u00e9rent aux questions pr\u00e9c\u00e9dentes, r\u00e9pondez aux questions ci dessous:</p> <ul> <li> <p>Que fait le caract\u00e8re <code>\\</code> devant un autre caract\u00e8re que <code>&lt;newline&gt;</code> (on rappelle que le caract\u00e8re <code>&lt;newline&gt;</code> est celui qui r\u00e9sulte de l'appui de la touche Entr\u00e9e du clavier) ?</p> <p>R\u00e9ponse</p> <p>Le caract\u00e8re <code>\\</code> pr\u00e9serve le sens litt\u00e9ral du prochain caract\u00e8re (sauf <code>&lt;newline&gt;)</code> puis est enlev\u00e9 par le shell.</p> </li> <li> <p>\u00c0 quoi sert la cha\u00eene de caract\u00e8res <code>\\&lt;newline&gt;</code> ?</p> <p>R\u00e9ponse</p> <p>La s\u00e9quence <code>\\&lt;newline&gt;</code> permet d\u2019\u00e9crire une commande sur plusieurs ligne. Ces deux caract\u00e8res sont supprim\u00e9s de la commande par le shell</p> </li> <li> <p>Comment peut-on obtenir un caract\u00e8re <code>\\</code> litt\u00e9ral ? Comment afficher <code>\\\\</code> \u00e0 l'aide de la commande <code>echo</code> ?</p> <p>R\u00e9ponse</p> <p>La s\u00e9quence <code>\\\\</code> est interpr\u00e9t\u00e9e comme une contre-oblique litt\u00e9rale. Pour afficher <code>\\\\</code> avec <code>echo</code>, on peut entrer la commande <code>echo \\\\\\\\</code>.</p> </li> </ul> </li> </ol>"},{"location":"contenus/corrige-tp3/#exercice-3-linhibition-des-caracteres-speciaux-lapostrophe","title":"Exercice 3 : L\u2019inhibition des caract\u00e8res sp\u00e9ciaux (l'apostrophe <code>'</code>)","text":"<ol> <li> <p>Tester les commandes suivantes : <pre><code>$ touch 'ceci est un horrible nom de fichier'\n$ rm -i ceci est un horrible nom de fichier\n$ rm -i 'ceci est un horrible nom de fichier'\n$ touch p; echo le caract\u00e8re * est-il sp\u00e9cial ? et ?\n$ echo 'le caract\u00e8re * est-il sp\u00e9cial ? et ?'\n$ echo 'en fait ,m\u00eame la fin de ligne&lt;newline&gt;est un caract\u00e8re normal entre&lt;newline&gt;apostrophes'\n$ echo 'le seul caract\u00e8re sp\u00e9cial entre apostrophes n'est-il pas apostrophe ?'\n</code></pre>     o\u00f9 <code>&lt;newline&gt;</code> sera \u00e0 taper avec la touche Entr\u00e9e de votre clavier.</p> </li> <li> <p>Au vu des exp\u00e9riences pr\u00e9c\u00e9dentes (et d\u2019autres \u00e0 inventer si n\u00e9cessaire), r\u00e9pondre aux questions suivantes :</p> <ul> <li>Quels sont les caract\u00e8res qui sont sp\u00e9ciaux entre apostrophes ?</li> <li>Comment obtenir une apostrophe dans une cha\u00eene entre apostrophes (question pi\u00e8ge) ?</li> <li>Comment, avec une combinaison de cha\u00eenes entre apostrophes et d\u2019une inhibition par contre-oblique, obtenir avec `echo`` l\u2019affichage suivant ?     <pre><code>Un d\u00e9veloppement de variable (comme $var) peut-il s'inhiber; par exemple entre apostrophes ?\n</code></pre></li> </ul> <p>R\u00e9ponse</p> <p>Dans une cha\u00eene entre apostrophe, tous les caract\u00e8res sont litt\u00e9raux, y compris les espaces et les fins de ligne, sauf l\u2019apostrophe elle-m\u00eame qui met fin \u00e0 l\u2019inhibition. On ne peut donc pas mettre d\u2019apostrophe \u00e0 l\u2019int\u00e9rieur d\u2019une cha\u00eene entre apostrophes. Si besoin, on peut toujours utiliser la s\u00e9quence <code>'\\''</code> pour mettre fin \u00e0 la cha\u00eene entre apostrophe, taper une apostrophe inhib\u00e9e et recommencer une cha\u00eene entre apostrophes, comme dans la derni\u00e8re question :</p> <pre><code>$ echo 'Un d\u00e9veloppement de variable (comme $var) peut s '\\''inhiber; par exemple entre apostrophes.' \n</code></pre> </li> </ol>"},{"location":"contenus/corrige-tp3/#exercice-4-linhibition-des-caracteres-speciaux-les-guillemets-anglais","title":"Exercice 4 : L\u2019inhibition des caract\u00e8res sp\u00e9ciaux (les guillemets anglais <code>\"</code>)","text":"<ol> <li>Tester les commandes suivantes et notez vos observation: <pre><code>$ echo \"? * et [ sont utilis\u00e9s pour le d\u00e9veloppement de chemins\"\n$ echo \"~ provoque un d\u00e9veloppement du tilde\"\n$ echo \" Entre \\\" , on peut aussi &lt;newline&gt;\u00e9crire sur plusieurs&lt;newline&gt; lignes\"\n$ nom=Alice\n$ echo '$nom scripte en shell'\n$ echo \"$nom scripte en shell\"\n$ echo \"\\$nom scripte en shell\"\n$ echo \"le chemin absolu du r\u00e9pertoire courant est `pwd`\"\n$ echo \"le chemin absolu du r\u00e9pertoire courant est \\`pwd\\`\"\n$ echo \"le chemin absolu du r\u00e9pertoire courant est $(pwd)\"\n$ echo \"le chemin absolu du r\u00e9pertoire courant est \\$(pwd)\"\n$ echo \"Aussi s\u00fbr que 2 et 2 font $((2 + 2))\"\n$ echo \"Aussi s\u00fbr que 2 et 2 font \\$((2 + 2))\"\n$ echo \"\\\\\\\\\\\"\\$\\`\\*\\'\"\n</code></pre></li> <li>Testez les commande suivantes et notez vos observations: <pre><code>$ mavar =\"Alice&lt;newline&gt; et&lt;newline&gt;Bob\"\n$ echo $mavar font plein de choses\n$ echo \"$mavar font plein de choses\"\n</code></pre></li> <li> <p>Au vu des exp\u00e9riences pr\u00e9c\u00e9dentes (et d\u2019autres \u00e0 inventer si n\u00e9cessaire), r\u00e9pondre aux questions suivantes :</p> <ul> <li>Quels sont les caract\u00e8res qui sont sp\u00e9ciaux entre guillemets anglais ?</li> <li>Quel est le r\u00f4le du caract\u00e8re  entre guillemets anglais ? Dans quel contexte est-il sp\u00e9cial, litt\u00e9ral ?</li> <li>Quels sont les d\u00e9veloppements qui n\u2019ont jamais lieu entre guillemets anglais ?</li> <li>Selon vous, pourquoi avoir cr\u00e9\u00e9 plusieurs m\u00e9canismes d\u2019inhibition ?</li> </ul> <p>R\u00e9ponse</p> <p>Les seuls caract\u00e8res sp\u00e9ciaux dans une cha\u00eene entre guillemets sont <pre><code>                            $ ` \" \\ \n</code></pre> Les d\u00e9veloppements de variable, arithm\u00e9tique (<code>$((...))</code>) et la substitution de commande (<code>$(...)</code> ou <code>`...`</code>) ont encore lieu. Bien s\u00fbr le guillement est sp\u00e9cial car il met fin \u00e0 l\u2019inhibition. On peut rendre \u00e0 ces caract\u00e8res leur sens litt\u00e9ral en les pr\u00e9c\u00e9dant d\u2019une contre-oblique. Laquelle est donc aussi sp\u00e9ciale, mais seulement lorsqu\u2019elle pr\u00e9c\u00e8de l\u2019un de ces quatre caract\u00e8res sp\u00e9ciaux.</p> <p>Les d\u00e9veloppements du tilde et de noms de chemins n\u2019ont jamais lieu dans une cha\u00eene entre guillemets.</p> <p>Il y a plusieurs m\u00e9canismes d\u2019inhibition pour pouvoir contr\u00f4ler \u00e0 quel point le shell met sonnez dans nos affaires. De plus (sens du dernier exemple), il fallait trouver une fa\u00e7on d\u2019inhiber le m\u00e9canisme (subtil) de la s\u00e9paration en mots (word splitting) des r\u00e9sultats des d\u00e9veloppements de variable, arithm\u00e9tique et substitution de commande.</p> </li> </ol>"},{"location":"contenus/corrige-tp3/#extensions-de-chemins","title":"Extensions de chemins","text":""},{"location":"contenus/corrige-tp3/#exercice-5-des-fichiers-et-des-images","title":"Exercice 5 : Des fichiers et des images","text":"<ol> <li>Cr\u00e9er un r\u00e9pertoire <code>dir</code> et y cr\u00e9er les fichiers vides <code>file-1.txt</code>, <code>file-2.txt</code>, <code>file-3.txt</code>, <code>file-4.txt</code>, <code>file-5.txt</code>, <code>file-6.txt</code>, <code>file-7.txt</code>, <code>file-8.txt</code>, <code>file-9.txt</code>, <code>config-a.txt</code>, <code>file-b.txt</code>.</li> <li>Cr\u00e9er \u00e9galement dans <code>dir</code> les fichiers vides suivants <code>img-1.png</code>, <code>img-2.png</code>, <code>img-3.png</code>, <code>img-4.png</code>, <code>img-5.png</code>, <code>img-6.png</code>, <code>img-7.png</code>, <code>img-8.png</code>, <code>img-9.png</code>.</li> <li>Cr\u00e9er ensuite dans <code>dir</code> deux sous-r\u00e9pertoires <code>files</code> et <code>imgs</code>. </li> <li> <p>En vous aidant de l'extension de chemin et de la commande <code>mv</code>, d\u00e9placer les fichiers <code>.txt</code> dans le r\u00e9pertoire <code>files</code>. Fa\u00eetes de m\u00eame pour les fichiers <code>.png</code> dans le r\u00e9pertoire <code>imgs</code>.</p> <p>R\u00e9ponse<p><pre><code># En partant de dir\n$ mv *.txt files/\n$ mv *.png imgs/\n</code></pre> N'h\u00e9sitez pas \u00e0 leur sugg\u00e9rer d'utiliser <code>tree dir</code> pour voir que tout est bon.</p> </p> </li> <li> <p>Donnez l'expression qui reconnais les fichiers <code>config-a.txt</code> et <code>file-b.txt</code>. Puis supprimez les fichiers correspondants \u00e0 cette expression. (Gr\u00e2ce \u00e0 l'extension de chemin, vous pouvez le faire en une seule commande).</p> <p>R\u00e9ponse</p> <p>L'expression qui reconna\u00eet peut \u00eatre par exemplle <code>*-[ab].txt</code>. Donc pour les supprimer si on est dans <code>dir</code> c'est la commande  <pre><code>$ rm */*-[ab].txt\n</code></pre></p> </li> <li> <p>Supprimez le r\u00e9pertoire <code>dir</code> et son contenu.</p> </li> </ol>"},{"location":"contenus/corrige-tp3/#exercice-6-extension-de-laccolade","title":"Exercice 6 : Extension de l'accolade","text":"<ol> <li>Testez les commandes suivantes     <pre><code>$ echo {a, b, c, d}\n$ echo {a..d}\n$ echo {a..d..2}\n$ echo {1,2,3,4,5,6,7,8,9}\n$ echo {1..9}\n$ echo {1..9..2}\n</code></pre></li> <li> <p>Que fait la commande <code>echo {a..d}</code> ? Quel est le r\u00f4le de la virgule <code>,</code> dans l'extension de l'accolade ?</p> <p>R\u00e9ponse</p> <p>Cette commande affiche la s\u00e9quence <code>a b c d</code>. La virgule joue un r\u00f4le de s\u00e9parateur.</p> </li> <li> <p>Que fait la commande <code>echo {a..d..2}</code> ? Quel est le r\u00f4le du <code>2</code> dans l'extension de l'accolade ?</p> <p>R\u00e9ponse</p> <p>Cette commande affiche la s\u00e9quence <code>a c</code>.Le <code>2</code> indique le pas d'incr\u00e9mentation.</p> </li> <li> <p>Testez les commandes suivantes, et observez leur r\u00e9sultats.     <pre><code>$ echo {a..d}*\n$ echo {a..d}.*\n$ echo {a..d}.txt\n</code></pre></p> </li> <li> <p>Cr\u00e9er un r\u00e9pertoire <code>dir</code>. D\u00e9placez-vous y. En utilisant l'extension de l'accolade, en une seule commande, cr\u00e9er les fichiers vides <code>file-1.txt</code>, <code>file-2.txt</code>, <code>file-3.txt</code>, <code>file-4.txt</code>, <code>file-5.txt</code>, <code>file-6.txt</code>, <code>file-7.txt</code>, <code>file-8.txt</code>, <code>file-9.txt</code>.</p> <p>R\u00e9ponse</p> <pre><code>$ mkdir dir\n$ cd dir\n$ touch file-{1..9}.txt\n</code></pre> </li> <li> <p>D\u00e9placez tous les fichiers <code>.txt</code> dans un r\u00e9pertoire <code>dir/files</code>.</p> <p>R\u00e9ponse</p> <pre><code>$ mkdir files\n$ mv file-{1..9}.txt files # ou \n$ mv *.txt files\n</code></pre> </li> <li> <p>Cr\u00e9er un r\u00e9pertoire <code>dir/imgs</code>. D\u00e9placez-vous y. En utilisant l'extension de l'accolade, en une seule commande, cr\u00e9\u00e9er les fichiers vides <code>img001.png</code>, <code>img002.png</code>, <code>img003.png</code>, <code>img004.png</code>, <code>img005.png</code>, <code>img006.png</code>, <code>img007.png</code>, <code>img008.png</code>, <code>img009.png</code>.</p> <p>R\u00e9ponse</p> <pre><code>$ mkdir imgs\n$ cd imgs\n$ touch img-{001..009}.png \n</code></pre> </li> <li> <p>Supprimez le r\u00e9pertoire <code>dir</code> et tout son contenu.</p> </li> </ol>"},{"location":"contenus/corrige-tp3/#substitution-de-commande","title":"Substitution de commande","text":"<p>Substitution de commande</p> <p>La substitution de commanande est un m\u00e9canisme qui permet d\u2019ins\u00e9rer le r\u00e9sultat d\u2019une commande dans une cha\u00eene de caract\u00e8res. </p> <p>La substitution de commandes dans une cha\u00eene de caract\u00e8res est une autre facilit\u00e9 offerte par le shell. Elle permet de capturer la sortie d'une commande et de l'assigner \u00e0 une variable ou de l'utiliser comme un argument d'une autre commande. Comme beaucoup de commandes UNIX g\u00e9n\u00e8rent une sortie, la substitution de commandes peut \u00eatre tr\u00e8s int\u00e9ressante. </p> <p>Il existe deux syntaxes pour la substitution de commande : la syntaxe ancienne avec les accents graves (<code>`</code>) et la syntaxe moderne avec les parenth\u00e8ses <code>$(...)</code>. La syntaxe ancienne est d\u00e9conseill\u00e9e car elle ne permet pas d\u2019imbriquer les substitutions de commande. Nous ne la pr\u00e9senterons donc pas ici.</p>"},{"location":"contenus/corrige-tp3/#exercice-7-substitution-de-commande-simple","title":"Exercice 7 : Substitution de commande simple","text":"<ol> <li>Testez les commandes suivantes et observez leur r\u00e9sultat: <pre><code>$ date\n$ echo date\n$ echo $(date)\n$ aujourdhui=$(date)\n$ echo $aujourdhui\n$ echo \"Nous sommes le $(date)\"\n</code></pre></li> <li> <p>Que fait la commande <code>echo $(date)</code> ? Quel est le r\u00f4le du <code>$</code> devant la parenth\u00e8se ouvrante <code>(</code> ?</p> <p>R\u00e9ponse</p> <p>Pour <code>echo $(date)</code>, le shell d\u00e9veloppe d'abord la commande <code>date</code> puis elle va afficher le r\u00e9sultat de la commande (puisque c'est ce r\u00e9sultat qui sera donn\u00e9 en argument de <code>echo</code>). Ici il n'y a pas de diff\u00e9rence entre <code>date</code> et <code>echo $(date)</code>. <code>$(...)</code> indique la subsiturion de commande.</p> </li> <li> <p>Tapez ensuite les commandes suivantes et observez leur r\u00e9sultat: <pre><code>$ prefix=\"Nous sommes le\"\n$ echo $prefix $(date)\n$ echo $prefix $aujourdhui\n$ echo ${prefix} ${ajourdhui}\n$ phrase=${prefix} ${ajourdhui}\n$ phrase=\"${prefix} ${ajourdhui}\"\n$ echo $phrase\n$ echo \"$phrase\"\n</code></pre></p> </li> <li> <p>Pouvez-vous d\u00e9duire le r\u00f4le des guillemets anglais dans la substitution de commande et le d\u00e9veloppemt de variable?</p> <p>R\u00e9ponse</p> <p>Les doubles quotes permettent de concatener dans une m\u00eame cha\u00eene de caract\u00e8res le r\u00e9sultat d'une substitution de commande et du d\u00e9veloppement de variable. </p> </li> <li> <p>Quelle est la diff\u00e9rence entre <code>$(...)</code> et <code>${...}</code> ?</p> <p>R\u00e9ponse</p> <p>La premi\u00e8re sert \u00e0 la substitution de commande et la deuxi\u00e8me au d\u00e9veloppement de variable.</p> </li> </ol>"},{"location":"contenus/corrige-tp3/#exercice-8-substitution-de-commande-imbriquee","title":"Exercice 8 : Substitution de commande imbriqu\u00e9e","text":"<ol> <li> <p>Testez les commandes suivantes et observez leur r\u00e9sultat:     <pre><code>$ echo $(date)\n$ echo $(echo $(date))\n$ echo $(echo $(echo $(date)))\n$ echo $(echo $(echo $(echo $(date))))\n$ echo $(echo $(echo $(echo $(echo $(date)))))\n</code></pre></p> <p>R\u00e9ponse</p> <p>Le r\u00e9sultat est toujours le m\u00eame. </p> </li> <li> <p>Testez ensuite la commande suivante:     <pre><code>$ echo\n</code></pre>     Sans ex\u00e9cuter la commande qui suit saurez vous pr\u00e9dire son r\u00e9sultat ?     <pre><code>$ echo $(echo $(echo $(echo $(echo))))\n</code></pre></p> <p>R\u00e9ponse</p> <p>Le r\u00e9sultat est le m\u00eame que <code>echo</code> sans argument.</p> </li> </ol>"},{"location":"contenus/corrige-tp3/#compilation-de-programme-c","title":"Compilation de programme C","text":"<p>Le compilateur C de Linux</p> <p><code>gcc</code> est le compilateur C de Linux. Il permet de compiler du code C. Il est tr\u00e8s utilis\u00e9 par les d\u00e9veloppeurs. Il est tr\u00e8s complet et poss\u00e8de de nombreuses fonctionnalit\u00e9s. Nous allons voir un aper\u00e7u de son utilisation.</p> <p>La compilation d'un programme en C passe par plusieurs \u00e9tapes, qui sont essentiellement les suivantes:</p> <ul> <li>La pr\u00e9compilation : elle permet de transformer le code source en un code interm\u00e9diaire.</li> <li>La compilation : elle permet de transformer le code interm\u00e9diaire en code machine.</li> <li>L'\u00e9dition des liens : elle permet de lier le code machine avec les biblioth\u00e8ques utilis\u00e9es.</li> <li>La cr\u00e9ation de l'ex\u00e9cutable : elle permet de cr\u00e9er l'ex\u00e9cutable.</li> </ul>"},{"location":"contenus/corrige-tp3/#exercice-9-le-compilateur-gcc","title":"Exercice 9 - Le compilateur <code>gcc</code>","text":"<ol> <li>Cr\u00e9er un fichier <code>hello.c</code> dont le contenu est le suivant:     <pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(\"Hello world !\\n\");\n    return 0;\n}\n</code></pre></li> <li> <p>Placez-vous ensuite dans le r\u00e9pertoire contenant votre fichier <code>hello.c</code> et tapez la commande <code>gcc hello.c</code>. Cette commande va compiler votre programme et cr\u00e9er un fichier <code>a.out</code> qui est l'ex\u00e9cutable de votre programme. Tapez enfin la commande <code>./a.out</code> pour ex\u00e9cuter votre programme.</p> <p>Attention</p> <ul> <li>Si vous avez d\u00e9j\u00e0 un fichier <code>a.out</code> dans votre r\u00e9pertoire, il sera \u00e9cras\u00e9 par la commande <code>gcc hello.c</code>.</li> <li><code>a.out</code> est le nom par d\u00e9faut de l'ex\u00e9cutable cr\u00e9\u00e9 par <code>gcc</code>. Vous pouvez changer ce nom en utilisant l'option <code>-o</code> de <code>gcc</code>. Par exemple, <code>gcc hello.c -o hello</code> va cr\u00e9er un ex\u00e9cutable <code>hello</code> au lieu de <code>a.out</code>.</li> </ul> </li> <li> <p>R\u00e9cup\u00e9rez ensuite cette archive hello.tar.gz.</p> </li> <li>Extraire les fichiers de cet archive et d\u00e9placez vos dans le r\u00e9pertoire <code>hello</code> qui en sera extrait. Vous pouvez le faire grace \u00e0 la commande suivate: <pre><code>$ tar -xvf hello.tar.gz\n</code></pre></li> <li>Tapez la commande  <pre><code>$ gcc main.c hello.c -o run\n</code></pre> pour compiler votre programme. Cette commande va compiler votre programme et cr\u00e9er un fichier <code>run</code> qui est l'ex\u00e9cutable de votre programme. Ex\u00e9cutez enfin votre programme avec la commande <code>./run</code>. </li> <li>Supprimer le fichier <code>run</code> et modifier ensuite le fichier <code>hello.c</code> de tel sorte \u00e0 avoir volontairement une erreur : supprimer l'accolade fermante de la fonction <code>void hello()</code>. R\u00e9ex\u00e9cutez ensuite les commandes de la question 5. Que remarquez-vous ?</li> <li>Remodifier ensuite le fichier <code>hello.c</code> en remettant l'accolade fermante mais rajouter un <code>return 1</code> dans la d\u00e9finition de la fonction (avant l'accolade fermante). R\u00e9ex\u00e9cutez ensuite les commandes de la question 5. Que remarquez-vous ?</li> <li> <p>Conclure sur la gestion des erreurs et des warnings sur <code>gcc</code>.</p> <p>R\u00e9ponse</p> <ul> <li>Lorsqu'il y a une erreur de compilation, <code>gcc</code> affiche un message d'erreur et ne cr\u00e9e pas l'ex\u00e9cutable.</li> <li>Lorsqu'il y a un warning, <code>gcc</code> affiche un message d'avertissement mais cr\u00e9e quand m\u00eame l'ex\u00e9cutable.</li> <li>Il est important de lire les messages d'erreur et de warning de <code>gcc</code> pour corriger les erreurs et am\u00e9liorer son code.</li> <li>L'option <code>-Wall</code> de <code>gcc</code> permet d'afficher tous les warnings.</li> </ul> </li> </ol>"},{"location":"contenus/corrige-tp3/#exercice-10-compilation-separee-et-edition-des-liens","title":"Exercice 10 - Compilation s\u00e9par\u00e9e et \u00e9dition des liens","text":"<p>Compilation en plusieurs \u00e9tapes</p> <p>Pour compiler un programme en C, il est possible de le faire en plusieurs \u00e9tapes. On peut d'abord compiler chaque fichier source en un fichier objet, puis \u00e9diter les liens pour cr\u00e9er l'ex\u00e9cutable. Cela permet de gagner du temps lors de la compilation de gros projets.</p> <p>En effet si un seul fichier source est modifi\u00e9, il n'est pas n\u00e9cessaire de recompiler tous les fichiers sources. Il suffit de recompiler le fichier source modifi\u00e9 et de r\u00e9\u00e9diter les liens.</p> <ul> <li>L'option <code>-c</code> de <code>gcc</code> permet de compiler un fichier source en un fichier objet. L'option <code>-o</code> permet de sp\u00e9cifier le nom du fichier objet \u00e0 cr\u00e9er.</li> <li>L'\u00e9dition des liens se fait avec la commande <code>gcc</code> en sp\u00e9cifiant les fichiers objets \u00e0 lier. L'option <code>-o</code> permet de sp\u00e9cifier le nom de l'ex\u00e9cutable \u00e0 cr\u00e9er.</li> </ul> <p>Dans cette configuration, imaginons que nous avons un fichier <code>main.c</code> qui contient la fonction <code>main</code> et un fichier <code>hello.c</code> qui contient la fonction <code>hello</code>. Pour compiler ces deux fichiers en un ex\u00e9cutable <code>run</code>, on peut proc\u00e9der comme suit: <pre><code>$ gcc -c main.c -o main.o # Compilation du fichier main.c en main.o\n$ gcc -c hello.c -o hello.o # Compilation du fichier hello.c en hello.o\n$ gcc main.o hello.o -o run # Edition des liens pour cr\u00e9er l'ex\u00e9cutable run\n</code></pre></p> <ol> <li> <p>Dans le r\u00e9pertoire <code>hello</code>, de l'exercice pr\u00e9c\u00e9dent, cr\u00e9er deux fichiers <code>bye.c</code> et <code>bye.h</code>, en utilisant l'extension de l'accolade, dont les contenus sont les suivants:</p> <ul> <li><code>bye.h</code>: <pre><code>#ifndef BYE_H\n#define BYE_H\n\nvoid bye();\n\n#endif\n</code></pre></li> <li><code>bye.c</code>: <pre><code>#include &lt;stdio.h&gt;\n#include \"bye.h\"\n\nvoid bye()\n{\n    printf(\"I'm done, bye !\\n\");\n}\n</code></pre></li> </ul> <p>R\u00e9ponse</p> <p><pre><code>$ touch bye.{c,h}\n</code></pre> Puis \u00e9diter les fichiers avec les contenus donn\u00e9s dans un \u00e9diteur de texte (probablement sur leur OS local et non dans Debian).</p> </li> <li> <p>Toujours en utilisant l'extension de l'accolade, compiler les deux fichiers <code>hello.c</code> et <code>bye.c</code> en deux fichiers objets <code>hello.o</code> et <code>bye.o</code>. Assurez-vous que le compilateur ne renvoie pas d'erreurs. (Par d\u00e9faut si on ne sp\u00e9cifie pas le nom du fichier de sortie, les fichiers <code>.c</code> sont compil\u00e9s en des fichiers objets de m\u00eame nom)</p> <p>R\u00e9ponse</p> <p><pre><code>$ gcc -c {hello,bye}.c\n</code></pre> N'h\u00e9sitez pas \u00e0 leur sugg\u00e9rer d'utiliser <code>ls</code> pour v\u00e9rifier que les fichiers objets ont bien \u00e9t\u00e9 cr\u00e9\u00e9s.</p> </li> <li> <p>Modifier ensuite le fichier <code>main.c</code> pour afin d'inclure le fichier <code>bye.h</code> et appeler la fonction <code>bye</code> \u00e0 la fin de la fonction <code>main</code>. Le contenu du fichier <code>main.c</code> doit \u00eatre le suivant:     <pre><code>#include &lt;stdio.h&gt;\n#include \"hello.h\"\n#include \"bye.h\"\n\nint main()\n{\n    hello();\n    bye();\n    return 0;\n}\n</code></pre></p> </li> <li> <p>Compiler le fichier <code>main.c</code> en un fichier objet <code>main.o</code>. Assurez-vous que le compilateur ne renvoie pas d'erreurs.</p> <p>R\u00e9ponse</p> <pre><code>$ gcc -c main.c\n</code></pre> <ol> <li>En utilisant l'extention de chemin avec le caract\u00e8re <code>*</code>, \u00e9diter les liens pour tous vos fichiers objets afin cr\u00e9er l'ex\u00e9cutable <code>run</code>. Ex\u00e9cutez ensuite votre programme avec la commande <code>./run</code>.</li> </ol> <p>R\u00e9ponse</p> <pre><code>$ gcc *.o -o run\n$ ./run\n</code></pre> </li> </ol>"},{"location":"contenus/corrige-tp4/","title":"TP4 - Canaux standards et redirections | Processus et t\u00e2ches | Signaux","text":"<p>Instructions</p> <ul> <li>On rappelle que dans tous les exercices le <code>$</code> en d\u00e9but de commande repr\u00e9sente le prompt, il n'est pas \u00e0 saisir lorsque vous \u00e9crivez une ligne de commande.</li> <li>Pour chaque nouvelle commande, n'h\u00e9sitez pas \u00e0 consulter sa page de manuel avec la commande <code>man</code>, ou \u00e0 utiliser l'option <code>--help</code> (si elle est disponible) pour savoir ce qu'elle fait.</li> <li>N'h\u00e9sitez pas \u00e0 reconsulter les anciens TP pour vous aider.</li> </ul>"},{"location":"contenus/corrige-tp4/#canaux-standards-et-redirections","title":"Canaux standards et redirections","text":"<p>Redirection de la sortie standard</p> <p>La plupart des commandes que nous avons \u00e9tudi\u00e9es \u00e9crivent leur r\u00e9sultat sur le terminal. Par exemple <code>ls, echo, cat,...</code>. On dit que ces commandes \u00e9crivent sur la sortie standard (qui est connect\u00e9e au terminal) </p> <p>Il est possible de rediriger la sortie standard vers un fichier en utilisant le caract\u00e8re <code>&gt;</code>. Par exemple : <pre><code>$ ls ~ # affiche le contenu du r\u00e9pertoire personnel sur la sortie standard\n$ ls ~ &gt; list_files.txt # redirige la sortie standard vers le fichier list_files\n</code></pre></p> <p>Attention</p> <p>La redirection de la sortie standard va cr\u00e9er le fichier <code>list_files.txt</code> s'il n'existe pas.</p> <p>La redirection \u00e9crase le contenu d'un fichier existant. Si on veut ajouter le r\u00e9sultat \u00e0 la fin du fichier, on utilise le caract\u00e8re <code>&gt;&gt;</code>.</p>"},{"location":"contenus/corrige-tp4/#exercice-1-redirection-de-la-sortie-standard","title":"Exercice 1 : Redirection de la sortie standard","text":"<ol> <li> <p>Testez les commandes suivantes et observez leur r\u00e9sultats. <pre><code>$ echo \"Est-ce que j'apparais sur le terminal ?\"\n$ echo \"Ou bien dans le fichier ?\" &gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Et moi ?\" &gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je ne veux pas vider le fichier\" &gt;&gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je veux vider le fichier\" 1&gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je m'ajoute en fin de ligne\" 1&gt;&gt; fichier.txt\n</code></pre></p> <p>R\u00e9ponses</p> <p>L'id\u00e9e ici c'est de leur montrer o\u00f9 sont \"affich\u00e9\" le r\u00e9sultat de la commande <code>echo</code>.</p> </li> <li> <p>Rappeler ce que fait la commande <code>cat</code> (man <code>cat</code>) puis \u00e0 partir des r\u00e9sultats des commandes pr\u00e9c\u00e9dentes:</p> <ul> <li>Quelle est la diff\u00e9rence entre <code>&gt;</code> et <code>&gt;&gt;</code> ?</li> <li>Quelle est la diff\u00e9rence entre <code>1&gt;</code> et <code>&gt;</code> ?</li> <li>Quelle est la diff\u00e9rence entre <code>1&gt;&gt;</code> et <code>&gt;&gt;</code> ?</li> </ul> <p>R\u00e9ponses</p> <ul> <li> <p><code>cat</code> sans argument va lire l'entr\u00e9e standard, et va ensuite afficher ce qu'il a lu.</p> </li> <li> <p><code>&gt;</code> \u00e9crase le contenu du ficher dans lequel est redirig\u00e9 la sortie standard, tandis que <code>&gt;&gt;</code> va \u00e9crire sur la derni\u00e8re ligne du fichier.</p> </li> <li><code>1&gt;</code> et <code>&gt;</code>, <code>1&gt;&gt;</code> et <code>&gt;&gt;</code> font exactement la m\u00eame chose. Le chiffre <code>1</code> est optionnel, c'est le descripteur de fichier associ\u00e9 \u00e0 la sortie standard (<code>stdout</code> en anglais).</li> </ul> </li> <li> <p>Placez-vous dans votre r\u00e9pertoire personnel et ex\u00e9cutez la commande suivante :     <pre><code>$ ls &gt; list_files.txt; cat list_files.txt\n</code></pre></p> <ul> <li> <p>Que fait cette commande ?</p> <p>La commande redirige la sortie standard de <code>ls</code> dans <code>list_files.txt</code></p> </li> <li> <p>Pouvez-vous expliquer pourquoi la cha\u00eene <code>list_files.txt</code> appara\u00eet dans le fichier <code>list_files.txt</code> ?</p> <p>Ici la cha\u00eene <code>list_files.txt</code> appara\u00eet dans le fichier car le fichier est d'abord cr\u00e9\u00e9 avant l'ex\u00e9cution de la commande <code>ls</code>.</p> </li> </ul> </li> </ol>"},{"location":"contenus/corrige-tp4/#exercice-2-compter-les-entetes-1","title":"Exercice 2 : Compter les ent\u00eates (1)","text":"<ol> <li> <p>En vous aidant de la redirection de la sortie standard, cr\u00e9er un fichier <code>include_files.txt</code> qui liste tous les fichiers du r\u00e9pertoire <code>/usr/include</code> dont le nom se termine par <code>.h</code>.</p> <p><code>$ ls /usr/include/*.h &gt; include_files.txt</code></p> </li> <li> <p>Compter le nombre de fichiers <code>.h</code> dans le r\u00e9pertoire <code>/usr/include</code> (indice : <code>wc</code>).</p> <p><code>$ wc -l include_files.txt</code></p> </li> <li> <p>Enfin ajouter la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire /usr/include</code> \u00e0 la fin du fichier <code>include_files.txt</code>.</p> <p>R\u00e9ponses</p> <p><pre><code>$ echo \"Il y a $(wc -l include_files.txt) fichiers .h dans le r\u00e9pertoire /usr/include\" &gt;&gt; include_files.txt\n</code></pre> Il faut passer par la substitution de commande et rediriger la sortie standard de <code>echo</code> \u00e0 la fin du fichier <code>include_files.txt</code>.</p> </li> </ol>"},{"location":"contenus/corrige-tp4/#exercice-3-redirection-de-lerreur-standard","title":"Exercice 3 : Redirection de l'erreur standard","text":"<ol> <li>Dans un r\u00e9pertoire <code>dir</code> cr\u00e9er un fichier <code>file-1.txt</code> dont le contenu est <code>Hello world !</code>.</li> <li>Cr\u00e9er ensuite une copie de <code>file-1.txt</code> nomm\u00e9e <code>file-2.txt</code>. Retirez toutes les permissions de lecture sur <code>file-2.txt</code>.</li> <li>Tapez ensuite la commande suivante et notez les r\u00e9sultats (on va avoir des erreur !) :     <pre><code>$ cat file-1.txt file-2.txt file-3.txt\n</code></pre></li> <li> <p>Quelles commande a r\u00e9ussi ? et quelles commandes ont \u00e9chou\u00e9 et pourquoi ?</p> <p>R\u00e9ponses</p> <ul> <li>La commande <code>cat file-1.txt</code> a r\u00e9ussi.</li> <li>La commande <code>cat file-2.txt</code> a \u00e9chou\u00e9 car le fichier <code>file-2.txt</code> n'a pas la permission <code>read</code>.</li> <li>La commande <code>cat file-3.txt</code> a \u00e9chou\u00e9 car le fichier <code>file-3.txt</code> n'existe pas.</li> </ul> </li> <li> <p>Faites ensuite une redirection de la sortie standard de la commande pr\u00e9c\u00e9dente vers un fichier <code>result.txt</code>. Observez le ce qui est affich\u00e9 sur le terminal, et observer le contenu du fichier <code>result.txt</code>.</p> <p>R\u00e9ponses</p> <pre><code>$ cat file-1.txt file-2.txt file-3.txt &gt; result.txt\n</code></pre> <p>Les erreurs restent affich\u00e9s sur le terminal. Il existe un autre canal pour les erreurs : c'est l'erreur standard (stderr en anglais).</p> </li> <li> <p>Tapez ensuite la commande suivante et notez les r\u00e9sultats :     <pre><code>$ cat file-1.txt file-2.txt file-3.txt 1&gt; result.txt 2&gt; error.txt\n</code></pre></p> </li> <li> <p>Observez les contenus de <code>result.txt</code> et <code>error.txt</code>. Que contiennent-ils ? \u00c0 votre avis que signifie <code>1&gt;</code> et <code>2&gt;</code> ? Tirez-en une conclusion sur la diff\u00e9rence entre la sortie standard et l'erreur standard.</p> <p>R\u00e9ponses</p> <ul> <li>La sortie standard est redirig\u00e9e vers <code>result.txt</code> et l'erreur standard est redirig\u00e9e vers le fichier <code>error.txt</code>.</li> <li>Le chiffre <code>2</code> ici n'est pas optionnel, il faut le marquer pour signifier que l'on redirige l'erreur standard.</li> </ul> </li> </ol> <p>Redirection de l'entr\u00e9e standard</p> <p>Certaines commandes lisent des informations sur le terminal. Par exemple <code>tr, read,...</code>. On dit que ces commandes lisent sur l'entr\u00e9e standard (qui est aussi connect\u00e9e au terminal).</p> <p>Mais beaucoup de commandes lisent \u00e9galement sue le terminal si aucun nom de fichier leur est donn\u00e9 en argument. Par exemple <code>cat, grep, sort,...</code>.</p> <p>Il est possible de rediriger l'entr\u00e9e standard d'une commande vers un fichier en utilisant le caract\u00e8re <code>&lt;</code>. Par exemple : <pre><code>$ cat &lt; fichier.txt\n</code></pre> Cette commande affiche le contenu du fichier <code>fichier.txt</code> sur la sortie standard. On dit que le fichier <code>fichier.txt</code> est connect\u00e9 \u00e0 l'entr\u00e9e standard de la commande <code>cat</code>.</p> <p>Attention</p> <p>Il faut que le fichier <code>fichier.txt</code> existe et qu'on ait la permission <code>read</code> sinon la commande <code>cat</code> va \u00e9chouer.</p>"},{"location":"contenus/corrige-tp4/#exercice-4-retour-sur-la-commande-cat","title":"Exercice 4 : Retour sur la commande <code>cat</code>","text":"<ol> <li>Revoyez le manuel de la commande <code>cat</code> et trouvez comment elle fonctionne lorsque l'on ne lui donne pas de fichier en argument.</li> <li> <p>Testez ensuite la commande suivante:    <pre><code>$ cat\nhello&lt;newline&gt;\nworld&lt;newline&gt;\nC-d # appuyer sur la touche Ctrl et la touche d en m\u00eame temps\n</code></pre>     Combien d'argument la commande <code>cat</code> a-t-elle re\u00e7u ? Qu'a-t-elle affich\u00e9 ? Pourquoi ?</p> <p>R\u00e9ponses</p> <p><code>cat</code> ici n'a pas d'argument. Comme indiqu\u00e9 dans l'exo pr\u00e9c\u00e9dent <code>cat</code> sans argument lit sur l'entr\u00e9e stadard. Elle va donc lire tous les caract\u00e8res tap\u00e9 au clavier avant que l'on appuie sur la touche entr\u00e9e (pour le caract\u00e8re <code>&lt;newline&gt;</code>). Directement apr\u00e8s <code>&lt;newline&gt;</code>, les caract\u00e8res lus sont affich\u00e9s sur le terminal.</p> <p>Vous pouvez leur dire que pour que <code>cat</code> arr\u00eate de lire, on tape sur <code>C-D</code> qui correspond au caract\u00e8re <code>EOF</code> (end of file).</p> </li> <li> <p>Testez ensuite la commande suivante:    <pre><code>$ cat &gt; catout.txt\nhello&lt;newline&gt;\nworld&lt;newline&gt;\nC-d # appuyer sur la touche Ctrl et la touche d en m\u00eame temps\n</code></pre>     Puis affichez le contenu du fichier <code>catout.txt</code>. Que contient-il ? Pourquoi ?</p> <p>Le fichier <code>catout.txt</code> va r\u00e9cup\u00e9rer les r\u00e9sultats de la commande <code>cat</code> qui a lu sur l'entr\u00e9e standard.</p> </li> <li> <p>Tapez enfin la commande suivante :     <pre><code>$ cat &lt; catout.txt\n$ cat 0&lt; catout.txt\n</code></pre></p> <ul> <li>Combien d'argument la commande <code>cat</code> a-t-elle re\u00e7u ? Qu'a-t-elle affich\u00e9 ?</li> <li>Quelle est la diff\u00e9rence entre <code>&lt;</code> et <code>0&lt;</code> ?</li> </ul> <p>R\u00e9ponses</p> <ol> <li>Ici aussi la commande <code>cat</code> n'a pas d'arguments, et lit donc sur l'entr\u00e9e standard. Sauf que cette fois-ci, l'entr\u00e9e standard est redirig\u00e9 vers le fichier <code>catout.txt</code>. En d'autres terme <code>cat</code> va lire le contenu de <code>catout.txt</code> comme si on les avait tap\u00e9 au clavier sur le terminal. La commande va donc afficher le contenu de <code>caout.txt</code>. </li> <li>L'utilisation de <code>&lt;</code> et <code>0&lt;</code> produisent exactement le m\u00eame r\u00e9sultat. <code>0</code> est le chiffre correspondant au descripteur de fichier de l'entr\u00e9e standard, et il est optionnel.</li> </ol> </li> </ol>"},{"location":"contenus/corrige-tp4/#exercice-5-compter-les-entetes-2","title":"Exercice 5 : Compter les ent\u00eates (2)","text":"<p>Nous allons refaire le m\u00eame exercice que l'exercice 2 mais cette fois-ci en utilisant la redirection de l'entr\u00e9e standard.</p> <ol> <li> <p>Cr\u00e9er un fichier <code>include_files.txt</code> qui liste tous les fichiers du r\u00e9pertoire <code>/usr/include</code> dont le nom se termine par <code>.h</code>.</p> <p><code>$ ls /usr/include/*.h &gt; include_files.txt</code></p> </li> <li> <p>Tapez ensuite la commande suivante et commentez son r\u00e9sultat:     <pre><code>$ wc -l &lt; include_files.txt\n</code></pre></p> <p>R\u00e9ponses</p> <ul> <li> <p><code>wc -l</code> compte le nombre de lignes du ou des fichiers pass\u00e9s en argument. Elle lit \u00e9galement sur l'entr\u00e9e standard sans argument. Ici, on a une redirection de l'entr\u00e9e standard. Cette commande va afficher le nombre de lignes du fichier <code>include_files.txt</code>.</p> </li> <li> <p><code>wc -l &lt; include_files.txt</code> et <code>wc -l include_files.txt</code> produisent exactement le m\u00eame r\u00e9sultat.</p> </li> </ul> </li> <li> <p>Entrez ensuite la commande suivante et commentez son r\u00e9sultat:     <pre><code>$ wc -l &lt; include_files.txt &gt;&gt; include_files.txt\n</code></pre>     et observez la derni\u00e8re ligne du fichier <code>include_files.txt</code>.</p> <p>On a ici une double redirection, redirection de stdin, et redirection de stdout (en mode <code>append</code>).</p> </li> <li> <p>Nous voudrions enfin que la derni\u00e8re ligne du fichier <code>include_files.txt</code> soit la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire /usr/include</code>. O\u00f9 <code>&lt;nombre&gt;</code> est le r\u00e9sultat de <code>wc -l &lt; include_files.txt</code>.</p> <p>Trouvez une commande qui permet de faire cela en utilisant \u00e0 la fois la redirection de la sortie standard et de l'entr\u00e9e standard.</p> <p>Indice</p> <ul> <li>Pour retirer la derni\u00e8re ligne, on peut refaire la commande de la premi\u00e8re question.</li> <li>Ensuite pensez \u00e0 la commande <code>echo</code> et la subsutitution de commande.</li> </ul> <p>R\u00e9ponses</p> <pre><code>$ ls /usr/include/*.h &gt; include_files.txt\n$ echo \"Il y a $(wc -l include_files.txt) fichiers .h dans le r\u00e9pertoire /usr/include.\" &gt;&gt; include_files.txt\n</code></pre> </li> </ol>"},{"location":"contenus/corrige-tp4/#les-tubes","title":"Les tubes","text":"<p>Tubes</p> <p>Un tube (pipe en anglais) est un m\u00e9canisme qui permet de connecter la sortie standard d'une commande \u00e0 l'entr\u00e9e standard d'une autre commande. On utilise le caract\u00e8re <code>|</code> pour cr\u00e9er un tube.</p> <p>C'est-\u00e0-dire que pour <pre><code>$ cmd1 | cmd2\n</code></pre> La sortie standard de <code>cmd1</code> est connect\u00e9e \u00e0 l'entr\u00e9e standard de <code>cmd2</code>.</p>"},{"location":"contenus/corrige-tp4/#exercice-6-compter-les-entetes-promis-cest-la-derniere-fois","title":"Exercice 6 : Compter les ent\u00eates (promis c'est la derni\u00e8re fois)","text":"<ol> <li> <p>Testez la commande suivante et commentez son r\u00e9sultat :     <pre><code>$ ls /usr/include/*.h | wc -l\n</code></pre>     O\u00f9 est redirig\u00e9 le r\u00e9sultat de la commande <code>ls</code> ? O\u00f9 est redirig\u00e9 l'entr\u00e9e standard de la commande <code>wc</code> ? O\u00f9 est affich\u00e9 le r\u00e9sultat de <code>wc</code>?</p> <p>On a connect\u00e9 le stdout de la commande <code>ls</code> au stdin de la commande <code>wc</code>. Vous pouvez faire remarquer que le r\u00e9sultat de la commande <code>ls</code> n'est pas affich\u00e9 dans le terminal, et <code>wc</code>n'a pas d'argument. </p> </li> <li> <p>Affichez ensuite sur le terminal la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire /usr/include</code> en utilisant la commande <code>echo</code> et la substitution de commande (indice la commande \u00e0 utiliser et celle de la question 1).    </p> <p>R\u00e9ponses</p> <pre><code>$ echo \"Il y a $(ls /usr/include/*.h | wc -l) fichiers .h dans le r\u00e9pertoire /usr/include\" \n</code></pre> </li> <li> <p>Enfin, entrez la commande suivante et commentez son r\u00e9sultat :     <pre><code>wc -l $(ls /usr/include/*.h)\n</code></pre></p> </li> <li> <p>\u00c0 votre avis pourquoi le r\u00e9sultat de la derni\u00e8re commande est-il diff\u00e9rent de celui de la question 1 ?</p> <p>R\u00e9ponses</p> <p><code>wc -l $(ls /usr/include/*.h)</code> affiche le nombre de ligne de CHACUN des fichiers affich\u00e9 par la commande <code>ls</code>. Le r\u00e9sultat n'est pas le m\u00eame que celle de la question 1, car la substitution de commande est eff\u00e9ctu\u00e9e avant l'ex\u00e9cution de la commande <code>wc</code>. Elle se comporte donc comme si chaque fichier affich\u00e9 par le <code>ls</code> est donn\u00e9 en argument \u00e0 <code>wc</code>.</p> </li> </ol>"},{"location":"contenus/corrige-tp4/#processus-et-taches","title":"Processus et t\u00e2ches","text":"<p>Processus et t\u00e2ches</p> <p>Un processus est une unit\u00e9 de travail sur un syst\u00e8me d'exploitation. Il peut s'agir d'un programme, d'un script, ou d'un service. Chaque programme que vous ex\u00e9cutez repr\u00e9sente un ou plusieurs processus. Chaque processus est identifi\u00e9 par un num\u00e9ro unique appel\u00e9 PID (Process IDentifier). </p> <p>Linux nous offre plusieurs commandes pour visualiser les processus en cours d'ex\u00e9cution.</p> <ul> <li><code>ps</code> permet d'afficher les processus en cours d'ex\u00e9cution. Par d\u00e9faut, <code>ps</code> n'affiche que les processus lanc\u00e9s par l'utilisateur courant. Pour afficher tous les processus, on utilise l'option <code>-e</code> (ou <code>-A</code>).</li> <li><code>top</code> permet d'afficher les processus en cours d'ex\u00e9cution. Il peut s'utiliser de mani\u00e8re interactive notamment les trier par utilisation du CPU. On peut quitter <code>top</code> avec la touche <code>q</code>.</li> </ul> <p>Une t\u00e2che par contre est une unit\u00e9 de travail du shell. Une t\u00e2che peut \u00eatre un processus, ou un groupe de processus mais il faut qu'il ait \u00e9t\u00e9 lanc\u00e9 par le shell. Le shell a un syst\u00e8me de contr\u00f4le de t\u00e2ches : c'est la capacit\u00e9 \u00e0 ex\u00e9cuter plusieurs commandes en m\u00eame temps. On peut lancer une commande en arri\u00e8re-plan et en avant-plan. </p> <p>La commande <code>jobs</code> permet d'afficher les t\u00e2ches en cours d'ex\u00e9cution.</p> <p>En somme</p> <p>Une t\u00e2che est un processus, mais un processus n'est pas forc\u00e9ment une t\u00e2che.</p>"},{"location":"contenus/corrige-tp4/#exercice-7-processus-et-taches","title":"Exercice 7 - Processus et t\u00e2ches","text":"<p>Correction globale</p> <ol> <li> <p>Dans cet exercice nous allons simuler l'ex\u00e9cution d'un processus long. Pour cela, nous allons utiliser la commande <code>sleep</code> qui permet de mettre en pause l'ex\u00e9cution d'un script pendant un certain temps. Tapez la commande <code>sleep 10</code> et observez ce qu'il se passe.</p> <p>Informations de la commande <code>ps</code><p>La commande <code>ps</code> retourne la liste des processus en cours d'ex\u00e9cution. Cette liste contient quatre colonnes par d\u00e9faut.</p> <ul> <li>La premi\u00e8re colonne correspond au PID (Process IDentifier) du processus.</li> <li>La deuxi\u00e8me colonne correspond au TTY (TeleTYpewriter) sur lequel le processus est lanc\u00e9. C'est le type de terminal utilis\u00e9 pour lancer le processus. Ici <code>pts/1</code> (pseudo-terminal slave) signifie que le processus a \u00e9t\u00e9 lanc\u00e9 dans un pseudo-terminal. Le chiffre renseign\u00e9 correspond au num\u00e9ro du terminal (par exemple si vous avez plusieurs instances du terminal ouverts).</li> <li>La troisi\u00e8me colonne correspond au TIME (temps) d'ex\u00e9cution du processus.</li> <li>La quatri\u00e8me colonne correspond \u00e0 la CMD (CoMmanDe) qui a lanc\u00e9 le processus.</li> </ul> </p> </li> <li> <p>Ensuite testez les commandes suivantes et commentez les r\u00e9sultats:     <pre><code>$ ps\n$ sleep 240\n$ C-z # Control + z\n$ ps\n$ fg %1 # fg %&lt;num\u00e9ro de la t\u00e2che&gt;\n$ C-c # Control + c\n$ ps\n</code></pre></p> <ul> <li>\u00c0 votre avis que fait le raccourci clavier <code>C-z</code> ? et le raccourci clavier <code>C-c</code> ?</li> <li>Refaites les commandes en tapant des commandes (ou tout autre chose dans le terminal) entre le <code>sleep 240</code> et le <code>C-z</code>. Que remarquez-vous ?</li> <li>Sans passer par <code>help fg</code>, pouvez-vous deviner ce que fait la commande <code>fg %1</code> ? et la commande <code>fg</code> de mani\u00e8re g\u00e9n\u00e9rale ?</li> <li>Refaites les commandes en notant \u00e0 chaque fois le PID du processus <code>sleep 240</code> dans les sorties de <code>ps</code>. Que remarquez-vous ?</li> </ul> </li> <li> <p>Ecrire un programme en C qui incr\u00e9mente ind\u00e9finiment une variable <code>i</code>, et affiche sa valeur sur la sortie standard \u00e0 chaque fois que <code>i</code> est un multiple de 100. Pensez \u00e0 utiliser la commande <code>sleep</code> pour ralentir l'ex\u00e9cution du programme et voir quelque chose sur le terminal. </p> <p>O\u00f9 est sleep ?</p> <p>Tapez la commande <code>man 3 sleep</code> pour voir o\u00f9 se trouve la fonction <code>sleep</code> dans la biblioth\u00e8que standard de C.</p> </li> <li> <p>Compilez le programme et nommer votre ex\u00e9cutable <code>compteur</code>. Puis testez les commandes suivantes et commentez les r\u00e9sultats:</p> <pre><code>$ ./compteur\n$ C-z\n$ jobs \n$ jobs -p # Notez le PID \n$ ps\n$ fg %1\n$ C-z\n$ bg %1\n$ fg %1 # Ne vous inqui\u00e9tez pas, tapez tout simplement la commande correctement\n$ C-z\n$ jobs\n% fg %1\n$ C-c\n$ jobs\n</code></pre> <ul> <li>Quels proc\u00e9d\u00e9s permettent de placer un processus en arri\u00e8re-plan ? et en avant-plan ?</li> <li>Quelle est la diff\u00e9rence entre <code>C-z</code> et <code>C-c</code> ?</li> <li>\u00c0 quoi sert l'option <code>-p</code> de la commande <code>jobs</code> ?</li> <li>Sans passer par <code>help bg</code>, pouvez-vous deviner ce que fait la commande <code>bg</code> de mani\u00e8re g\u00e9n\u00e9rale ?</li> <li>Quels sont les diff\u00e9rents \u00e9tats des t\u00e2ches que vous avez observ\u00e9 ?</li> </ul> </li> </ol>"},{"location":"contenus/corrige-tp4/#correction-globale","title":"Correction globale","text":"<ol> <li> <p>Il est important de leur faire comprendre qu'on peut faire tourner des processus en avant et en arri\u00e8re plan dans le shell.</p> <ul> <li>Les processus en avant plan, bloquent l'interpr\u00e9teur de commande tant qu'ils ne terminent pas.</li> <li>Ceux qui tournent en arri\u00e8re plan ne bloquent pas l'interpr\u00e9teur de commande, qu'il ait termin\u00e9 ou non.</li> </ul> </li> <li> <p>On peut aussi leur rappeler la distinction entre processus et t\u00e2ches. Ici tous les processus sont des t\u00e2ches car nous les lan\u00e7ons dans le shell.</p> </li> <li> <p><code>C-z</code> et <code>C-c</code> permettent d'interagir avec les processus en avant-plan. En plus, <code>C-z</code> fait directement appara\u00eetre le num\u00e9ro de t\u00e2che et le PID du processus sur la sortie standard.</p> </li> <li> <p>Les commandes <code>fg</code> et <code>bg</code> sont des commandes internes du shell qui permette de mettre resp\u00e9ctivement en avant et en arri\u00e8re plan des t\u00e2che en leur passant le num\u00e9ro de la t\u00e2che en argument avec <code>%&lt;num\u00e9ro t\u00e2che&gt;</code>. Pour un processus arr\u00eat\u00e9, <code>fg</code> et <code>bg</code> permet de le relancer, respectivement en avant et arri\u00e8re plan.</p> </li> <li> <p>Normalement, il doivent voir <code>Running</code>, <code>Stopped</code> et <code>Done</code> comme \u00e9tats des t\u00e2ches dans cet exo.</p> </li> </ol>"},{"location":"contenus/corrige-tp4/#envoyer-des-signaux-a-un-processus","title":"Envoyer des signaux \u00e0 un processus","text":"<p>Communiquer avec les processus</p> <p>Lorsque des processus ont \u00e9t\u00e9 lanc\u00e9s, nous avons remarqu\u00e9 qu'ils peuvent \u00eatre arr\u00eates, red\u00e9marr\u00e9s et tu\u00e9s. Pour cela, nous avons utilis\u00e9 les commandes <code>C-z</code>, <code>C-c</code>, <code>fg</code> et <code>bg</code>. Ces commandes permettent de communiquer avec les processus en cours d'ex\u00e9cution. En r\u00e9alit\u00e9, ces derni\u00e8res envoient ce qu'on appelle des signaux aux processus. Un signal est un message envoy\u00e9 \u00e0 un processus pour lui demander de faire quelque chose. </p> <p>La commande qui permet d'envoyer des signaux \u00e0 un processus est <code>kill</code>. Cette commande n\u00e9cessite le PID du processus \u00e0 qui envoyer le signal (ou son num\u00e9ro de t\u00e2che si c'en est une). Ainsi <code>C-z</code>, <code>C-c</code>, <code>fg</code> et <code>bg</code> font donc appel \u00e0 la commande <code>kill</code> pour envoyer des signaux aux processus.</p> <p>Il existe plusieurs signaux, les plus courants sont les suivants:</p> <ul> <li><code>SIGINT</code> : signal envoy\u00e9 par la combinaison de touches <code>C-c</code>. Il demande au processus de s'arr\u00eater.</li> <li><code>SIGTSTP</code> : signal envoy\u00e9 par la combinaison de touches <code>C-z</code>. Il demande au processus de se mettre en pause.</li> <li><code>SIGCONT</code> : signal envoy\u00e9 par les commandes <code>bg</code> et <code>fg</code>. Il demande au processus de reprendre son ex\u00e9cution.</li> <li><code>SIGTERM</code> : signal envoy\u00e9 par la commande <code>kill</code> par d\u00e9faut. Il demande au processus de s'arr\u00eater.</li> <li><code>SIGKILL</code> : Il demande au processus de s'arr\u00eater imm\u00e9diatement et provoque son arr\u00eat brutal, comprenez par l\u00e0 que le processus n'a pas le temps de se terminer correctement. Il est donc d\u00e9conseill\u00e9 d'utiliser ce signal.</li> </ul> <p>La liste exhaustive des signaux est disponible est obtenu avec commande <code>kill -L</code>.</p> <p>Qui a le droit d'envoyer des signaux \u00e0 un processus ?</p> <p>Pour pouvoir affecter un processus, vous devez biensur en \u00eatre le prorpi\u00e9taire ou \u00eatre root.</p>"},{"location":"contenus/corrige-tp4/#exercice-8-la-commande-kill","title":"Exercice 8 - La commande <code>kill</code>","text":"<p>Correction globale</p> <ol> <li><code>kill</code> peut s'utiliser de 4 fa\u00e7ons diff\u00e9rentes et fonctionne \u00e9galement avec le num\u00e9ro de t\u00e2che. Par exemple pour <code>SIGINT</code> dont le num\u00e9ro est <code>2</code>:       <pre><code>$ kill -s SIGINT &lt;PID&gt;\n$ kill -SIGINT &lt;PID&gt;\n$ kill -2 &lt;PID&gt;\n$ kill -s INT &lt;PID&gt; # je ne leur ai pas montr\u00e9 cette derni\u00e8re\n</code></pre></li> <li> <p>Dans cet exercice <code>$ kill -SIGINT &lt;PID&gt;</code> ne marche pas si le processus est en arri\u00e8re plan c'est pour \u00e7a qu'on donne directement \u00e0 <code>kill</code> le num\u00e9ro de t\u00e2che.</p> </li> <li> <p>On a:</p> <ul> <li><code>SIGINT</code> permet d'interrompre puis tuer un processus. Statut dans <code>jobs</code>: <code>Interrupted</code>.</li> <li><code>SIGKILL</code> arr\u00eate de mani\u00e8re brutale un pricessus (aucun incidence dans notre exemple, mais vous pouvez leur expliquer qu'un programme peut allouer diff\u00e9rentes ressources, et lui envoyer un <code>SIGKILL</code> le force \u00e0 s'arr\u00eater sans terminer proprement). Statut dans <code>jobs</code>: <code>Killed</code>.</li> <li><code>SIGTERM</code> interompt et arr\u00eate un processus. Statut dans <code>jobs</code>: <code>Terminated</code>.</li> <li><code>SIGTSTP</code> interompt un processus mais ne le tue pas. Statut dans <code>jobs</code>: <code>Stopped</code>.</li> <li><code>SIGCONT</code> relance un processus arr\u00eat\u00e9. Apr\u00e8s <code>SIGCONT</code> le statut dans <code>jobs</code> devient <code>Running</code>.</li> </ul> </li> </ol> <ol> <li> <p>Tapez la commande <code>kill -L</code> et notez les num\u00e9ros associ\u00e9s aux signaux <code>SIGINT</code>, <code>SIGTSTP</code>, <code>SIGCONT</code>, <code>SIGTERM</code> et <code>SIGKILL</code>.</p> </li> <li> <p>On peut utiliser le caract\u00e8re <code>&amp;</code> \u00e0 la fin de la commande pour directement lancer les t\u00e2ches en arri\u00e8re-plan. Lancez alors 3 processus <code>./compteur</code> en arri\u00e8re-plan et testez les commandes suivantes:</p> <pre><code>$ ./compteur 1 &amp; # ce sera notre processus 1\n$ ./compteur 2 &amp; # ce sera notre processus 2\n$ ./compteur 3 &amp; # ce sera notre processus 3\n$ jobs -p # notez les PID des processus, mais ils ont d\u00fb \u00eatre affich\u00e9s \u00e0 l'\u00e9cran lors de leur lancement\n$ kill -SIGTSTP &lt;PID du processus 1&gt;\n$ jobs\n$ kill -SIGINT %2\n$ jobs\n$ jobs # oui une deuxi\u00e8me fois\n$ kill -SIGCONT %1\n$ jobs\n$ kill -s SIGTERM &lt;PID processus 1&gt;\n$ jobs\n$ kill -9 &lt;PID du processus 3&gt;\n$ jobs\n$ jobs # pour voir dispara\u00eetre la t\u00e2che [3]\n</code></pre> </li> <li> <p>Selon vous quel est la diff\u00e9rence entre <code>SIGINT</code> et <code>SIGTSTP</code> ? et entre <code>SIGTSTP</code> et <code>SIGTERM</code> ?</p> </li> <li>D'apr\u00e8s vos observations sur les r\u00e9sultats de la question 2, de combien de mani\u00e8re diff\u00e9rente peut-on utiliser la commande <code>kill</code> pour arriver au m\u00eame r\u00e9sultat ?</li> </ol>"},{"location":"contenus/draft-corrige-tp4/","title":"TP4 - Filtres textuels, redirection et tubes","text":"<p>::: info - On rappelle que dans tous les exercices le <code>$</code> en d\u00e9but de commande repr\u00e9sente le prompt, il n'est pas \u00e0 saisir lorsque vous \u00e9crivez une ligne de commande. - Pour chaque nouvelle commande, n'h\u00e9sitez pas \u00e0 consulter sa page de manuel avec la commande <code>man</code>, ou \u00e0 utiliser l'option <code>--help</code> (si elle est disponible) pour savoir ce qu'elle fait. - N'h\u00e9sitez pas \u00e0 reconsulter les anciens TP pour vous aider. :::</p>"},{"location":"contenus/draft-corrige-tp4/#canaux-standards-et-redirections","title":"Canaux standards et redirections","text":"<p>:::success \"Redirection de la sortie standard\"</p> <p>La plupart des commandes que nous avons \u00e9tudi\u00e9es \u00e9crivent leur r\u00e9sultat sur le terminal. Par exemple <code>ls, echo, cat,...</code>. On dit que ces commandes \u00e9crivent sur la sortie standard (qui est connect\u00e9e au terminal) </p> <p>Il est possible de rediriger la sortie standard vers un fichier en utilisant le caract\u00e8re <code>&gt;</code>. Par exemple : <pre><code>$ ls ~ # affiche le contenu du r\u00e9pertoire personnel sur la sortie standard\n$ ls ~ &gt; list_files.txt # redirige la sortie standard vers le fichier list_files\n</code></pre></p> <p>:::warning \"Attention\" La redirection de la sortie standard va cr\u00e9er le fichier <code>list_files.txt</code> s'il n'existe pas.</p> <p>La redirection \u00e9crase le contenu d'un fichier existant. Si on veut ajouter le r\u00e9sultat \u00e0 la fin du fichier, on utilise le caract\u00e8re <code>&gt;&gt;</code>. :::</p>"},{"location":"contenus/draft-corrige-tp4/#exercice-1-redirection-de-la-sortie-standard","title":"Exercice 1 : Redirection de la sortie standard","text":"<ol> <li> <p>Testez les commandes suivantes et observez leur r\u00e9sultats.     <pre><code>$ echo \"Est-ce que j'apparais sur le terminal ?\"\n$ echo \"Ou bien dans le fichier ?\" &gt; fichier.txt\n$ cat fichier.txt\n$ cat \"Et moi ?\" &gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je ne veux pas vider le fichier\" &gt;&gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je veux vider le fichier\" 1&gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je m'ajoute en fin de ligne\" 1&gt;&gt; fichier.txt\n</code></pre>     :::danger     L'id\u00e9e ici c'est de leur montrer o\u00f9 sont \"affich\u00e9\" le r\u00e9sultat de la commande <code>echo</code>.     :::</p> </li> <li> <p>Rappeler ce que fait la commande <code>cat</code> (man <code>cat</code>) puis \u00e0 partir des r\u00e9sultats des commandes pr\u00e9c\u00e9dentes:</p> <ul> <li>Quelle est la diff\u00e9rence entre <code>&gt;</code> et <code>&gt;&gt;</code> ?</li> <li>Quelle est la diff\u00e9rence entre <code>1&gt;</code> et <code>&gt;</code> ?</li> <li> <p>Quelle est la diff\u00e9rence entre <code>1&gt;&gt;</code> et <code>&gt;&gt;</code> ?</p> <p>:::danger * <code>cat</code> sans argument va lire l'entr\u00e9e standard, et va ensuite afficher ce qu'il a lu.</p> <ul> <li><code>&gt;</code> \u00e9crase le contenu du ficher dans lequel est redirig\u00e9 la sortie standard, tandis que <code>&gt;&gt;</code> va \u00e9crire sur la derni\u00e8re ligne du fichier.</li> <li><code>1&gt;</code> et <code>&gt;</code>, <code>1&gt;&gt;</code> et <code>&gt;&gt;</code> font exactement la m\u00eame chose. Le chiffre <code>1</code> est optionnel, c'est le descripteur de fichier associ\u00e9 \u00e0 la sortie standard (<code>stdout</code> en anglais). :::</li> </ul> </li> </ul> </li> <li> <p>Placez-vous dans votre r\u00e9pertoire personnel et ex\u00e9cutez la commande suivante :     <pre><code>$ ls &gt; list_files.txt; cat list_files.txt\n</code></pre></p> <ul> <li>Que fait cette commande ?     :::danger     La commande redirige la sortie standard de <code>ls</code> dans <code>list_files.txt</code>.     :::</li> <li>Pouvez-vous expliquer pourquoi la cha\u00eene <code>list_files.txt</code> appara\u00eet dans le fichier <code>list_files.txt</code> ?     :::danger     Ici la cha\u00eene <code>list_files.txt</code> appara\u00eet dans le fichier car le fichier est d'abord cr\u00e9\u00e9 avant l'ex\u00e9cution de la commande <code>ls</code>.     :::</li> </ul> </li> </ol>"},{"location":"contenus/draft-corrige-tp4/#exercice-2-compter-les-entetes-1","title":"Exercice 2 : Compter les ent\u00eates (1)","text":"<ol> <li> <p>En vous aidant de la redirection de la sortie standard, cr\u00e9er un fichier <code>include_files.txt</code> qui liste tous les fichiers du r\u00e9pertoire <code>/usr/include</code> dont le nom se termine par <code>.h</code>.</p> <p>:::danger <pre><code>$ ls /usr/include/*.h &gt; include_files.txt\n</code></pre> :::</p> </li> <li> <p>Compter le nombre de fichiers <code>.h</code> dans le r\u00e9pertoire <code>/usr/include</code> (indice : <code>wc</code>).</p> <p>:::danger <pre><code>$ wc -l include_files.txt\n</code></pre> ::: 5. Enfin ajouter la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire /usr/include</code> \u00e0 la fin du fichier <code>include_files.txt</code>. :::danger Il faut passer par la substitution de commande et rediriger la sortie standard de <code>echo</code> \u00e0 la fin du fichier <code>include_files.txt</code>. <pre><code>$ echo \"Il y a $(wc -l include_files.txt) fichiers .h dans le r\u00e9pertoire /usr/include &gt;&gt; include_files.txt\n</code></pre> :::</p> </li> </ol>"},{"location":"contenus/draft-corrige-tp4/#exercice-3-redirection-de-lerreur-standard","title":"Exercice 3 : Redirection de l'erreur standard","text":"<ol> <li>Dans un r\u00e9pertoire <code>dir</code> cr\u00e9er un fichier <code>file-1.txt</code> dont le contenu est <code>Hello world !</code>.     :::danger         $ mkdir dir; cd dir         $ echo \"Hello world !\" &gt; file-1.txt     :::</li> <li>Cr\u00e9er ensuite une copie de <code>file-1.txt</code> nomm\u00e9e <code>file-2.txt</code>. Retirez toutes les permissions de lecture sur <code>file-2.txt</code>.     :::danger         $ cp file-1.txt file-2.txt         $ chmod a= file-2.txt     :::</li> <li>Tapez ensuite la commande suivante et notez les r\u00e9sultats (on va avoir des erreur !) :     <pre><code>$ cat file-1.txt file-2.txt file-3.txt\n</code></pre></li> <li>Quelles commande a r\u00e9ussi ? et quelles commandes ont \u00e9chou\u00e9 et pourquoi ?     :::danger<ul> <li>Seul <code>cat file-1.txt</code> a r\u00e9ussi.</li> <li>Pour <code>file-2</code> on n'a pas la permission.</li> <li>Pour <code>file-3</code> le fichier n'existe pas. :::</li> </ul> </li> <li>Faites ensuite une redirection de la sortie standard de la commande pr\u00e9c\u00e9dente vers un fichier <code>result.txt</code>. Observez le ce qui est affich\u00e9 sur le terminal, et observer le contenu du fichier <code>result.txt</code>.     :::danger         $ cat file-1.txt file-2.txt file-3.txt &gt; result.txt     Les erreurs restent affich\u00e9s sur le terminal. Il existe un autre canal pour les erreurs : c'est l'erreur standard (stderr en anglais).     :::</li> <li>Tapez ensuite la commande suivante et notez les r\u00e9sultats :     <pre><code>$ cat file-1.txt file-2.txt file-3.txt 1&gt; result.txt 2&gt; error.txt\n</code></pre></li> <li>Observez les contenus de <code>result.txt</code> et <code>error.txt</code>. Que contiennent-ils ? \u00c0 votre avis que signifie <code>1&gt;</code> et <code>2&gt;</code> ? Tirez-en une conclusion sur la diff\u00e9rence entre la sortie standard et l'erreur standard.     :::danger     La sortie standard est redirig\u00e9e vers <code>result.txt</code> et l'erreur standard est redirig\u00e9e vers le fichier <code>error.txt</code>.<ul> <li>Le chiffre <code>2</code> ici n'est pas optionnel, il faut le marquer pour signifier que l'on redirige l'erreur standard. :::</li> </ul> </li> </ol> <p>:::success \"Redirection de l'entr\u00e9e standard\"</p> <p>Certaines commandes lisent des informations sur le terminal. Par exemple <code>tr, read,...</code>. On dit que ces commandes lisent sur l'entr\u00e9e standard (qui est aussi connect\u00e9e au terminal).</p> <p>Mais beaucoup de commandes lisent \u00e9galement sue le terminal si aucun nom de fichier leur est donn\u00e9 en argument. Par exemple <code>cat, grep, sort,...</code>.</p> <p>Il est possible de rediriger l'entr\u00e9e standard d'une commande vers un fichier en utilisant le caract\u00e8re <code>&lt;</code>. Par exemple : <pre><code>$ cat &lt; fichier.txt\n</code></pre> Cette commande affiche le contenu du fichier <code>fichier.txt</code> sur la sortie standard. On dit que le fichier <code>fichier.txt</code> est connect\u00e9 \u00e0 l'entr\u00e9e standard de la commande <code>cat</code>.</p> <p>:::warning \"Attention\" Il faut que le fichier <code>fichier.txt</code> existe et qu'on ait la permission <code>read</code> sinon la commande <code>cat</code> va \u00e9chouer. :::</p>"},{"location":"contenus/draft-corrige-tp4/#exercice-4-retour-sur-la-commande-cat","title":"Exercice 4 : Retour sur la commande <code>cat</code>","text":"<ol> <li> <p>Revoyez le manuel de la commande <code>cat</code> et trouvez comment elle fonctionne lorsque l'on ne lui donne pas de fichier en argument.</p> </li> <li> <p>Testez ensuite la commande suivante:    <pre><code>$ cat\nhello&lt;newline&gt;\nworld&lt;newline&gt;\nC-d # appuyer sur la touche Ctrl et la touche d en m\u00eame temps\n</code></pre>     Combien d'argument la commande <code>cat</code> a-t-elle re\u00e7u ? Qu'a-t-elle affich\u00e9 ? Pourquoi ?     :::danger     <code>cat</code> ici n'a pas d'argument. Comme indiqu\u00e9 dans l'exo pr\u00e9c\u00e9dent <code>cat</code> sans argument lit sur l'entr\u00e9e stadard. Elle va donc lire tous les caract\u00e8res tap\u00e9 au clavier avant que l'on appuie sur la touche entr\u00e9e (pour le caract\u00e8re <code>&lt;newline&gt;</code>). Directement apr\u00e8s <code>&lt;newline&gt;</code>, les caract\u00e8res lus sont affich\u00e9s sur le terminal.     Vous pouvez leur dire que pour que <code>cat</code> arr\u00eate de lire, on tape sur <code>C-D</code> qui correspond au caract\u00e8re <code>EOF</code> (end of file).     :::</p> </li> <li> <p>Testez ensuite la commande suivante:    <pre><code>$ cat &gt; catout.txt\nhello&lt;newline&gt;\nworld&lt;newline&gt;\nC-d # appuyer sur la touche Ctrl et la touche d en m\u00eame temps\n</code></pre>     Puis affichez le contenu du fichier <code>catout.txt</code>. Que contient-il ? Pourquoi ?     :::danger     Le fichier <code>catout.txt</code> va r\u00e9cup\u00e9rer les r\u00e9sultats de la commande <code>cat</code> qui a lu sur l'entr\u00e9e standard.     :::</p> </li> <li> <p>Tapez enfin la commande suivante :     <pre><code>$ cat &lt; catout.txt\n$ cat 0&lt; catout.txt\n</code></pre></p> <ul> <li>Combien d'argument la commande <code>cat</code> a-t-elle re\u00e7u ? Qu'a-t-elle affich\u00e9 ?</li> <li>Quelle est la diff\u00e9rence entre <code>&lt;</code> et <code>0&lt;</code> ? :::danger</li> <li>Ici aussi la commande <code>cat</code> n'a pas d'arguments, et lit donc sur l'entr\u00e9e standard. Sauf que cette fois-ci, l'entr\u00e9e standard est redirig\u00e9 vers le fichier <code>catout.txt</code>. En d'autres terme <code>cat</code> va lire le contenu de <code>catout.txt</code> comme si on les avait tap\u00e9 au clavier sur le terminal. La commande va donc afficher le contenu de <code>caout.txt</code>. </li> <li>L'utilisation de <code>&lt;</code> et <code>0&lt;</code> produisent exactement le m\u00eame r\u00e9sultat. <code>0</code> est le chiffre correspondant au descripteur de fichier de l'entr\u00e9e standard, et il est optionnel. :::</li> </ul> </li> </ol>"},{"location":"contenus/draft-corrige-tp4/#exercice-5-compter-les-entetes-2","title":"Exercice 5 : Compter les ent\u00eates (2)","text":"<p>Nous allons refaire le m\u00eame exercice que l'exercice 2 mais cette fois-ci en utilisant la redirection de l'entr\u00e9e standard.</p> <ol> <li> <p>Cr\u00e9er un fichier <code>include_files.txt</code> qui liste tous les fichiers du r\u00e9pertoire <code>usr/include</code> dont le nom se termine par <code>.h</code>.</p> <p>:::danger <pre><code>$ ls /usr/include/*.h &gt; include_files.txt\n</code></pre> ::: 3. Tapez ensuite la commande suivante et commentez son r\u00e9sultat: <pre><code>$ wc -l &lt; include_files.txt\n</code></pre> :::danger <code>wc -l</code> compte le nombre de lignes du ou des fichiers pass\u00e9s en argument. Elle lit \u00e9galement sur l'entr\u00e9e standard sans argument. Ici, on a une redirection de l'entr\u00e9e standard. Cette commande va afficher le nombre de lignes du fichier <code>include_files.txt</code>.</p> <p><code>wc -l &lt; include_files.txt</code> et <code>wc -l include_files.txt</code> produisent exactement le m\u00eame r\u00e9sultat. ::: 3. Entrez ensuite la commande suivante et commentez son r\u00e9sultat: <pre><code>$ wc -l &lt; include_files.txt &gt;&gt; include_files.txt\n</code></pre> et observez la derni\u00e8re ligne du fichier <code>include_files.txt</code>. :::danger On a ici une double redirection, redirection de stdin, et redirection de stdout (en mode <code>append</code>). ::: 4. Nous voudrions enfin que la derni\u00e8re ligne du fichier <code>include_files.txt</code> soit la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire usr/include</code>. O\u00f9 <code>&lt;nombre&gt;</code> est le r\u00e9sultat de <code>wc -l &lt; include_files.txt</code>.</p> <p>Trouvez une commande qui permet de faire cela en utilisant \u00e0 la fois la redirection de la sortie standard et de l'entr\u00e9e standard.</p> <p>:::info \"Indice\"</p> <ul> <li>Pour retirer la derni\u00e8re ligne, on peut refaire la commande de la premi\u00e8re question.</li> <li>Ensuite pensez \u00e0 la commande <code>echo</code> et la subsutitution de commande. :::</li> </ul> <p>:::danger En une commande (en vrai en deux)</p> <pre><code>$ ls /usr/include/*.h &gt; include_files.txt\n$ echo \"Il y a $(wc -l include_files.txt) fichiers .h dans le r\u00e9pertoire /usr/include.\" &gt;&gt; include_files.txt\n</code></pre> <p>:::</p> </li> </ol>"},{"location":"contenus/draft-corrige-tp4/#les-tubes","title":"Les tubes","text":"<p>:::success \"Tube\"</p> <p>Un tube (pipe en anglais) est un m\u00e9canisme qui permet de connecter la sortie standard d'une commande \u00e0 l'entr\u00e9e standard d'une autre commande. On utilise le caract\u00e8re <code>|</code> pour cr\u00e9er un tube.</p> <p>C'est-\u00e0-dire que pour <pre><code>$ cmd1 | cmd2\n</code></pre> La sortie standard de <code>cmd1</code> est connect\u00e9e \u00e0 l'entr\u00e9e standard de <code>cmd2</code>. :::</p>"},{"location":"contenus/draft-corrige-tp4/#exercice-6-compter-les-entetes-promis-cest-la-derniere-fois","title":"Exercice 6 : Compter les ent\u00eates (promis c'est la derni\u00e8re fois)","text":"<ol> <li>Testez la commande suivante et commentez son r\u00e9sultat :     <pre><code>$ ls /usr/include/*.h | wc -l\n</code></pre>     O\u00f9 est redirig\u00e9 le r\u00e9sultat de la commande <code>ls</code> ? O\u00f9 est redirig\u00e9 l'entr\u00e9e standard de la commande <code>wc</code> ? O\u00f9 est affich\u00e9 le r\u00e9sultat de <code>wc</code>?     :::danger     On a connect\u00e9 le stdout de la commande <code>ls</code> au stdin de la commande <code>wc</code>.     Vous pouvez faire remarquer que le r\u00e9sultat de la commande <code>ls</code> n'est pas affich\u00e9 dans le terminal, et <code>wc</code>n'a pas d'argument.      :::</li> <li> <p>Afficher sur le terminal ensuite la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire /usr/include</code> en utilisant la commande <code>echo</code> et la substitution de commande (indice la commande \u00e0 utiliser et celle de la question 1).</p> <p>:::danger <pre><code>$ echo \"Il y a $(ls /usr/include/*.h | wc -l) fichiers .h dans le r\u00e9pertoire /usr/include.\"\n</code></pre> :::</p> </li> <li> <p>Enfin, entrez la commande suivante et commentez son r\u00e9sultat :     <pre><code>wc -l $(ls /usr/include/*.h)\n</code></pre></p> </li> <li>\u00c0 votre avis pourquoi le r\u00e9sultat de la derni\u00e8re commande est-il diff\u00e9rent de celui de la commande pr\u00e9c\u00e9dente ?     :::danger     <code>wc -l $(ls /usr/include/*.h)</code> affiche le nombre de ligne de CHACUN des fichiers affich\u00e9 par la commande <code>ls</code>. Le r\u00e9sultat n'est pas le m\u00eame que celle de la question 1, car la substitution de commande est eff\u00e9ctu\u00e9e avant l'ex\u00e9cution de la commande <code>wc</code>. Elle se comporte donc comme si chaque fichier affich\u00e9 par le <code>ls</code> est donn\u00e9 en argument \u00e0 <code>wc</code>.     :::</li> </ol>"},{"location":"contenus/draft-corrige-tp4/#filtre-textuels","title":"Filtre textuels","text":"<p>:::success \"Qu'est ce que c'est ?\" Les filtres textuel sont des commandes qui lisent ou peuvent lire depuis leur entr\u00e9e standard et \u00e9crivent des donn\u00e9es modifi\u00e9es sur leur sortie standard. </p> <p>En voici quelques-uns parmi les plus courants :</p> <ul> <li><code>head</code> : affiche les premi\u00e8res lignes de son entr\u00e9e ;</li> <li><code>tail</code> : affiche les derni\u00e8res lignes de son entr\u00e9e. Avec l\u2019option -f (pour follow, continuer \u00e0 afficher la fin du fichier quand il est mis \u00e0 jour) c\u2019est l\u2019une des commandes pr\u00e9f\u00e9r\u00e9es des administrateurs syst\u00e8mes ;</li> <li><code>grep</code> : une des commandes les plus connues, affiche des lignes correspondant \u00e0 une cha\u00eene, ou plus g\u00e9n\u00e9ralement une expression rationnelle dans son entr\u00e9e ;</li> <li><code>cut</code> : s\u00e9lectionne des champs ou des caract\u00e8res dans chaque ligne de l\u2019entr\u00e9e standard ;</li> <li><code>sort</code> : trie son entr\u00e9e standard suivant des crit\u00e8res.</li> <li><code>tr</code> : remplace des caract\u00e8res dans son entr\u00e9e standard.</li> <li><code>uniq</code> : supprime les lignes cons\u00e9cutives identiques dans son entr\u00e9e standard. :::</li> </ul>"},{"location":"contenus/draft-corrige-tp4/#exercice-7-frere-jacques","title":"Exercice 7 : Fr\u00e8re Jacques","text":"<ol> <li>Cr\u00e9er un fichier <code>fj</code> contenant ces lignes :     <pre><code>Fr\u00e8re Jaques, \nFr\u00e8re Jacques,                    \nDormez-vous,\nDormez-vous,\nSonnez les matines,\nSonnez les matines !\nDing !\nDing ! \nDong !\n</code></pre>     avec la commande <code>echo</code> (le caract\u00e8re <code>&lt;newline&gt;</code> correspond \u00e0 la touche entr\u00e9e de votre clavier):     <pre><code>$ echo 'Fr\u00e8re Jaques,&lt;newline&gt; \n&gt; Fr\u00e8re Jacques,&lt;newline&gt;                     \n&gt; Dormez-vous,&lt;newline&gt; \n&gt; Dormez-vous,&lt;newline&gt; \n&gt; Sonnez les matines,&lt;newline&gt; \n&gt; Sonnez les matines !&lt;newline&gt; \n&gt; Ding !&lt;newline&gt; \n&gt; Ding !&lt;newline&gt; \n&gt; Dong !' &gt; fj\n</code></pre></li> <li> <p>Testez ensuite les commandes suivantes et observez leur r\u00e9sultats:     <pre><code>$ cat fj \n$ head fj\n$ tail fj\n$ head -n 2 fj\n$ tail -n 3 fj\n$ grep \"Dormez\" fj\n$ grep -v \"Dormez\" fj\n$ grep \"dormez\" fj\n$ grep -i \"dormez\" fj\n$ sort fj \n$ uniq fj\n$ cut -c 1 fj\n$ cut -c 2 fj\n$ cut -c 1-3 fj\n$ cut -d ' ' -f 1 fj\n$ cut -d ' ' -f 1,2 fj\n</code></pre></p> <ul> <li>O\u00f9 sont affich\u00e9s les r\u00e9sultats ?</li> <li>\u00c0 quoi servent les options <code>-n</code> de <code>head</code> et <code>tail</code> ? </li> <li>\u00c0 quoi sert l'option <code>-v</code> de <code>grep</code> ? \u00c0 quoi sert l'option <code>-i</code> de <code>grep</code> ?</li> <li>\u00c0 quoi servent les options <code>-c</code> et <code>-d</code> de <code>cut</code> ?</li> </ul> </li> <li> <p>Testez ensuite la commande      <pre><code>$ tr a-z A-Z fj\n</code></pre>     \u00c0 votre avis pourquoi la commande \u00e9choue ?      :::danger     <code>tr</code> ne lit que sur l'entr\u00e9e standard.     :::</p> </li> <li>Tapez ensuite les commandes suivantes et commentez son r\u00e9sultat :     <pre><code>$ tr a-z A-Z &lt; fj\n$ tr S D &lt; fj\n$ tail -n 3 fj | tr D B &gt;&gt; fj\n$ cat fj\n</code></pre>     Que pouvez-vous conclure sur la commande <code>tr</code> ?     :::danger     La syntaxe est <code>tr SET1 [SET2]</code>, cette commande remplace les \u00e9l\u00e9ments de SET1 par SET2, elle lit uniquement sur l'entr\u00e9e standard.      :::</li> </ol>"},{"location":"contenus/draft-corrige-tp4/#exercice-8-dernier-round-des-fichiers-dentetes","title":"Exercice 8 : Dernier round des fichiers d'ent\u00eates","text":"<p>:::info \"Nom de base\" Le nom de base d'un fichier est le nom du fichier sans son extension. Par exemple le nom de base du fichier <code>/usr/include/stdio.h</code> est <code>stdio</code>. :::</p> <p>Dans cet exercice, nous voudrions afficher sur le terminal le nom de base des 10 fichiers les plus l\u00e9gers (en taille en octets) parmi les fichier <code>.h</code> du r\u00e9pertoire <code>/usr/include</code>.</p> <p>En utilisant les commande <code>wc</code>, <code>sort</code>, <code>cut</code>, <code>head</code> (ou \u00e9ventuellement <code>tail</code>), et les redirection par tube, \u00e9crivez une commande qui affiche le nom de base des 10 fichiers les plus l\u00e9gers parmi les fichiers <code>.h</code> du r\u00e9pertoire <code>/usr/include</code>.</p> <p>:::info \"Indication\"</p> <ul> <li>L'option <code>-c</code> de <code>wc</code> vous donne le nombre d'octets d'un fichier.</li> <li>L'option <code>-n</code> de <code>sort</code> vous permet de trier les lignes d'un fichier par ordre num\u00e9rique.</li> <li> <p>L'option <code>-d</code> de <code>tr</code> supprime les caract\u00e8res re\u00e7us en premiers argument au lieu de les remplacer. ::: Si vous avez install\u00e9 <code>gcc</code>, vous devriez avoir : <pre><code>pool\nwait\nsyslog\nsyscall\nlastlog\ntermio\nstab\nmemory\nre_comp\nalloca\n</code></pre> :::danger</p> <p>$ wc -c $(ls /usr/include/*.h) | sort -n | head -n 10 | tr -d ' ' | cut -d / -f4 | cut -d . -f1 :::</p> </li> </ul>"},{"location":"contenus/draft-corrige-tp4/#exercice-9-plus-sur-grep","title":"Exercice 9 : Plus sur <code>grep</code>","text":"<p>:::success \"Passer un r\u00e9pertoire en argument de <code>grep</code>\"</p> <ul> <li>L'option <code>-r</code> de <code>grep</code> permet de passer un r\u00e9pertoire en argument. Et lui demande de chercher dans tous les fichiers de ce r\u00e9pertoire.</li> <li> <p>L'option <code>-l</code> de <code>grep</code> permet de n'afficher que le nom des fichiers qui contiennent la cha\u00eene recherch\u00e9e. ::: En utilisant <code>grep</code> et \u00e9ventuellement d'autres commandes, trouvez une ligne de commande qui permet de:</p> </li> <li> <p>Afficher la valeur de <code>RAND_MAX</code> (c'est une constante de la librairie standard de C). </p> </li> <li>Afficher le chemin absolu des fichiers qui contiennent de la cha\u00eene <code>127.0.0.1</code> dans les fichiers de <code>/etc</code>.</li> <li>Afficher uniquement le nom des fichiers qui contiennent de la cha\u00eene <code>127.0.0.1</code> dans les fichiers de <code>/etc</code>. (indice : il existe une commande qui s'appelle <code>rev</code>).</li> <li>Affiche le chemin du r\u00e9pertoire personnel de l'utilisateur <code>games</code>.</li> </ul> <p>:::danger <code>bash= grep -r \"RAND_MAX\" /usr/include | head -n 1 | tr '\\t' ' ' | cut -d ' ' -f 3 grep -lr \"127.0.0.1\" /etc 2&gt; /dev/null grep -lr \"127.0.0.1\" /etc 2&gt; /dev/ null | rev | cut -d / -f 1 | rev grep \"games\" /etc/passwd | cut -d : -f 6</code> :::</p>"},{"location":"contenus/installation-wsl/","title":"Installation d'une distribution Linux","text":""},{"location":"contenus/installation-wsl/#installation-dune-distribution-linux-via-virtualbox-sur-windows-et-macos","title":"Installation d'une distribution Linux via VirtualBox sur Windows et MacOS","text":"<p>Objectif p\u00e9dagogique</p> <p>Dans ce tutoriel, vous allez apprendre \u00e0 installer une distribution Linux (Debian 12) dans une machine virtuelle \u00e0 l\u2019aide du logiciel VirtualBox.</p> <p>Pr\u00e9requis</p> <p>Avant de commencer, assurez-vous d\u2019avoir :</p> <ul> <li>Une connexion internet stable</li> <li>Au moins 10 Go d\u2019espace libre</li> <li> <p>VirtualBox install\u00e9 sur votre syst\u00e8me :</p> <p>Windows </p> <p>ou MacOS (Sur des processeurs Intel)</p> </li> <li> <p>Le fichier ISO de Debian (image disque)</p> </li> </ul> <p>Attention \u00e0 la puce Apple Silicon (M1/M2/M3)</p> <p>VirtualBox ne prend pas encore pleinement en charge les puces Apple Silicon. Pour ces machines, privil\u00e9giez UTM </p> <p>Instructions</p> <p>Il est essentiel de suivre attentivement les instructions, certaines \u00e9tapes \u00e9tant sp\u00e9cifiques \u00e0 Windows, \u00e0 macOS (processeur Intel), ou aux deux. Veillez donc \u00e0 respecter scrupuleusement les indications correspondant \u00e0 votre syst\u00e8me.</p> <p>Pour l'installation de :</p> <ul> <li>Windows : suivre les \u00e9tapes 1, 2, 3, 4, 5, 6, 7, 9</li> <li>MacOs :.  suivre les \u00e9tapes 1, 2, 3, 5, 6, 8, 9</li> </ul>"},{"location":"contenus/installation-wsl/#etape-1-telecharger-virtualbox","title":"\u00c9tape 1 : T\u00e9l\u00e9charger VirtualBox","text":"<ol> <li>Allez sur le site officiel : https://www.virtualbox.org</li> <li>Cliquez sur le bouton Download VirtualBox. </li> <li>Choisissez la version adapt\u00e9e \u00e0 votre syst\u00e8me d\u2019exploitation (Windows, macOS, Linux). </li> <li>Une fois le fichier t\u00e9l\u00e9charg\u00e9, installez VirtualBox en suivant l\u2019assistant d\u2019installation.</li> </ol> <p>Extension Pack</p> <p>Il est recommand\u00e9 d\u2019installer le \"VirtualBox Extension Pack\" pour b\u00e9n\u00e9ficier de fonctions suppl\u00e9mentaires comme le copier-coller entre h\u00f4te et invit\u00e9.</p>"},{"location":"contenus/installation-wsl/#etape-2-telecharger-limage-iso-de-debian","title":"\u00c9tape 2 : T\u00e9l\u00e9charger l\u2019image ISO de Debian","text":"<ol> <li>Rendez-vous sur : https://www.debian.org/</li> <li>T\u00e9l\u00e9chargez la version 64 bits (amd64) : debian-12.11.0-amd64-netinst.iso</li> </ol>"},{"location":"contenus/installation-wsl/#etape-3-creer-une-machine-virtuelle","title":"\u00c9tape 3 : Cr\u00e9er une machine virtuelle","text":"<ol> <li>Lancez VirtualBox et cliquez sur \"Nouvelle\". </li> <li>Donnez un nom \u00e0 votre machine virtuelle (par exemple \"Debian12\").</li> <li>Choisissez :<ul> <li>Type : Linux</li> <li>Version : Debian (64-bit)</li> </ul> </li> <li>Cliquez ensuite sur \"Suivant\".  </li> </ol>"},{"location":"contenus/installation-wsl/#etape-4-configuration-des-parametres-utilisateurs","title":"\u00c9tape 4 : Configuration des param\u00e8tres utilisateurs","text":"<p>Notez bien</p> <p>Cette \u00e9tape concerne exclusivement l'installation sous Windows.</p> <p>Assurez-vous que le nom d'utilisateur soit enti\u00e8rement en minuscules. </p> <ul> <li>Exemple : yvan</li> <li>Vous pouvez \u00e9galement conserver le nom d'utilisateur par d\u00e9faut qui vous est propos\u00e9</li> </ul>"},{"location":"contenus/installation-wsl/#etape-5-allouer-de-la-memoire-vive-ram","title":"\u00c9tape 5 : Allouer de la m\u00e9moire vive (RAM)","text":"<p>Allouez au moins 2048 Mo (2 Go) si vous avez assez de RAM.</p> <p>Recommandation</p> <p>Ne d\u00e9passez pas 50 % de votre m\u00e9moire totale.</p> <p></p>"},{"location":"contenus/installation-wsl/#etape-6-creer-un-disque-dur-virtuel","title":"\u00c9tape 6 : Cr\u00e9er un disque dur virtuel","text":"<ol> <li>Choisissez \"Cr\u00e9er un disque dur virtuel maintenant\".</li> <li>Laissez le type VDI (VirtualBox Disk Image) par d\u00e9faut.</li> <li>Choisissez allocation dynamique.</li> <li>D\u00e9finissez une taille de disque de 10 Go ou plus. </li> <li>V\u00e9rifier les param\u00e8tres de vos \"Configurations\".</li> <li>Ensuite cliquer sur \"Finish\" </li> </ol>"},{"location":"contenus/installation-wsl/#etape-7-finalisation-de-linstallation-sous-windows","title":"\u00c9tape 7 : Finalisation de l'installation sous Windows","text":"<ol> <li>Une fois l'installation termin\u00e9e, entrer vos param\u00e8tres de connexion  </li> <li>Fermez les diff\u00e9rentes fen\u00eatres qui vont s'afficher.</li> <li>Ensuite cliquer sur \"Show Applications\"</li> <li>Vous pouvez ensuite ouvrir le \"Terminal\"  </li> </ol>"},{"location":"contenus/installation-wsl/#etape-8-verifier-que-limage-iso-a-bien-ete-insere-et-finalisation-de-linstallation-sous-macos","title":"\u00c9tape 8 : V\u00e9rifier que l\u2019image ISO a bien \u00e9t\u00e9 ins\u00e9r\u00e9 et finalisation de l'installation sous MacOS","text":"<ol> <li>Une fois la VM cr\u00e9\u00e9e, s\u00e9lectionnez-la et cliquez sur \"Configuration\". </li> <li>Allez dans l\u2019onglet \"Stockage\".</li> <li>Cliquez sur le lecteur vide et s\u00e9lectionnez \"Choisir un fichier disque\".</li> <li>S\u00e9lectionnez l\u2019ISO Debian t\u00e9l\u00e9charg\u00e9. </li> <li>Cliquez sur \"D\u00e9marrer\" pour lancer la VM.</li> <li>L\u2019installateur Debian va appara\u00eetre. Choisissez Install ou Graphical Install. </li> <li>Suivez les \u00e9tapes :<ul> <li>Choisissez la langue, la localisation, le clavier</li> <li>D\u00e9finition du nom de l\u2019ordinateur.</li> <li>Cr\u00e9ation du compte utilisateur + mot de passe (utilisez un nom simple en minuscules et ne contenant pas d'espace.) </li> </ul> </li> <li>Partitionner le disque<ul> <li>Choisissez  Guided \u2013 use entire disk</li> <li>Choisissez le disque propos\u00e9 (sda en g\u00e9n\u00e9ral)</li> <li>Choisissez All files in one partition</li> <li>Confirmez avec Finish partitioning and write changes to disk</li> </ul> </li> <li>Installation du syst\u00e8me<ul> <li>L'installation d\u00e9marre, attendez la fin</li> <li>Acceptez l\u2019installation du GRUB bootloader si demand\u00e9.</li> <li>Terminez et red\u00e9marrez la machine virtuelle.</li> </ul> </li> </ol>"},{"location":"contenus/installation-wsl/#etape-9-verification-finale-et-test","title":"\u00c9tape 9 : V\u00e9rification finale et test","text":"<p>\u00c0 faire</p> <ol> <li>Une fois l\u2019installation termin\u00e9e, pensez \u00e0 retirer l\u2019ISO de l\u2019installation :<ul> <li>Allez dans \"P\u00e9riph\u00e9riques\" &gt; \"Lecteurs optiques\"</li> <li>Si l'image iso n'est pas retirer (debian-12.11.0-amd64-netinst.iso), cliquer sur \"Retirer le disque\"</li> </ul> </li> <li>Testez quelques commandes : <pre><code>    whoami\n    hostname\n    ls /\n    uname -a\n</code></pre></li> </ol>"},{"location":"contenus/installation-wsl/#installation-dune-distribution-linux-via-utm-sur-macos-puces-m1m2m3","title":"Installation d'une distribution Linux via UTM sur MacOS (Puces M1/M2/M3)","text":"<p>Objectif p\u00e9dagogique</p> <p>Permettre aux \u00e9tudiants d\u2019installer un syst\u00e8me GNU/Linux Debian dans un environnement virtualis\u00e9 adapt\u00e9 aux Mac \u00e9quip\u00e9s de puces  Apple Silicon (M1/M2/M3), afin de d\u00e9couvrir un OS libre et pratiquer en toute s\u00e9curit\u00e9.</p>"},{"location":"contenus/installation-wsl/#prerequis","title":"Pr\u00e9requis","text":"<p>Avant de commencer, assurez-vous de disposer : </p> <ul> <li>D\u2019un Mac avec une puce Apple Silicon (M1 ou M2 ou M3).</li> <li>D\u2019au moins 8 Go de RAM et 20 Go d\u2019espace libre.</li> <li>D'une bonne connexion internet</li> </ul>"},{"location":"contenus/installation-wsl/#etape-1-telecharger-et-installer-utm","title":"\u00c9tape 1 : T\u00e9l\u00e9charger et installer UTM","text":"<ol> <li>Rendez-vous sur le site officiel : https://mac.getutm.app/</li> <li>Cliquez sur Download </li> <li>Ouvrez le fichier .dmg puis glissez UTM.app dans votre dossier Applications.</li> </ol>"},{"location":"contenus/installation-wsl/#etape-2-telecharger-debian-pour-arm64","title":"\u00c9tape 2 : T\u00e9l\u00e9charger Debian pour ARM64","text":"<p>Warning</p> <p>N\u2019utiliser pas d\u2019image \u201cx86_64\u201d, car elle est incompatible avec les puces M1/M2/M3 sans \u00e9mulation lente.</p> <ol> <li>Allez sur : https://cdimage.debian.org/debian-cd/current/arm64/iso-cd/</li> <li>T\u00e9l\u00e9chargez la version netinst (cliquez par exemple sur debian-12.11.0-arm64-netinst.iso). </li> <li>Enregistrez le fichier dans un endroit accessible (par exemple T\u00e9l\u00e9chargements).</li> </ol>"},{"location":"contenus/installation-wsl/#etape-3-creer-une-nouvelle-machine-virtuelle-dans-utm","title":"\u00c9tape 3 : Cr\u00e9er une nouvelle machine virtuelle dans UTM","text":"<ol> <li>Ouvrez UTM.</li> <li>Cliquez sur + pour cr\u00e9er une nouvelle VM.</li> <li>Cliquez sur Virtualize (et non Emulate).</li> <li>Choisissez l\u2019option Linux, puis selectionner le fichier precedemment t\u00e9l\u00e9charg\u00e9. </li> <li>Cliquez sur Continuer.</li> </ol>"},{"location":"contenus/installation-wsl/#etape-4-definir-la-memoire-le-stockage-et-creer-la-vm","title":"\u00c9tape 4 : D\u00e9finir la m\u00e9moire, le stockage et cr\u00e9er la VM","text":"<ol> <li>Allouez 4 Go de RAM (4096 Mo).</li> <li> <p>Allouez 2 CPU minimum. </p> </li> <li> <p>Allouez 20 Go de stockage minimum.</p> </li> <li>Donnez un nom (ex. : Debian-UTM-M1).</li> <li>Cliquez sur Enregistrer</li> </ol>"},{"location":"contenus/installation-wsl/#etape-5-lancer-la-machine-virtuelle","title":"\u00c9tape 5 : Lancer la machine virtuelle","text":"<ol> <li>Cliquez sur la VM dans la liste (ex. : Debian-UTM-M1).</li> <li>Cliquez sur Play.  </li> <li>Cliquer sur \"Install\". Ensuite suivez les instructions d'installation de la distribution :<ul> <li>Choix de la langue;</li> <li>Partition automatique;</li> <li>Cr\u00e9ation de l'utilisateur;</li> <li>Mot de passe root</li> </ul> </li> <li>Red\u00e9marre une fois l'installation termin\u00e9e.</li> </ol> <p>Tip</p> <p>Si tu vois un \u00e9cran noir au red\u00e9marrage, \u00e9teins la VM, va dans Settings --&gt; Drives et retire l\u2019ISO. Ensuite red\u00e9marrer \u00e0 nouveau la machine virtuelle. </p>"},{"location":"contenus/installation-wsl/#etape-6-premiere-utilisation","title":"\u00c9tape 6 : Premi\u00e8re utilisation","text":"<ol> <li>Connexion avec vos param\u00e8tres utilisateurs</li> <li>Lancer le terminal (<code>Ctrl + Alt + T</code> ou via le menu).</li> <li>Taper les commandes suivantes : <pre><code>uname -a\nlscpu\nlsblk\n</code></pre></li> <li>Mise \u00e0 jour de la distribution : <pre><code>sudo apt update &amp;&amp; sudo apt upgrade\n</code></pre></li> </ol>"},{"location":"contenus/old-tp4/","title":"TP4 - Filtres textuels, redirection et tubes","text":"<p>Instructions</p> <ul> <li>On rappelle que dans tous les exercices le <code>$</code> en d\u00e9but de commande repr\u00e9sente le prompt, il n'est pas \u00e0 saisir lorsque vous \u00e9crivez une ligne de commande.</li> <li>Pour chaque nouvelle commande, n'h\u00e9sitez pas \u00e0 consulter sa page de manuel avec la commande <code>man</code>, ou \u00e0 utiliser l'option <code>--help</code> (si elle est disponible) pour savoir ce qu'elle fait.</li> <li>N'h\u00e9sitez pas \u00e0 reconsulter les anciens TP pour vous aider.</li> </ul>"},{"location":"contenus/old-tp4/#canaux-standards-et-redirections","title":"Canaux standards et redirections","text":"<p>Redirection de la sortie standard</p> <p>La plupart des commandes que nous avons \u00e9tudi\u00e9es \u00e9crivent leur r\u00e9sultat sur le terminal. Par exemple <code>ls, echo, cat,...</code>. On dit que ces commandes \u00e9crivent sur la sortie standard (qui est connect\u00e9e au terminal) </p> <p>Il est possible de rediriger la sortie standard vers un fichier en utilisant le caract\u00e8re <code>&gt;</code>. Par exemple : <pre><code>$ ls ~ # affiche le contenu du r\u00e9pertoire personnel sur la sortie standard\n$ ls ~ &gt; list_files.txt # redirige la sortie standard vers le fichier list_files\n</code></pre></p> <p>Attention</p> <p>La redirection de la sortie standard va cr\u00e9er le fichier <code>list_files.txt</code> s'il n'existe pas.</p> <p>La redirection \u00e9crase le contenu d'un fichier existant. Si on veut ajouter le r\u00e9sultat \u00e0 la fin du fichier, on utilise le caract\u00e8re <code>&gt;&gt;</code>.</p>"},{"location":"contenus/old-tp4/#exercice-1-redirection-de-la-sortie-standard","title":"Exercice 1 : Redirection de la sortie standard","text":"<ol> <li>Testez les commandes suivantes et observez leur r\u00e9sultats. <pre><code>$ echo \"Est-ce que j'apparais sur le terminal ?\"\n$ echo \"Ou bien dans le fichier ?\" &gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Et moi ?\" &gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je ne veux pas vider le fichier\" &gt;&gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je veux vider le fichier\" 1&gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je m'ajoute en fin de ligne\" 1&gt;&gt; fichier.txt\n</code></pre></li> <li> <p>Rappeler ce que fait la commande <code>cat</code> (man <code>cat</code>) puis \u00e0 partir des r\u00e9sultats des commandes pr\u00e9c\u00e9dentes:</p> <ul> <li>Quelle est la diff\u00e9rence entre <code>&gt;</code> et <code>&gt;&gt;</code> ?</li> <li>Quelle est la diff\u00e9rence entre <code>1&gt;</code> et <code>&gt;</code> ?</li> <li>Quelle est la diff\u00e9rence entre <code>1&gt;&gt;</code> et <code>&gt;&gt;</code> ?</li> </ul> </li> <li> <p>Placez-vous dans votre r\u00e9pertoire personnel et ex\u00e9cutez la commande suivante :     <pre><code>$ ls &gt; list_files.txt; cat list_files.txt\n</code></pre></p> <ul> <li>Que fait cette commande ?</li> <li>Pouvez-vous expliquer pourquoi la cha\u00eene <code>list_files.txt</code> appara\u00eet dans le fichier <code>list_files.txt</code> ?</li> </ul> </li> </ol>"},{"location":"contenus/old-tp4/#exercice-2-compter-les-entetes-1","title":"Exercice 2 : Compter les ent\u00eates (1)","text":"<ol> <li>En vous aidant de la redirection de la sortie standard, cr\u00e9er un fichier <code>include_files.txt</code> qui liste tous les fichiers du r\u00e9pertoire <code>/usr/include</code> dont le nom se termine par <code>.h</code>.</li> <li>Compter le nombre de fichiers <code>.h</code> dans le r\u00e9pertoire <code>/usr/include</code> (indice : <code>wc</code>).</li> <li>Enfin ajouter la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire /usr/include</code> \u00e0 la fin du fichier <code>include_files.txt</code>.</li> </ol>"},{"location":"contenus/old-tp4/#exercice-3-redirection-de-lerreur-standard","title":"Exercice 3 : Redirection de l'erreur standard","text":"<ol> <li>Dans un r\u00e9pertoire <code>dir</code> cr\u00e9er un fichier <code>file-1.txt</code> dont le contenu est <code>Hello world !</code>.</li> <li>Cr\u00e9er ensuite une copie de <code>file-1.txt</code> nomm\u00e9e <code>file-2.txt</code>. Retirez toutes les permissions de lecture sur <code>file-2.txt</code>.</li> <li>Tapez ensuite la commande suivante et notez les r\u00e9sultats (on va avoir des erreur !) :     <pre><code>$ cat file-1.txt file-2.txt file-3.txt\n</code></pre></li> <li>Quelles commande a r\u00e9ussi ? et quelles commandes ont \u00e9chou\u00e9 et pourquoi ?</li> <li>Faites ensuite une redirection de la sortie standard de la commande pr\u00e9c\u00e9dente vers un fichier <code>result.txt</code>. Observez le ce qui est affich\u00e9 sur le terminal, et observer le contenu du fichier <code>result.txt</code>.</li> <li>Tapez ensuite la commande suivante et notez les r\u00e9sultats :     <pre><code>$ cat file-1.txt file-2.txt file-3.txt 1&gt; result.txt 2&gt; error.txt\n</code></pre></li> <li>Observez les contenus de <code>result.txt</code> et <code>error.txt</code>. Que contiennent-ils ? \u00c0 votre avis que signifie <code>1&gt;</code> et <code>2&gt;</code> ? Tirez-en une conclusion sur la diff\u00e9rence entre la sortie standard et l'erreur standard.</li> </ol> <p>Redirection de l'entr\u00e9e standard</p> <p>Certaines commandes lisent des informations sur le terminal. Par exemple <code>tr, read,...</code>. On dit que ces commandes lisent sur l'entr\u00e9e standard (qui est aussi connect\u00e9e au terminal).</p> <p>Mais beaucoup de commandes lisent \u00e9galement sue le terminal si aucun nom de fichier leur est donn\u00e9 en argument. Par exemple <code>cat, grep, sort,...</code>.</p> <p>Il est possible de rediriger l'entr\u00e9e standard d'une commande vers un fichier en utilisant le caract\u00e8re <code>&lt;</code>. Par exemple : <pre><code>$ cat &lt; fichier.txt\n</code></pre> Cette commande affiche le contenu du fichier <code>fichier.txt</code> sur la sortie standard. On dit que le fichier <code>fichier.txt</code> est connect\u00e9 \u00e0 l'entr\u00e9e standard de la commande <code>cat</code>.</p> <p>Attention</p> <p>Il faut que le fichier <code>fichier.txt</code> existe et qu'on ait la permission <code>read</code> sinon la commande <code>cat</code> va \u00e9chouer.</p>"},{"location":"contenus/old-tp4/#exercice-4-retour-sur-la-commande-cat","title":"Exercice 4 : Retour sur la commande <code>cat</code>","text":"<ol> <li>Revoyez le manuel de la commande <code>cat</code> et trouvez comment elle fonctionne lorsque l'on ne lui donne pas de fichier en argument.</li> <li> <p>Testez ensuite la commande suivante:    <pre><code>$ cat\nhello&lt;newline&gt;\nworld&lt;newline&gt;\nC-d # appuyer sur la touche Ctrl et la touche d en m\u00eame temps\n</code></pre>     Combien d'argument la commande <code>cat</code> a-t-elle re\u00e7u ? Qu'a-t-elle affich\u00e9 ? Pourquoi ?</p> </li> <li> <p>Testez ensuite la commande suivante:    <pre><code>$ cat &gt; catout.txt\nhello&lt;newline&gt;\nworld&lt;newline&gt;\nC-d # appuyer sur la touche Ctrl et la touche d en m\u00eame temps\n</code></pre>     Puis affichez le contenu du fichier <code>catout.txt</code>. Que contient-il ? Pourquoi ?</p> </li> <li>Tapez enfin la commande suivante :     <pre><code>$ cat &lt; catout.txt\n$ cat 0&lt; catout.txt\n</code></pre><ul> <li>Combien d'argument la commande <code>cat</code> a-t-elle re\u00e7u ? Qu'a-t-elle affich\u00e9 ?</li> <li>Quelle est la diff\u00e9rence entre <code>&lt;</code> et <code>0&lt;</code> ?</li> </ul> </li> </ol>"},{"location":"contenus/old-tp4/#exercice-5-compter-les-entetes-2","title":"Exercice 5 : Compter les ent\u00eates (2)","text":"<p>Nous allons refaire le m\u00eame exercice que l'exercice 2 mais cette fois-ci en utilisant la redirection de l'entr\u00e9e standard.</p> <ol> <li>Cr\u00e9er un fichier <code>include_files.txt</code> qui liste tous les fichiers du r\u00e9pertoire <code>/usr/include</code> dont le nom se termine par <code>.h</code>.</li> <li>Tapez ensuite la commande suivante et commentez son r\u00e9sultat:     <pre><code>$ wc -l &lt; include_files.txt\n</code></pre></li> <li>Entrez ensuite la commande suivante et commentez son r\u00e9sultat:     <pre><code>$ wc -l &lt; include_files.txt &gt;&gt; include_files.txt\n</code></pre>     et observez la derni\u00e8re ligne du fichier <code>include_files.txt</code>.</li> <li> <p>Nous voudrions enfin que la derni\u00e8re ligne du fichier <code>include_files.txt</code> soit la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire /usr/include</code>. O\u00f9 <code>&lt;nombre&gt;</code> est le r\u00e9sultat de <code>wc -l &lt; include_files.txt</code>.</p> <p>Trouvez une commande qui permet de faire cela en utilisant \u00e0 la fois la redirection de la sortie standard et de l'entr\u00e9e standard.</p> <p>Indice</p> <ul> <li>Pour retirer la derni\u00e8re ligne, on peut refaire la commande de la premi\u00e8re question.</li> <li>Ensuite pensez \u00e0 la commande <code>echo</code> et la subsutitution de commande.</li> </ul> </li> </ol>"},{"location":"contenus/old-tp4/#les-tubes","title":"Les tubes","text":"<p>Tubes</p> <p>Un tube (pipe en anglais) est un m\u00e9canisme qui permet de connecter la sortie standard d'une commande \u00e0 l'entr\u00e9e standard d'une autre commande. On utilise le caract\u00e8re <code>|</code> pour cr\u00e9er un tube.</p> <p>C'est-\u00e0-dire que pour <pre><code>$ cmd1 | cmd2\n</code></pre> La sortie standard de <code>cmd1</code> est connect\u00e9e \u00e0 l'entr\u00e9e standard de <code>cmd2</code>.</p>"},{"location":"contenus/old-tp4/#exercice-6-compter-les-entetes-promis-cest-la-derniere-fois","title":"Exercice 6 : Compter les ent\u00eates (promis c'est la derni\u00e8re fois)","text":"<ol> <li>Testez la commande suivante et commentez son r\u00e9sultat :     <pre><code>$ ls /usr/include/*.h | wc -l\n</code></pre>     O\u00f9 est redirig\u00e9 le r\u00e9sultat de la commande <code>ls</code> ? O\u00f9 est redirig\u00e9 l'entr\u00e9e standard de la commande <code>wc</code> ? O\u00f9 est affich\u00e9 le r\u00e9sultat de <code>wc</code>?</li> <li>Affichez ensuite sur le terminal la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire /usr/include</code> en utilisant la commande <code>echo</code> et la substitution de commande (indice la commande \u00e0 utiliser et celle de la question 1).    </li> <li>Enfin, entrez la commande suivante et commentez son r\u00e9sultat :     <pre><code>wc -l $(ls /usr/include/*.h)\n</code></pre></li> <li>\u00c0 votre avis pourquoi le r\u00e9sultat de la derni\u00e8re commande est-il diff\u00e9rent de celui de la question 1 ?</li> </ol>"},{"location":"contenus/old-tp4/#filtre-textuels","title":"Filtre textuels","text":"<p>Qu'est ce que c'est ?</p> <p>Les filtres textuel sont des commandes qui lisent ou peuvent lire depuis leur entr\u00e9e standard et \u00e9crivent des donn\u00e9es modifi\u00e9es sur leur sortie standard. </p> <p>En voici quelques-uns parmi les plus courants :</p> <ul> <li><code>head</code> : affiche les premi\u00e8res lignes de son entr\u00e9e ;</li> <li><code>tail</code> : affiche les derni\u00e8res lignes de son entr\u00e9e. Avec l\u2019option -f (pour follow, continuer \u00e0 afficher la fin du fichier quand il est mis \u00e0 jour) c\u2019est l\u2019une des commandes pr\u00e9f\u00e9r\u00e9es des administrateurs syst\u00e8mes ;</li> <li><code>grep</code> : une des commandes les plus connues, affiche des lignes correspondant \u00e0 une cha\u00eene, ou plus g\u00e9n\u00e9ralement une expression rationnelle dans son entr\u00e9e ;</li> <li><code>cut</code> : s\u00e9lectionne des champs ou des caract\u00e8res dans chaque ligne de l\u2019entr\u00e9e standard ;</li> <li><code>sort</code> : trie son entr\u00e9e standard suivant des crit\u00e8res.</li> <li><code>tr</code> : remplace des caract\u00e8res dans son entr\u00e9e standard.</li> <li><code>uniq</code> : supprime les lignes cons\u00e9cutives identiques dans son entr\u00e9e standard.</li> </ul>"},{"location":"contenus/old-tp4/#exercice-7-frere-jacques","title":"Exercice 7 : Fr\u00e8re Jacques","text":"<ol> <li>Cr\u00e9er un fichier <code>fj</code> contenant ces lignes :     <pre><code>Fr\u00e8re Jaques, \nFr\u00e8re Jacques,                    \nDormez-vous,\nDormez-vous,\nSonnez les matines,\nSonnez les matines !\nDing !\nDing ! \nDong !\n</code></pre>     avec la commande <code>echo</code> (le caract\u00e8re <code>&lt;newline&gt;</code> correspond \u00e0 la touche entr\u00e9e de votre clavier):     <pre><code>$ echo 'Fr\u00e8re Jaques,&lt;newline&gt; \n&gt; Fr\u00e8re Jacques,&lt;newline&gt;                     \n&gt; Dormez-vous,&lt;newline&gt; \n&gt; Dormez-vous,&lt;newline&gt; \n&gt; Sonnez les matines,&lt;newline&gt; \n&gt; Sonnez les matines !&lt;newline&gt; \n&gt; Ding !&lt;newline&gt; \n&gt; Ding !&lt;newline&gt; \n&gt; Dong !' &gt; fj\n</code></pre></li> <li> <p>Testez ensuite les commandes suivantes et observez leur r\u00e9sultats:     <pre><code>$ cat fj \n$ head fj\n$ tail fj\n$ head -n 2 fj\n$ tail -n 3 fj\n$ grep \"Dormez\" fj\n$ grep -v \"Dormez\" fj\n$ grep \"dormez\" fj\n$ grep -i \"dormez\" fj\n$ sort fj \n$ uniq fj\n$ cut -c 1 fj\n$ cut -c 2 fj\n$ cut -c 1-3 fj\n$ cut -d ' ' -f 1 fj\n$ cut -d ' ' -f 1,2 fj\n</code></pre></p> <ul> <li>O\u00f9 sont affich\u00e9s les r\u00e9sultats ?</li> <li>\u00c0 quoi servent les options <code>-n</code> de <code>head</code> et <code>tail</code> ? </li> <li>\u00c0 quoi sert l'option <code>-v</code> de <code>grep</code> ? \u00c0 quoi sert l'option <code>-i</code> de <code>grep</code> ?</li> <li>\u00c0 quoi servent les options <code>-c</code> et <code>-d</code> de <code>cut</code> ?</li> </ul> </li> <li> <p>Testez ensuite la commande      <pre><code>$ tr a-z A-Z fj\n</code></pre>     \u00c0 votre avis pourquoi la commande \u00e9choue ? </p> </li> <li>Tapez ensuite les commandes suivantes et commentez son r\u00e9sultat :     <pre><code>$ tr a-z A-Z &lt; fj\n$ tr S D &lt; fj\n$ tail -n 3 fj | tr D B &gt;&gt; fj\n$ cat fj\n</code></pre>     Que pouvez-vous conclure sur la commande <code>tr</code> ?</li> </ol>"},{"location":"contenus/old-tp4/#exercice-8-trier-les-fichiers","title":"Exercice 8 : Trier les fichiers","text":"<p>Nom de base</p> <p>Le nom de base d'un fichier est le nom du fichier sans son extension. Par exemple le nom de base du fichier <code>/usr/include/stdio.h</code> est <code>stdio</code>.</p> <p>Dans cet exercice, nous voudrions afficher sur le terminal le nom de base des 10 fichiers les plus l\u00e9gers (en taille en octets) parmi les fichier <code>.h</code> du r\u00e9pertoire <code>/usr/include</code>.</p> <p>En utilisant les commandes <code>wc</code>, <code>sort</code>, <code>cut</code>, <code>head</code> (ou \u00e9ventuellement <code>tail</code>), et les redirections par tube, \u00e9crivez une commande qui affiche le nom de base des 10 fichiers les plus l\u00e9gers parmi les fichiers <code>.h</code> du r\u00e9pertoire <code>/usr/include</code>.</p> <p>Indication</p> <ul> <li>L'option <code>-c</code> de <code>wc</code> vous donne le nombre d'octets d'un fichier.</li> <li>L'option <code>-n</code> de <code>sort</code> vous permet de trier les lignes d'un fichier par ordre num\u00e9rique.</li> <li>L'option <code>-d</code> de <code>tr</code> supprime les caract\u00e8res re\u00e7us en premiers argument au lieu de les remplacer.</li> </ul> <p>Si vous avez install\u00e9 <code>gcc</code>, vous devriez avoir : <pre><code>pool\nwait\nsyslog\nsyscall\nlastlog\ntermio\nstab\nmemory\nre_comp\nalloca\n</code></pre></p>"},{"location":"contenus/old-tp4/#exercice-9-plus-sur-grep","title":"Exercice 9 : Plus sur <code>grep</code>","text":"<p>Passer un r\u00e9pertoire en argument de <code>grep</code></p> <ul> <li>L'option <code>-r</code> de <code>grep</code> permet de passer un r\u00e9pertoire en argument. Et lui demande de chercher dans tous les fichiers de ce r\u00e9pertoire.</li> <li>L'option <code>-l</code> de <code>grep</code> permet de n'afficher que le nom des fichiers qui contiennent la cha\u00eene recherch\u00e9e.</li> </ul> <p>En utilisant <code>grep</code> et \u00e9ventuellement d'autres commandes, trouvez une ligne de commande qui permet de:</p> <ol> <li>Afficher la valeur de <code>RAND_MAX</code> (c'est une constante de la librairie standard de C). </li> <li>Afficher le chemin absolu des fichiers qui contiennent de la cha\u00eene <code>127.0.0.1</code> dans les fichiers de <code>/etc</code>.</li> <li>Afficher uniquement le nom des fichiers qui contiennent de la cha\u00eene <code>127.0.0.1</code> dans les fichiers de <code>/etc</code>. (indice : il existe une commande qui s'appelle <code>rev</code>).</li> <li>Affiche le chemin du r\u00e9pertoire personnel de l'utilisateur <code>games</code>.</li> </ol>"},{"location":"contenus/old-tp5/","title":"TP5 - Processus","text":"<p>Instructions</p> <ul> <li>On rappelle que dans tous les exercices le <code>$</code> en d\u00e9but de commande repr\u00e9sente le prompt, il n'est pas \u00e0 saisir lorsque vous \u00e9crivez une ligne de commande.</li> <li>Pour chaque nouvelle commande, n'h\u00e9sitez pas \u00e0 consulter sa page de manuel avec la commande <code>man</code>, ou \u00e0 utiliser l'option <code>--help</code> (si elle est disponible) pour savoir ce qu'elle fait.</li> <li>N'h\u00e9sitez pas \u00e0 reconsulter les anciens TP pour vous aider.</li> <li>Les exercices 1, 2, 3 et 4 sont obligatoires. Le reste est optionnel, mais \u00e0 finir si vous avez le temps.</li> </ul> <p>Derni\u00e8re s\u00e9ance</p> <p>Comme il s'agit de la derni\u00e8re s\u00e9ance du module, prennez le temps de r\u00e9pondre au questionnaire d'\u00e9valuation du cours :) N'h\u00e9sitez pas \u00e0 nous faire part de ce que vous avez trouv\u00e9 de bien et de moins bien. Vos r\u00e9ponses sont anonymes et nous permettront d'am\u00e9liorer le cours pour les prochaines ann\u00e9es. Merci d'avance !</p>"},{"location":"contenus/old-tp5/#processus-et-taches","title":"Processus et t\u00e2ches","text":"<p>Processus et t\u00e2ches</p> <p>Un processus est une unit\u00e9 de travail sur un syst\u00e8me d'exploitation. Il peut s'agir d'un programme, d'un script, ou d'un service. Chaque programme que vous ex\u00e9cutez repr\u00e9sente un ou plusieurs processus. Chaque processus est identifi\u00e9 par un num\u00e9ro unique appel\u00e9 PID (Process IDentifier). </p> <p>Linux nous offre plusieurs commandes pour visualiser les processus en cours d'ex\u00e9cution.</p> <ul> <li><code>ps</code> permet d'afficher les processus en cours d'ex\u00e9cution. Par d\u00e9faut, <code>ps</code> n'affiche que les processus lanc\u00e9s par l'utilisateur courant. Pour afficher tous les processus, on utilise l'option <code>-e</code> (ou <code>-A</code>).</li> <li><code>top</code> permet d'afficher les processus en cours d'ex\u00e9cution. Il peut s'utiliser de mani\u00e8re interactive notamment les trier par utilisation du CPU. On peut quitter <code>top</code> avec la touche <code>q</code>.</li> </ul> <p>Une t\u00e2che par contre est une unit\u00e9 de travail du shell. Une t\u00e2che peut \u00eatre un processus, ou un groupe de processus mais il faut qu'il ait \u00e9t\u00e9 lanc\u00e9 par le shell. Le shell a un syst\u00e8me de contr\u00f4le de t\u00e2ches : c'est la capacit\u00e9 \u00e0 ex\u00e9cuter plusieurs commandes en m\u00eame temps. On peut lancer une commande en arri\u00e8re-plan et en avant-plan. </p> <p>La commande <code>jobs</code> permet d'afficher les t\u00e2ches en cours d'ex\u00e9cution.</p> <p>En somme</p> <p>Une t\u00e2che est un processus, mais un processus n'est pas forc\u00e9ment une t\u00e2che.</p>"},{"location":"contenus/old-tp5/#exercice-1-visualisation-des-processus","title":"Exercice 1 - Visualisation des processus","text":"<ol> <li>Testez les commandes suivantes et observez leurs r\u00e9sultats. Aidez-vous de <code>man ps</code> pour comprendre les options utilis\u00e9es.     <pre><code>$ ps\n$ ps -f\n$ ps -u\n$ ps -T\n$ ps -e\n$ ps -U root\n</code></pre></li> <li> <p>La commande <code>ps</code> retourne la liste des processus en cours d'ex\u00e9cution. Cette liste contient quatre colonnes par d\u00e9faut.</p> <p>Informations de la commande <code>ps</code></p> <ul> <li>La premi\u00e8re colonne correspond au PID (Process IDentifier) du processus.</li> <li>La deuxi\u00e8me colonne correspond au TTY (TeleTYpewriter) sur lequel le processus est lanc\u00e9. C'est le type de terminal utilis\u00e9 pour lancer le processus. Ici <code>pts/1</code> (pseudo-terminal slave) signifie que le processus a \u00e9t\u00e9 lanc\u00e9 dans un pseudo-terminal. Le chiffre renseign\u00e9 correspond au num\u00e9ro du terminal (par exemple si vous avez plusieurs instances du terminal ouverts).</li> <li>La troisi\u00e8me colonne correspond au TIME (temps) d'ex\u00e9cution du processus.</li> <li>La quatri\u00e8me colonne correspond \u00e0 la CMD (CoMmanDe) qui a lanc\u00e9 le processus.</li> </ul> </li> <li> <p>La sortie standard de la commande <code>ps</code> peut \u00eatre redirig\u00e9e. En utilisant la commande <code>grep</code> et/ou <code>wc</code> :</p> <ul> <li>Affichez le nombre de processus lanc\u00e9s par l'utilisateur courant.</li> <li>Affichez le nombre de processus lanc\u00e9s par l'utilisateur <code>root</code>.</li> <li>Affichez les nombre de processus lanc\u00e9s par l'utilisateur courant et dont la commande est <code>bash</code>.</li> </ul> </li> <li> <p>(Optionnel) La commande <code>top</code> permet d'afficher les processus en cours d'ex\u00e9cution. Une fois lanc\u00e9e, elle s'ex\u00e9cute en continu et affiche les processus en temps r\u00e9el. La touche <code>h</code> permet d'afficher l'aide et de visualiser les fonctionnalit\u00e9s disponible, la touche <code>q</code> permet de quitter <code>top</code>. Testez la commande <code>top</code>, afficher l'aide puis:</p> <ul> <li>Filtrer les processus en cours d'ex\u00e9cution pour n'afficher que ceux lanc\u00e9s par l'utilisateur courant.</li> <li>Filtrer les processus en cours d'ex\u00e9cution pour n'afficher que ceux lanc\u00e9s par l'utilisateur <code>root</code>.</li> <li>Filtrer les processus en cours d'ex\u00e9cution pour n'afficher que ceux dont la commande est <code>bash</code>.</li> </ul> </li> </ol>"},{"location":"contenus/old-tp5/#exercice-2-processus-et-taches","title":"Exercice 2 - Processus et t\u00e2ches","text":"<ol> <li>Dans cet exercice nous allons simuler l'ex\u00e9cution d'un processus long. Pour cela, nous allons utiliser la commande <code>sleep</code> qui permet de mettre en pause l'ex\u00e9cution d'un script pendant un certain temps. Tapez la commande <code>sleep 10</code> et observez ce qu'il se passe.</li> <li> <p>Ensuite testez les commandes suivantes et commentez les r\u00e9sultats:     <pre><code>$ ps\n$ sleep 240\n$ C-z # Control + z\n$ ps\n$ fg %1 # fg %&lt;num\u00e9ro de la t\u00e2che&gt;\n$ C-c # Control + c\n$ ps\n</code></pre></p> <ul> <li>\u00c0 votre avis que fait le raccourci clavier <code>C-z</code> ? et le raccourci clavier <code>C-c</code> ?</li> <li>Refaites les commandes en tapant des commandes (ou tout autre chose dans le terminal) entre le <code>sleep 240</code> et le <code>C-z</code>. Que remarquez-vous ?</li> <li>Sans passer par <code>help fg</code>, pouvez-vous deviner ce que fait la commande <code>fg %1</code> ? et la commande <code>fg</code> de mani\u00e8re g\u00e9n\u00e9rale ?</li> <li>Refaites les commandes en notant \u00e0 chaque fois le PID du processus <code>sleep 240</code> dans les sorties de <code>ps</code>. Que remarquez-vous ?</li> </ul> </li> <li> <p>Cr\u00e9er un ficher <code>gros_processus</code> dont le contenu est le suivant:     <pre><code>#!/bin/bash\nsleep 120\necho 'Termin\u00e9'\n</code></pre></p> </li> <li>Modifier les droits du fichier <code>gros_processus</code> pour qu'il soit ex\u00e9cutable. Puis ex\u00e9cutez les commandes suivantes et observez attentivement les r\u00e9sultats:     <pre><code>$ ./gros_processus 1\n$ C-z\n$ ./gros_processus 2 &amp;\n$ jobs\n$ jobs -p\n$ ps\n$ fg %1\n$ C-z\n$ bg %1\n$ jobs\n$ fg %2\n$ C-z\n$ bg %2 # puis attendre que les processus se terminent\n$ jobs\n</code></pre><ul> <li>Quels proc\u00e9d\u00e9s permettent de placer un processus en arri\u00e8re-plan ? et en avant-plan ?</li> <li>Quelle diff\u00e9rence remarquez-vous entre <code>./gros_processus 1</code> puis <code>C-z</code> et directement <code>./gros_processus 2 &amp;</code> ? (\u00c0 part 1 et 2 bien-s\u00fbr) ?</li> <li>\u00c0 quoi sert l'option <code>-p</code> de la commande <code>jobs</code> ?</li> <li>Sans passer par <code>help bg</code>, pouvez-vous deviner ce que fait les commandes <code>bg %1</code> et <code>bg %2</code>? et la commande <code>bg</code> de mani\u00e8re g\u00e9n\u00e9rale ?</li> <li>Quels sont les diff\u00e9rents \u00e9tats des t\u00e2ches que vous avez observ\u00e9 ?</li> </ul> </li> </ol>"},{"location":"contenus/old-tp5/#envoyer-des-signaux-a-un-processus","title":"Envoyer des signaux \u00e0 un processus","text":"<p>Communiquer avec les processus</p> <p>Lorsque des processus ont \u00e9t\u00e9 lanc\u00e9s, nous avons remarqu\u00e9 qu'ils peuvent \u00eatre arr\u00eates, red\u00e9marr\u00e9s et tu\u00e9s. Pour cela, nous avons utilis\u00e9 les commandes <code>C-z</code>, <code>C-c</code>, <code>fg</code> et <code>bg</code>. Ces commandes permettent de communiquer avec les processus en cours d'ex\u00e9cution. En r\u00e9alit\u00e9, ces derni\u00e8res envoient ce qu'on appelle des signaux aux processus. Un signal est un message envoy\u00e9 \u00e0 un processus pour lui demander de faire quelque chose. </p> <p>La commande qui permet d'envoyer des signaux \u00e0 un processus est <code>kill</code>. Cette commande n\u00e9cessite le PID du processus \u00e0 qui envoyer le signal (ou son num\u00e9ro de t\u00e2che si c'en est une). Ainsi <code>C-z</code>, <code>C-c</code>, <code>fg</code> et <code>bg</code> font donc appel \u00e0 la commande <code>kill</code> pour envoyer des signaux aux processus.</p> <p>Il existe plusieurs signaux, les plus courants sont les suivants:</p> <ul> <li><code>SIGINT</code> : signal envoy\u00e9 par la combinaison de touches <code>C-c</code>. Il demande au processus de s'arr\u00eater.</li> <li><code>SIGTSTP</code> : signal envoy\u00e9 par la combinaison de touches <code>C-z</code>. Il demande au processus de se mettre en pause.</li> <li><code>SIGCONT</code> : signal envoy\u00e9 par les commandes <code>bg</code> et <code>fg</code>. Il demande au processus de reprendre son ex\u00e9cution.</li> <li><code>SIGTERM</code> : signal envoy\u00e9 par la commande <code>kill</code> par d\u00e9faut. Il demande au processus de s'arr\u00eater.</li> <li><code>SIGKILL</code> : Il demande au processus de s'arr\u00eater imm\u00e9diatement et provoque son arr\u00eat brutal, comprenez par l\u00e0 que le processus n'a pas le temps de se terminer correctement. Il est donc d\u00e9conseill\u00e9 d'utiliser ce signal.</li> </ul> <p>La liste exhaustive des signaux est disponible est obtenu avec commande <code>kill -L</code>.</p> <p>Qui a le droit d'envoyer des signaux \u00e0 un processus ?</p> <p>Pour pouvoir affecter un processus, vous devez biensur en \u00eatre le prorpi\u00e9taire ou \u00eatre root.</p>"},{"location":"contenus/old-tp5/#exercice-3-la-commande-kill","title":"Exercice 3 - La commande <code>kill</code>","text":"<ol> <li>Tapez la commande <code>kill -L</code> et notez les num\u00e9ros associ\u00e9s aux signaux <code>SIGINT</code>, <code>SIGTSTP</code>, <code>SIGCONT</code>, <code>SIGTERM</code> et <code>SIGKILL</code>.</li> <li>Reprenez ensuite le script <code>gros_processus</code> de l'exercice pr\u00e9c\u00e9dent et testez les commandes suivantes. Et commentez les r\u00e9sultats. <pre><code>$ ./gros_processus 1 &amp; # ce sera notre processus 1\n$ ./gros_processus 2 &amp; # ce sera notre processus 2\n$ ./gros_processus 3 &amp; # ce sera notre processus 3\n$ jobs -p # notez les PID des processus, mais ils ont d\u00fb \u00eatre affich\u00e9s \u00e0 l'\u00e9cran lors de leur lancement\n$ kill -SIGTSTP &lt;PID du processus 1&gt;\n$ jobs\n$ kill -SIGINT %2\n$ jobs\n$ jobs # oui une deuxi\u00e8me fois\n$ kill -SIGCONT %1\n$ jobs\n$ kill -s SIGTERM &lt;PID processus 1&gt;\n$ jobs\n$ kill -9 &lt;PID du processus 3&gt;\n$ jobs\n$ jobs # pour voir dispara\u00eetre la t\u00e2che [3]\n</code></pre></li> <li>Selon vous quel est la diff\u00e9rence entre <code>SIGINT</code> et <code>SIGTSTP</code> ? et entre <code>SIGTSTP</code> et <code>SIGTERM</code> ?</li> <li>D'apr\u00e8s vos observations sur les r\u00e9sultats de la question 2, de combien de mani\u00e8re diff\u00e9rente peut-on utiliser la commande <code>kill</code> pour arriver au m\u00eame r\u00e9sultat ?</li> </ol>"},{"location":"contenus/old-tp5/#autres-commandes","title":"Autres commandes","text":""},{"location":"contenus/old-tp5/#exercice-4-archiver-des-fichiers-et-extraire-des-archives","title":"Exercice 4 - Archiver des fichiers et extraire des archives","text":"<p>Compression de fichiers et archivage</p> <p>Archiver un ensemble de fichiers consiste \u00e0 les regrouper dans un seul fichier. Cela permet de les stocker ou de les transf\u00e9rer plus facilement. Tandis que compresser un fichier consiste \u00e0 r\u00e9duire sa taille en supprimant les informations redondantes. Cela permet de gagner de l'espace de stockage et \u00e9ventuellement de r\u00e9duire le temps de transfert.</p> <p>Ces deux proc\u00e9d\u00e9s vont souvent de paire. En effet, on va souvent compresser un fichier avant de l'archiver. Il existe plusieurs outils pour compresser et archiver des fichiers.</p> <ul> <li><code>gzip</code> (GNU zip): permet de compresser un fichier et dont les fichiers ont l'extension <code>.gz</code>.</li> <li><code>bzip2</code> (block-sorting zip): permet de compresser un fichier et dont les fichiers ont l'extension <code>.bz2</code>.</li> <li><code>zip</code>: permet de compresser et d'archiver un ensemble de fichiers et dont les fichiers ont l'extension <code>.zip</code> (format standard des archives Windows)</li> <li><code>tar</code> (tape archive): permet d'archiver un ensemble de fichiers et dont les fichiers ont l'extension <code>.tar</code>.</li> </ul> <p>On d\u00e9compresse ensuite un fichier en fonction de son format de compr\u00e9ssion et d'archivage. </p> <ul> <li><code>gunzip</code> : permet de d\u00e9compresser un fichier compress\u00e9 avec <code>gzip</code>.</li> <li><code>bunzip2</code> : permet de d\u00e9compresser un fichier compress\u00e9 avec <code>bzip2</code>.</li> <li><code>unzip</code> : permet de d\u00e9compresser et d'extraire un fichier archiv\u00e9 avec <code>zip</code>.</li> </ul> <p>Remarque</p> <p><code>tar</code> permet \u00e0 la fois la compression et l'archivage</p> <ul> <li>L'option <code>-c</code> de <code>tar</code> permet de cr\u00e9er une archive.</li> <li>L'option <code>-x</code> de <code>tar</code> permet d'extraire une archive.</li> <li>L'option <code>-f</code> de <code>tar</code> permet de sp\u00e9cifier le nom de l'archive.</li> </ul> <ol> <li>Dans un r\u00e9pertoire <code>dir</code> cr\u00e9er l'arborescence suivante : <pre><code>dir\n\u251c\u2500\u2500 files\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 file-a.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 file-b.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 file-c.md\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 file-d.md\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 file-e.md\n\u2514\u2500\u2500 imgs\n    \u251c\u2500\u2500 img001.png\n    \u251c\u2500\u2500 img002.png\n    \u251c\u2500\u2500 img003.png\n    \u251c\u2500\u2500 img004.png\n    \u2514\u2500\u2500 img005.png\n</code></pre></li> <li>On se place dans le r\u00e9pertoire <code>dir</code>. Tapez ensuite la commande suivante pour cr\u00e9er une archive <code>files.tar</code> contenant les fichiers du r\u00e9pertoire <code>files</code>: <pre><code>$ tar -cvf files.tar files\n</code></pre>     Listez ensuite les fichiers de <code>dir</code>.</li> <li>Toujours dans <code>dir</code>. Tapez la commande suivante pour cr\u00e9er une archive <code>imgs.tar</code> contenant les images du r\u00e9pertoire <code>imgs</code>: <pre><code>$ tar -cf imgs.tar imgs\n</code></pre>     Listez ensuite les fichiers de <code>dir</code>.</li> <li>Que pouvez vous dire sur l'option <code>-v</code> de <code>tar</code> ?</li> <li>D\u00e9placer vous ensuite dans le r\u00e9pertoire parent de <code>dir</code> et tapez les commandes suivantes: <pre><code>$ tar -czvf dir.tar.gz dir\n$ ls\n$ gunzip dir.tar.gz\n$ ls\n$ tar -xvf dir.tar\n</code></pre><ul> <li>Apr\u00e8s la commande <code>gunzip</code>, qu'est devenu le fichier <code>dir.tar.gz</code> ?</li> <li>Selon vous \u00e0 quoi sert l'option <code>-z</code> de tar ?</li> </ul> </li> </ol>"},{"location":"contenus/old-tp5/#exercice-5-un-apercu-de-vim","title":"Exercice 5 - Un aper\u00e7u de <code>vim</code>","text":"<p>Un \u00e9diteur de texte dans la console</p> <p><code>vim</code>  est un \u00e9diteur de texte en mode console. Il permet de cr\u00e9er, modifier et visualiser des fichiers textes. Il est tr\u00e8s puissant et tr\u00e8s utilis\u00e9 par les d\u00e9veloppeurs. Il est tr\u00e8s complet et poss\u00e8de de nombreuses fonctionnalit\u00e9s. Il est donc assez difficile de le ma\u00eetriser. Nous allons voir quelques commandes de base pour pouvoir l'utiliser.</p> <p>Dans <code>vim</code> il existe plusieurs modes (il est renseign\u00e9 en bas \u00e0 gauche de la fen\u00eatre):</p> <ul> <li>Le mode normal : c'est le mode par d\u00e9faut. Il permet de naviguer dans le fichier, de copier, coller, supprimer, etc.</li> <li>Le mode insertion : il permet d'ins\u00e9rer du texte dans le fichier.</li> <li>Le mode commande : il permet d'entrer des commandes pour effectuer des actions sur le fichier.</li> </ul> <p>De mani\u00e8re g\u00e9n\u00e9rale, pour revenir dans le mode normal il faut appuyer sur la touche <code>ESC</code>.</p> <ul> <li>Pour passer du mode normal au mode insertion il faut appuyer sur la touche <code>i</code>.  </li> <li>Pour passer du mode normal au mode commande il faut appuyer sur la touche <code>:</code>. </li> </ul> <p>En mode commande, nous allons voir ensemble quelques commandes de base:</p> <ul> <li><code>:q</code> : quitter <code>vim</code>.</li> <li><code>:w</code> : enregistrer le fichier.</li> <li><code>:wq</code> : enregistrer le fichier et quitter <code>vim</code>.</li> <li><code>:q!</code> : quitter <code>vim</code> sans enregistrer le fichier.</li> </ul> <p>Si vous voulez en apprendre plus, vous pouvez faire un tour ici et ici.</p> <ol> <li>Tapez la commande <code>vim hellovim</code> pour cr\u00e9er un fichier <code>hellovim</code> avec <code>vim</code>.</li> <li>Une fois dans l'\u00e9diteur, passer en mode insertion en tapant sur la touche <code>i</code>. Puis \u00e9crivez le texte suivant:     <pre><code>Hello vim !\n</code></pre></li> <li>Revenez en mode normal en appuyant sur la touche <code>ESC</code>. Puis enregistrez le fichier en tapant <code>:w</code> et quittez <code>vim</code> en tapant <code>:q</code>.</li> <li>Affichez ensuite le contenu de <code>hellovim</code> avec la commande <code>cat</code>.</li> </ol>"},{"location":"contenus/old-tp5/#exercice-6-compiler-et-executer-un-programme-c","title":"Exercice 6 - Compiler et ex\u00e9cuter un programme C","text":"<p>Le compilateur C de Linux</p> <p><code>gcc</code> est le compilateur C de Linux. Il permet de compiler du code C. Il est tr\u00e8s utilis\u00e9 par les d\u00e9veloppeurs. Il est tr\u00e8s complet et poss\u00e8de de nombreuses fonctionnalit\u00e9s. Nous allons voir un aper\u00e7u de son utilisation.</p> <p>La compilation d'un programme en C passe par plusieurs \u00e9tapes, qui sont essentiellement les suivantes:</p> <ul> <li>La pr\u00e9compilation : elle permet de transformer le code source en un code interm\u00e9diaire.</li> <li>La compilation : elle permet de transformer le code interm\u00e9diaire en code machine.</li> <li>L'\u00e9dition des liens : elle permet de lier le code machine avec les biblioth\u00e8ques utilis\u00e9es.</li> <li>La cr\u00e9ation de l'ex\u00e9cutable : elle permet de cr\u00e9er l'ex\u00e9cutable.</li> </ul> <ol> <li>Cr\u00e9er un fichier <code>hello.c</code> dont le contenu est le suivant:     <pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(\"Hello world !\\n\");\n    return 0;\n}\n</code></pre></li> <li> <p>Placez-vous ensuite dans le r\u00e9pertoire contenant votre fichier <code>hello.c</code> et tapez la commande <code>gcc hello.c</code>. Cette commande va compiler votre programme et cr\u00e9er un fichier <code>a.out</code> qui est l'ex\u00e9cutable de votre programme. Tapez enfin la commande <code>./a.out</code> pour ex\u00e9cuter votre programme.</p> <p>Attention</p> <ul> <li>Si vous avez d\u00e9j\u00e0 un fichier <code>a.out</code> dans votre r\u00e9pertoire, il sera \u00e9cras\u00e9 par la commande <code>gcc hello.c</code>.</li> <li><code>a.out</code> est le nom par d\u00e9faut de l'ex\u00e9cutable cr\u00e9\u00e9 par <code>gcc</code>. Vous pouvez changer ce nom en utilisant l'option <code>-o</code> de <code>gcc</code>. Par exemple, <code>gcc hello.c -o hello</code> va cr\u00e9er un ex\u00e9cutable <code>hello</code> au lieu de <code>a.out</code>.</li> </ul> </li> <li> <p>R\u00e9cup\u00e9rez ensuite cette archive hello.tar.gz.</p> </li> <li>Extraire les fichiers de cet archive et d\u00e9placez vos dans le r\u00e9pertoire <code>hello</code>.</li> <li>Tapez la commande  <pre><code>$ gcc main.c hello.c -o run\n</code></pre> pour compiler votre programme. Cette commande va compiler votre programme et cr\u00e9er un fichier <code>run</code> qui est l'ex\u00e9cutable de votre programme. Ex\u00e9cutez enfin votre programme avec la commande <code>./run</code>. </li> <li>Supprimer le fichier <code>run</code> et modifier ensuite le fichier <code>hello.c</code> de tel sorte \u00e0 avoir volontairement une erreur : supprimer l'accolade fermante de la fonction <code>void hello()</code>. R\u00e9ex\u00e9cutez ensuite les commandes de la question 5. Que remarquez-vous ?</li> <li>Remodifier ensuite le fichier <code>hello.c</code> en remettant l'accolade fermante mais rajouter un <code>return 1</code> dans la d\u00e9finition de la fonction (avant l'accolade fermante). R\u00e9ex\u00e9cutez ensuite les commandes de la question 5. Que remarquez-vous ?</li> <li>Conclure sur la gestion des erreurs et des warnings sur <code>gcc</code>.</li> </ol>"},{"location":"contenus/old-tp5/#exercice-7-la-commande-trap","title":"Exercice 7 - La commande <code>trap</code>","text":"<p>Intercepter les signaux</p> <p>La commande <code>trap</code> permet d'intercepter les signaux envoy\u00e9s \u00e0 un processus. Elle permet donc de d\u00e9finir des actions \u00e0 effectuer lorsqu'un signal est envoy\u00e9 \u00e0 un processus. Sa syntaxe est la suivante: <pre><code>trap 'commande1;commande2;...' signal1 signal2 ...\n</code></pre> Ici <code>commande1;commande2;...</code> est la lite des actions \u00e0 effectuer \u00e0 la r\u00e9ception du ou des signaux de la liste <code>signal1 signal2 ...</code>.</p> <p>\u00c0 la r\u00e9ception d'un <code>SIGINT</code>, par exemple, on voudrait terminer proprement notre processus. On peut dans ce cas d\u00e9sallouer toutes les ressources avant de terminer notre processus. (\u00c7a s'appelle un graceful shutdown).</p> <ol> <li>Cr\u00e9er un fichier <code>graceful_shutdown</code> dont le contenu est le suivant: <pre><code>#!/bin/bash\n\nfunction cmd1()\n{\n    echo\n    echo \"Ok, c'est bon je m'arr\u00eate...\" \n} \n\nfunction cmd2()\n{\n    echo\n    echo \"...mais dans la gr\u00e2ce\" \n}\n\ntrap 'cmd1;cmd2;exit' SIGINT SIGTERM\n\nwhile true\ndo\n    echo \"Personne ne peut m'arr\u00eater\"\n    sleep 10\ndone\n</code></pre></li> <li>Fa\u00eetes en sorte que le fichier <code>graceful_shutdown</code> soit ex\u00e9cutable puis ex\u00e9cutez-le.</li> <li>Tapez ensuite les commandes suivantes et commentez les r\u00e9sultats: <pre><code>$ ./graceful_shutdown\n$ C-c\n</code></pre></li> <li>\u00c0 votre avis, que fait la commande <code>exit</code> ?</li> <li>Relancez le script <code>graceful_shutdown</code> mais cette fois-ci en arri\u00e8re-plan. Puis tapez les commandes suivantes et commentez les r\u00e9sultats: <pre><code>$ ./graceful_shutdown &amp;\n$ C-c\n</code></pre><ul> <li>Que remarquez-vous ? D\u00e8s que vous avez la main sur le terminal envoyer un <code>SIGTERM</code> au processus <code>graceful_shutdown</code>.</li> <li>Quelle conclusion pouvez-vous tirer sur <code>C-c</code> et les processus en arri\u00e8re plan ?</li> </ul> </li> </ol>"},{"location":"contenus/preliminary-reading/","title":"Lecture pr\u00e9liminaire","text":"<p>Dans ce cours d'introduction, nous allons apprendre \u00e0 utiliser le syst\u00e8me d'exploitation Linux \u00e0 travers la distribution Debian. Nous apprendrons \u00e0 utiliser l'interface en ligne de commande (CLI) et \u00e0 utiliser le shell pour interagir avec le syst\u00e8me d'exploitation. Nous apprendrons \u00e9galement \u00e0 utiliser le shell pour \u00e9crire des scripts et automatiser des t\u00e2ches.</p> <p>Cette premi\u00e8re lecture pr\u00e9liminaire permet de comprendre la gen\u00e8se de Linux et de saisir la philosophie qui se cache derri\u00e8re ce syst\u00e8me d'exploitation. Elle permet \u00e9galement de comprendre pourquoi il est si populaire, m\u00eame si vous n'en avez jamais entendu parler auparavant. Oui, vous ne le savez peut-\u00eatre pas, mais vous l'utilisez d\u00e9j\u00e0 tous les jours. Une d\u00e9finition d'un shell est \u00e9galement fournie.</p>"},{"location":"contenus/preliminary-reading/#quest-ce-quun-systeme-dexploitation","title":"Qu'est-ce qu'un syst\u00e8me d'exploitation ?","text":"<p>Selon Wikip\u00e9dia, l'encyclop\u00e9die libre, un syst\u00e8me d'exploitation (SE) est un logiciel qui g\u00e8re les ressources mat\u00e9rielles et logicielles de l'ordinateur et fournit des services communs pour les programmes informatiques.</p> <p>Il re\u00e7oit des demandes d'utilisation des ressources de l'ordinateur - ressources de stockage de la m\u00e9moire (par exemple, acc\u00e8s \u00e0 la RAM, disques durs), ressources de calcul du processeur central, ressources de communication vers les p\u00e9riph\u00e9riques (par exemple, pour demander des ressources de calcul du GPU ou de toute autre carte d'extension) ou via le r\u00e9seau - \u00e0 partir du logiciel d'application. Le syst\u00e8me d'exploitation g\u00e8re ces demandes et les ressources n\u00e9cessaires pour \u00e9viter les interf\u00e9rences entre les applications logicielles.</p>"},{"location":"contenus/preliminary-reading/#quest-ce-quunix","title":"Qu'est-ce qu'UNIX ?","text":"<p>UNIX est un syst\u00e8me d'exploitation (SE) d\u00e9velopp\u00e9 \u00e0 l'origine par Ken Thompson chez Bell Labs, la l\u00e9gendaire branche de recherche d'AT&amp;T (l'ancien monopole am\u00e9ricain des t\u00e9l\u00e9communications) en 1969 et a \u00e9t\u00e9 consid\u00e9rablement am\u00e9lior\u00e9 \u00e0 l'Universit\u00e9 de Californie \u00e0 Berkeley (UCB) au cours des ann\u00e9es 1970 et 1980. De nombreuses variations ont ensuite \u00e9t\u00e9 d\u00e9velopp\u00e9es, et elles sont collectivement appel\u00e9es syst\u00e8mes d'exploitation de type Unix ou bas\u00e9s sur Unix. Les syst\u00e8mes d'exploitation bas\u00e9s sur Unix sont largement consid\u00e9r\u00e9s comme les meilleurs syst\u00e8mes d'exploitation jamais cr\u00e9\u00e9s en termes de plusieurs crit\u00e8res, notamment la stabilit\u00e9, la s\u00e9curit\u00e9, la flexibilit\u00e9, la scalabilit\u00e9 et l'\u00e9l\u00e9gance.</p>"},{"location":"contenus/preliminary-reading/#quest-ce-que-linux-et-gnulinux","title":"Qu'est ce que Linux et GNU/Linux ?","text":"<p>Linux est un syst\u00e8me d'exploitation (SE) gratuit et performant similaire \u00e0 UNIX. Linus Torvalds a commenc\u00e9 Linux (une concat\u00e9nation de Linus et UNIX) en 1991, dans le but de cr\u00e9er une alternative UNIX gratuite en raison de son insatisfaction \u00e0 l'\u00e9gard de MS-DOS. Il est rapidement devenu un projet mondial, attirant des d\u00e9veloppeurs du monde entier <sup>1</sup>, ce qui a conduit \u00e0 des am\u00e9liorations continues des performances et \u00e0 une adoption g\u00e9n\u00e9ralis\u00e9e par les particuliers, les entreprises, les \u00e9tablissements d'enseignement et les gouvernements.</p> <p>La sup\u00e9riorit\u00e9 de Linux par rapport aux autres syst\u00e8mes de type Unix r\u00e9side dans le fait qu'il est compl\u00e8tement gratuit, \u00e0 la fois sur le plan mon\u00e9taire et en termes de droits d'utilisation. Cette libert\u00e9 est rendue possible par la licence publique g\u00e9n\u00e9rale GNU (GPL), associ\u00e9e au projet GNU lanc\u00e9 par Richard Stallman en 1983, qui fournit des programmes utilitaires essentiels pour Linux, d'o\u00f9 le nom GNU/Linux.</p> <p>Compar\u00e9 \u00e0 Microsoft Windows, le syst\u00e8me d'exploitation le plus utilis\u00e9, Linux offre plusieurs avantages : (1) \u00eatre gratuit, (2) une grande stabilit\u00e9 avec moins de plantages, (3) une forte r\u00e9sistance aux virus et aux logiciels malveillants, (4) la disponibilit\u00e9 de nombreux logiciels gratuits de haute qualit\u00e9, et (5) la compatibilit\u00e9 avec les anciens ordinateurs incapables de prendre en charge les nouvelles versions de Windows. Pour une liste plus compl\u00e8te des avantages, l'article \"25 Reasons to Convert to Linux\" peut fournir d'autres informations.</p>"},{"location":"contenus/preliminary-reading/#quest-ce-quune-distribution-linux","title":"Qu'est-ce qu'une distribution Linux ?","text":"<p>Une distribution est un syst\u00e8me d'exploitation complet compos\u00e9 d'un noyau (c'est-\u00e0-dire le c\u0153ur d'un syst\u00e8me d'exploitation) et d'utilitaires (dont certains sont \u00e9galement n\u00e9cessaires au fonctionnement du syst\u00e8me d'exploitation) ainsi que d'une vari\u00e9t\u00e9 de programmes d'application.</p> <p>Il existe une centaine de distributions de Linux disponibles actuellement. Elles sont livr\u00e9es avec diverses saveurs, de la plus conviviale pour les d\u00e9butants complets \u00e0 la plus avanc\u00e9e pour les experts. Les plus populaires d'entre elles sont Ubuntu, Fedora, Debian.</p> <p>La plupart de ces distributions sont disponibles (1) en anglais, (2) pour les processeurs compatibles Intel (x86) et (3) en t\u00e9l\u00e9chargement gratuit sur Internet. Elles sont \u00e9galement disponibles (4) dans d'autres langues et (5) pour d'autres types de processeurs.</p> <p>Dans ce module nous allons commencer notre d\u00e9couverte Linux avec Debian.</p>"},{"location":"contenus/preliminary-reading/#quest-ce-que-debian","title":"Qu'est-ce que Debian","text":"<p>Debian est un syst\u00e8me d'exploitation (SE) gratuit bas\u00e9 sur un noyau de type UNIX (Linux ou FreeBSD) qui peut \u00eatre t\u00e9l\u00e9charg\u00e9 ici. Vous pouvez trouver plus d'informations sur Debian ici.</p>"},{"location":"contenus/preliminary-reading/#historique-du-developpement-dunix-et-de-linux","title":"Historique du d\u00e9veloppement d'UNIX et de Linux","text":"<ul> <li>1969: Ken Thompson d\u00e9veloppe la premi\u00e8re version d'UNIX chez Bell Labs.</li> <li>1973: UNIX est r\u00e9\u00e9crit dans le langage de programmation C, ce qui augmente consid\u00e9rablement sa portabilit\u00e9.</li> <li>1983: Richard Stallman lance le projet GNU pour cr\u00e9er un syst\u00e8me d'exploitation de type UNIX gratuit fournissant de nombreux utilitaires.</li> <li>1985: La Free Software Foundation est fond\u00e9e pour soutenir le projet GNU.</li> <li>1987: Andrew Tanenbaum d\u00e9veloppe MINIX, un syst\u00e8me d'exploitation de type UNIX gratuit \u00e0 des fins \u00e9ducatives.</li> <li>1991: Linus Torvalds lance Linux comme projet de loisir.</li> <li>1992: Linux est re-licenci\u00e9 sous la GNU GPL.</li> <li>1993: Le projet Debian est fond\u00e9 pour cr\u00e9er un syst\u00e8me d'exploitation de type UNIX gratuit.</li> </ul>"},{"location":"contenus/preliminary-reading/#unix-aujourdhui","title":"UNIX aujourd'hui","text":"<ul> <li>Gnu/Linux noyau Linux + utilitaires GNU, \u00e9quipe la plupart des serveurs et supercalculateurs, et est de plus en plus utilis\u00e9 sur les ordinateurs de bureau et portables (1% \u00e0 2%).</li> <li>Android noyau Linux + utilitaires Android, \u00e9quipe la plupart des smartphones et tablettes (80%).</li> <li>FreeBSD OS de type UNIX, \u00e9quipe la plupart des ordinateurs Apple Macintosh (10%), et l'OS de Playstation 3 et 4.</li> <li>iOS et MacOS OS de type UNIX, \u00e9quipe les iPhones et iPads et les Macs d'Apple.</li> </ul>"},{"location":"contenus/preliminary-reading/#mais-le-shell-dans-tout-ca","title":"Mais le shell dans tout \u00e7a ?","text":"<p>Nous avons vu qu'un SE g\u00e8re les demandes d'utilisation des ressources de l'ordinateur. Ces demandes sont faites \u00e0 travers une interface utilisateur. Il existe deux types d'interfaces utilisateur : (1) les interfaces utilisateur graphiques (GUI) et (2) les interfaces utilisateur en ligne de commande (CLI).</p> <p>Un shell est un programme qui fournit l'interface utilisateur traditionnelle, uniquement textuelle, pour les syst\u00e8mes d'exploitation de type Unix. Sa fonction principale est de lire les commandes (c'est-\u00e0-dire les instructions) qui sont saisies dans une console (c'est-\u00e0-dire un mode d'affichage tout texte) ou une fen\u00eatre de terminal (c'est-\u00e0-dire un mode d'affichage graphique), puis de les ex\u00e9cuter.</p> <p>Dans ce module nous allons utiliser le shell Bash. Bash est le shell du projet GNU. Bash est le Bourne Again SHell. Bash est un shell compatible sh qui int\u00e8gre des fonctionnalit\u00e9s utiles du shell Korn (ksh) et du shell C (csh). Il est destin\u00e9 \u00e0 se conformer \u00e0 la norme IEEE POSIX P1003.2/ISO 9945.2 Shell and Tools. Il offre des am\u00e9liorations fonctionnelles par rapport \u00e0 sh pour la programmation et l'utilisation interactive. De plus, la plupart des scripts sh peuvent \u00eatre ex\u00e9cut\u00e9s par Bash sans modification.</p> <ol> <li> <p>Plus tard, Linus Torvalds inventera Git pour g\u00e9rer le d\u00e9veloppement du noyau Linux, car son d\u00e9veloppement s'est r\u00e9pandu dans le monde entier.\u00a0\u21a9</p> </li> </ol>"},{"location":"contenus/tp1/","title":"TP1 - Premi\u00e8res commandes","text":"<p>Objectifs p\u00e9dagogiques</p> <p>\u00c0 l\u2019issue de ce TP, l\u2019\u00e9tudiant sera capable de :</p> <ul> <li>Se rep\u00e9rer dans l\u2019arborescence du syst\u00e8me de fichiers Linux</li> <li>Comprendre et utiliser les commandes de base du shell (naviguer, cr\u00e9er, d\u00e9placer, supprimer)</li> <li>Utiliser les raccourcis clavier essentiels du terminal</li> <li>Comprendre la distinction entre commandes internes et externes</li> <li>Consulter l\u2019aide en ligne (man, help) et lire un synopsis de commande</li> <li>Comprendre la diff\u00e9rence entre chemins absolus et relatifs</li> <li>Manipuler les r\u00e9pertoires et les fichiers en ligne de commande</li> <li>Utiliser les caract\u00e8res jokers (wildcards) pour rechercher ou manipuler des fichiers</li> <li>Appliquer la compl\u00e9tion automatique et les raccourcis utiles pour gagner en efficacit\u00e9</li> </ul> <p>Instructions</p> <ul> <li>Dans tous les exercices, la cha\u00eene <code>$</code> au d\u00e9but de la ligne repr\u00e9sente l'invite de commande et ne doit pas \u00eatre saisie.</li> <li>Pour l'instant, \u00e0 chaque fois que vous ouvrez un terminal, vous \u00eates invit\u00e9 \u00e0 saisir la commande suivante, (suivie, comme toujours, de la touche entr\u00e9e), pour des raisons p\u00e9dagogiques :</li> </ul> <pre><code>$ PS1='$ '\n</code></pre> <p>\u00c0 propos des r\u00e9ponses du TP</p> <p>Avant de commencer le TP, vous devez cr\u00e9er un fichier nomm\u00e9 <code>resultat_commande_TP1_NomPrenomEtudiant.txt</code>. Dans ce fichier, vous consignerez progressivement les r\u00e9sultats des commandes ex\u00e9cut\u00e9es au fil des exercices.  </p> <p>Cr\u00e9ation du fichier</p> <ol> <li>Clic droit dans votre r\u00e9pertoire de travail  </li> <li>Cr\u00e9er un document \u2192 Fichier vide </li> <li>Nommer le fichier : <code>resultat_commande_TP1_NomPrenomEtudiant</code> </li> </ol> <p>Notez bien : </p> <p> Votre enseignant doit pouvoir consulter ce fichier \u00e0 tout moment afin d\u2019\u00e9valuer votre progression. </p> <p>Bar\u00e8me d\u2019interpr\u00e9tation des exercices</p> <p>\ud83d\udcda = Facile, \ud83d\udcda\ud83d\udcda = Moyenne, \ud83d\udcda\ud83d\udcda\ud83d\udcda = \u00c9lev\u00e9e </p>"},{"location":"contenus/tp1/#exercice-1-premieres-commandes","title":"Exercice 1 : Premi\u00e8res commandes \ud83d\udcda","text":"<p>Qu'est-ce qu'une commande ?</p> <p>Une commande est une s\u00e9quence de mots se terminant par un caract\u00e8re de nouvelle ligne. Autrement dit, une commande est une s\u00e9quence de caract\u00e8res qui se termine par la touche \u23ce Entr\u00e9e. Le premier mot est le nom de la commande, les autres sont ses arguments. La commande est ex\u00e9cut\u00e9e par le shell, qui est un programme qui interpr\u00e8te la ligne de commande.</p> <p><pre><code>$ touch file.txt\n</code></pre> Ici la commande est <code>touch</code> et son argument est <code>file.txt</code>. Le signe <code>$</code> au d\u00e9but de la ligne est l'invite de commande. Il ne fait pas partie de la commande.</p> <p>Chaque mot de la ligne de commande est s\u00e9par\u00e9 par un ou plusieurs espaces. Le shell interpr\u00e8te les espaces comme des s\u00e9parateurs entre les mots. Le shell interpr\u00e8te le caract\u00e8re de nouvelle ligne comme la fin de la commande.</p> <ol> <li>Essayez les commandes suivantes dans un terminal. D\u00e9crivez en une phrase son utilit\u00e9, indiquez le nom de la commande, son nombre d'arguments et ses arguments. Par exemple, la premi\u00e8re commande est <code>date</code>, elle n'a pas d'argument et son utilit\u00e9 est d'afficher la date et l'heure. <pre><code>$ date\n$ cal\n$ cal 3 2022\n$ who\n$ who am i\n$   who  am   i\n$ uname\n$ uname -m -r\n$ uname -mrs\n$ echo Hello, world!\n$ echo       Hello,        world!\n</code></pre></li> <li>Appuyez sur la touche \u2191 (fl\u00e8che vers le haut) de votre clavier, ou bien Ctrl + P (Ctrl et P en m\u00eame temps), plusieurs fois jusqu'\u00e0 ce que la commande <code>who</code> s'affiche. Appuyez maintenant sur la touche \u2193 (fl\u00e8che vers le bas) ou bien tapez Ctrl + N jusqu'\u00e0 ce que la commande <code>uname -m -r</code> s'affiche puis appuyez sur la touche entr\u00e9e. Notez \u00e0 quoi servent ces raccourcis et apprenez-les.</li> <li>Appuyez sur Ctrl + L. Notez \u00e0 quoi sert ce raccourci et apprenez-le.</li> <li>Sans \u00e9crire la commande, afficher la commande <code>cal 3 2022</code>, sans l'ex\u00e9cuter (c'est-\u00e0-dire sans appuyer sur entr\u00e9e).</li> <li>Appuyez sur Ctrl + U. Notez \u00e0 quoi sert ce raccourci et apprenez-le.</li> <li>Affichez de nouveau la commande <code>uname</code>, sans l'\u00e9crire ni l'ex\u00e9cuter, puis appuyez sur Ctrl + D. Que se passe-t-il ?</li> <li>Effacez la ligne de commande avec un raccourci clavier et appuyez de nouveau sur Ctrl + D. Que se passe-t-il ?</li> <li>Ouvrez de nouveau un terminal Debian et appuyez plusieurs fois sur Ctrl + P. Qu'observez-vous ?</li> <li>Fermez le terminal avec un raccourci clavier.</li> </ol>"},{"location":"contenus/tp1/#exercice-2-repertoires-et-fichiers","title":"Exercice 2 : R\u00e9pertoires et fichiers \ud83d\udcda\ud83d\udcda","text":"<ol> <li>Ouvrez un terminal Debian et tapez la commande suivante, en respectant sa syntaxe : <pre><code>PS1='$ '\n</code></pre></li> <li>Entrez la commande <code>pwd</code> (print working directory), c'est-\u00e0-dire afficher le nom du r\u00e9pertoire courant et notez ce qui est affich\u00e9 \u00e0 l'\u00e9cran : c'est le chemin absolu de votre r\u00e9pertoire personnel, votre home.</li> <li>Entrez la commande <code>cd ..</code> (change directory,  avec un espace entre <code>cd</code> et <code>..</code>) puis <code>pwd</code>. R\u00e9p\u00e9tez plusieurs fois ces deux commandes jusqu'\u00e0 ce que le r\u00e9sultat reste le m\u00eame. Que s'est-il pass\u00e9 ?</li> <li>Entrez la commande <code>cd</code> (sans argument), puis <code>pwd</code>. Commentez.</li> <li>Entrez la commande <code>cd /</code>, puis <code>pwd</code> et <code>ls</code>. \u00c0 quoi sert la commande <code>ls</code> ?</li> <li>Entrez la commande <code>cd /usr/include</code>. Utilisez la commande <code>ls</code>. \u00c0 quoi semble servir ce r\u00e9pertoire ?</li> <li>La commande <code>cat</code> (concatenate) affiche un ou plusieurs fichiers donn\u00e9s en arguments (l'un apr\u00e8s l'autre) dans le terminal. La commande <code>wc</code> (word count) affiche (dans cet ordre) le nombre de lignes, de mots et de caract\u00e8res des fichiers donn\u00e9s en arguments, puis, s'il y en a plusieurs, les sommes de ces nombres pour tous les fichiers. Affichez le contenu du fichier <code>stdlib.h</code> et le nombre de lignes de ce fichier.</li> <li>Entrez la commande <code>cd ..</code>, <code>pwd</code> et <code>ls</code>.</li> <li>Entrez la commande <code>cd share/man</code>, puis <code>pwd</code> et <code>ls</code>. Pouvez-vous deviner \u00e0 quoi se r\u00e9f\u00e8rent certains des r\u00e9sultats affich\u00e9s ?</li> <li>Entrez la commande <code>ls /bin</code>. Certains noms vous sont-ils familiers ?</li> <li>Le caract\u00e8re <code>~</code> (qui se lit tilde) est entr\u00e9 au clavier avec la combinaison de touches <code>Alt Gr-2</code>. Entrez la commande <code>echo ~</code>, puis la commande <code>cd ~</code>. Que fait le shell au caract\u00e8re <code>~</code> ?</li> <li>Repr\u00e9sentez les r\u00e9pertoires et fichiers mentionn\u00e9s dans l'Exercice sous la forme d'un arbre (c'est-\u00e0-dire comme un arbre g\u00e9n\u00e9alogique).</li> </ol>"},{"location":"contenus/tp1/#exercice-3-gestion-de-repertoires-et-de-fichiers-1","title":"Exercice 3 : Gestion de r\u00e9pertoires et de fichiers (1) \ud83d\udcda\ud83d\udcda","text":"<p>Chemin d'acc\u00e8s</p> <p>La r\u00e9f\u00e9rence \u00e0 une ressource (fichier ou r\u00e9pertoire) s'appelle un chemin d'acc\u00e8s (en anglais : path). Dans ce chemin, sous Linux, les noms des r\u00e9pertoires et \u00e9ventuel fichier sont s\u00e9par\u00e9s par un slash <code>/</code> (alors qu'on utilise un antislash <code>\\</code> sous Windows).</p> <p>Il existe deux types de chemin : absolu et relatif. </p> <ol> <li>Un chemin absolu se base sur la racine de l'arborescence et commence par <code>/</code>, par exemple : <code>/home/debian</code> est le chemin abslou vers le repertoire personnel de l'utilisateur debian. Il reste valable quel que soit le contexte.</li> <li>Un chemin relatif est a priori relatif au r\u00e9pertoire courant o\u00f9 se trouve l'utilisateur. ar exemple, si le r\u00e9pertoire courant est <code>/home/debian</code>, le chemin relatif <code>./Documents</code> fait r\u00e9f\u00e9rence au r\u00e9pertoire <code>/home/debian/Documents</code>.Un chemin qui commence par autre chose que <code>/</code> ou <code>~</code> est un chemin relatif. </li> </ol> <p>Le <code>.</code> fait r\u00e9f\u00e9rence au r\u00e9pertoire courant. Les <code>..</code> font r\u00e9f\u00e9rence au r\u00e9pertoire parent.</p> <p>O\u00f9 se trouve <code>~</code> sur le clavier ?</p> <ul> <li>Sur un clavier azerty windows, le caract\u00e8re <code>~</code> (tilde) est entr\u00e9 au clavier avec la combinaison de touches Alt Gr + 2</li> <li>Sur un clavier mac, le caract\u00e8re <code>~</code> (tilde) est entr\u00e9 au clavier avec la combinaison de touches Alt + N</li> </ul> <ol> <li>Assurez-vous d'\u00eatre dans votre r\u00e9pertoire personnel et listez son contenu.</li> <li>Entrez la commande <code>mkdir tp_shell</code> (pour make directory, c'est-\u00e0-dire cr\u00e9er un r\u00e9pertoire). Listez le contenu du r\u00e9pertoire personnel et du r\u00e9pertoire <code>tp_shell</code>.</li> <li>Entrez la commande <code>mkdir abeilles tp_shell/tp1 ~/arbres</code>. Que fait-elle ? Parmi ses arguments, lesquels sont des chemins absolus et lesquels sont des chemins relatifs ? (indice : voir le r\u00e9sultat de <code>echo ~/arbres</code>).`</li> <li>Que fait la commande suivante ?     <pre><code>$ mkdir -p vivant/plante/fleur tp_shell/tp1/exos/ex1/\n</code></pre></li> <li>Le shell <code>bash</code> (qui est votre shell par d\u00e9faut) poss\u00e8de une fonctionnalit\u00e9 qui fait gagner beaucoup de temps et \u00e9vite les fautes de frappe : la compl\u00e9tion automatique. Elle se fait avec la touche de tabulation (la touche \u00e0 gauche de la touche <code>a</code>). Entrez les caract\u00e8res suivants (la touche de tabulation \u21e5 Tab est repr\u00e9sent\u00e9e ci-dessous par <code>&lt;Tab&gt;</code>) et observez le r\u00e9sultat dans le terminal :     <pre><code>$ mkd&lt;Tab&gt; vi&lt;Tab&gt;&lt;Tab&gt;&lt;Tab&gt;roses\n</code></pre></li> <li>Quand plusieurs choix sont possibles, la tabulation ne d\u00e9clenche pas la compl\u00e9tion, mais en appuyant deux fois de suite sur la touche de tabulation, la liste des choix possibles est affich\u00e9e : essayez avec     <pre><code>$ ls a&lt;Tab&gt;&lt;Tab&gt;\n</code></pre></li> <li>La commande <code>rmdir</code> (pour remove directory) permet de supprimer des r\u00e9pertoires. Testez-la avec la commande     <pre><code>$ rmdir vivant tp_shell/tp1/exos/ex1\n</code></pre> et supprimez le sous-r\u00e9pertoire <code>tp1</code> du r\u00e9pertoire <code>tp_shell</code>.</li> <li>La commande <code>touch</code> permet (entre autres) de cr\u00e9er des fichiers vides (normaux). Observez le r\u00e9sultat de la commande (ex\u00e9cut\u00e9e depuis votre r\u00e9pertoire personnel) :     <pre><code>$ touch ~/arbres/hello.c abeilles/truc.txt bidule\n</code></pre> en entrant <pre><code>$ ls ~/arbres abeilles/ .\n</code></pre></li> <li>La commande <code>mv</code> pour move permet de d\u00e9placer ou renommer des fichiers. Observez avec <code>ls</code> le r\u00e9sultat de chacune des commandes suivantes :     <pre><code>$ mv arbres/hello.c arbres/bonjour.c\n$ mv abeilles arbres vivant/\n$ mv bidule vivant\n$ mv vivant vie\n</code></pre></li> <li>La commande <code>cp</code> pour copy, permet de copier des fichiers et des r\u00e9pertoires. Observez le r\u00e9sultat des commandes suivantes :     <pre><code>$ cp vie/arbres/bonjour.c salut.c\n$ mkdir copies\n$ cp salut.c vie/abeilles/truc.txt copies\n$ cp vie/bidule tp_shell copies\n$ cp -R vie/bidule tp_shell copies\n$ cp vie copie_vie\n$ cp -R vie copie_vie\n</code></pre> Essayez de d\u00e9crire les op\u00e9rations de la commande <code>cp</code> en fonction que son dernier argument soit un r\u00e9pertoire existant ou non et que l'option <code>-R</code> soit pr\u00e9sente ou non. Pouvez-vous d\u00e9duire l'utilit\u00e9 de l'option <code>-R</code> ?      </li> <li>Enfin, la commande <code>rm</code> (pour remove) permet de supprimer des fichiers et des r\u00e9pertoires. Observez le r\u00e9sultat des commandes suivantes :     <pre><code>$ rm vie/bidule\n$ rm copies\n$ rm -r copies\n$ rm -R copie_vie\n$ rm -i vie/arbres/bonjour.c vie/abeilles/truc.txt\n</code></pre></li> <li>Supprimez tous les fichiers et r\u00e9pertoires cr\u00e9\u00e9s lors de cet Exercice.</li> </ol>"},{"location":"contenus/tp1/#exercice-4-gestion-de-repertoires-et-de-fichiers-2","title":"Exercice 4 : Gestion de r\u00e9pertoires et de fichiers (2) \ud83d\udcda\ud83d\udcda\ud83d\udcda","text":"<p>Cr\u00e9ez l'arborescence suivante. Le <code>~</code> repr\u00e9sente le r\u00e9pertoire personnel de l'utilisateur. Seuls <code>rapport.txt</code> et <code>index.html</code> sont des fichiers normaux, les autres sont tous des r\u00e9pertoires. Les r\u00e9pertoires Mail, Rapport et Web seront cr\u00e9\u00e9s en une seule commande \u00e0 l'aide de <code>mkdir</code>.</p> <p><pre><code>stateDiagram-v2\n    ~ --&gt; Mail\n    ~ --&gt; Rapport\n    ~ --&gt; Web\n    Rapport --&gt; rapport.txt\n    Rapport --&gt; Docs\n    Docs --&gt; Afaire\n    Docs --&gt; Fait\n    Web --&gt; index.html</code></pre> Utilisez la commande <code>touch</code> pour cr\u00e9er les fichiers normaux et un \u00e9diteur de texte pour leur donner un contenu.</p> <p>Depuis votre r\u00e9pertoire personnel, ex\u00e9cutez les op\u00e9ratiorns suivantes (plusieurs solutions sont possibles) :</p> <ol> <li>Allez directement dans <code>~/Rapport/Docs/Afaire</code>.</li> <li>De l\u00e0, allez dans <code>~/Rapport/Docs/Fait</code> et copiez-y le fichier <code>rapport.txt</code>. Rappel : le r\u00e9pertoire courant peut \u00eatre d\u00e9sign\u00e9 par <code>.</code> (un point).</li> <li>Renommez cette copie <code>rapport_copie.txt</code>.</li> <li>Revenez dans <code>~/Rapport</code>.</li> <li>Sans changer de r\u00e9pertoire, affichez le contenu du fichier <code>index.html</code> \u00e0 l'aide de la commande <code>cat</code>.</li> <li>Sans changer de r\u00e9pertoire, listez le contenu du r\u00e9pertoire <code>Web</code>.</li> <li>Revenez dans <code>~</code> et supprimez toute l'arborescence de cet Exercice.</li> </ol>"},{"location":"contenus/tp1/#exercice-5-commandes-internes-et-commandes-externes","title":"Exercice 5 : Commandes internes et commandes externes \ud83d\udcda","text":"<p>Differents types de commandes</p> <p>Il existe plusieurs types de commandes : les commandes externes, les commandes internes, les fonctions du shell et les alias. Les commandes externes sont des programmes compil\u00e9s ou des scripts install\u00e9s sur le syst\u00e8me. Les commandes internes (aussi appel\u00e9es commandes int\u00e9gr\u00e9es) sont des commandes int\u00e9gr\u00e9es au shell. Les fonctions du shell sont des fonctions d\u00e9finies par l'utilisateur. Les alias sont des raccourcis pour des commandes d\u00e9finis par l'utilisateur.</p> <p>La commande <code>type</code> permet de conna\u00eetre le type d'une commande. Par exemple, la commande <code>type</code> elle-m\u00eame est une commande interne :</p> <pre><code>$ type type\ntype is a shell builtin\n</code></pre> <ol> <li>Pour chacune des commandes utils\u00e9es dans les Exercices pr\u00e9c\u00e9dents, dire avec la commande <code>type</code> \u00e0 quelle cat\u00e9gorie elle appartient (n'oubliez pas <code>type</code>).</li> <li>Pouvez-vous deviner dans quels r\u00e9pertoires se trouvent la plupart des programmes install\u00e9s sur le syst\u00e8me ?</li> </ol>"},{"location":"contenus/tp1/#exercice-6-obtenir-laide","title":"Exercice 6 : Obtenir l'aide \ud83d\udcda\ud83d\udcda","text":"<p>Si vous \u00eates sur Windows et que vous utilisez WSL</p> <p>Il se peut que <code>man</code> ne soit pas install\u00e9 sur votre Debian. Vous pouvez installer <code>man</code> avec la commande <code>sudo apt install manpages man-db</code>.</p> <p>Les pages du manuel</p> <p>La commande <code>man</code> fournit l'aide pour les commandes externes. Pour les commandes internes, vous pouvez utiliser la commande <code>help</code>.</p> <p>La command <code>man</code> affiche les pages du manuel de la commande donn\u00e9e en argument. Les pages du manuel sont divis\u00e9es en sections. La section est indiqu\u00e9e entre parenth\u00e8ses en haut \u00e0 gauche de la page.</p> <ul> <li>La partie <code>NAME</code> d\u00e9crit en une ligne ce que fait la commande. La partie <code>SYNOPSIS</code> d\u00e9crit les syntaxes accept\u00e9es par la commande.</li> <li>La partie <code>DESCRIPTION</code> d\u00e9crit en d\u00e9tail ce que fait la commande. Elle liste les options et arguments accept\u00e9s par la commande.</li> <li>Il peut y avoir une partie <code>EXAMPLES</code> qui donne des exemples d'utilisation de la commande.</li> </ul> <p>Les pages du manuel peuvent \u00eatre plus ou moins compr\u00e9hensibles... Mais on a rarement besoin de tout comprendre.</p> <ol> <li>Entrez la commande <code>man ls</code>. Quelles sont les options <code>-l</code> et <code>-a</code> ? Appuyez sur la touche <code>q</code> pour quitter l'aide et testez-les.</li> <li>\u00c0 l'aide du manuel, dire \u00e0 quoi sert l'option <code>-f</code> de la commande <code>rm</code> et comment on peut supprimer un fichier dont le nom commence par un tiret (comme par exemple <code>-f</code>).</li> <li>\u00c0 l'aide de la commande <code>help</code>, afficher les pages d'aide des commandes internes <code>echo</code> et <code>type</code>.</li> <li>\u00c0 l'aide du manuel sur la commande <code>touch</code>, quelle est l'utilit\u00e9 de cette commande si ce n'est pas de cr\u00e9er des fichiers vides ?</li> <li>En utilisant la commande <code>man</code> sur <code>man</code>, pouvez-vous trouver la partie qui parle des comandes internes ? Dans quelle partie les librairies sont-elles document\u00e9es (par exemple la librairie standard de C) . Selon vous quelle est la diff\u00e9rence entre les commandes suivantes ?     <pre><code>man 1 printf\nman 3 printf\n</code></pre></li> <li>Dans la page de manuel de <code>mv</code>, observer les deux premi\u00e8res lignes de la partie \u00ab SYNOPSIS \u00bb. Que signifient les crochets ? les points de suspension ? Si besoin, se reporter au manuel de <code>man</code>.</li> </ol>"},{"location":"contenus/tp1/#exercice-7-caracteres-joker","title":"Exercice 7 : Caract\u00e8res joker \ud83d\udcda\ud83d\udcda\ud83d\udcda","text":"<p>Caract\u00e8res joker</p> <p>Les caract\u00e8res joker (wildcards en anglais) sont des caract\u00e8res qui sont utilis\u00e9s pour repr\u00e9senter un ou plusieurs autres caract\u00e8res. Ils servent \u00e0 sp\u00e9cifier des motifs dans les commandes.</p> <p>Les caract\u00e8res joker sont interpr\u00e9t\u00e9s par le shell avant l'ex\u00e9cution de la commande. Le shell remplace le caract\u00e8re joker par la liste des fichiers qui correspondent au motif. C'est ce qu'on appelle l'expansion des chemins.</p> <p>Il existe plusieurs types de caract\u00e8res joker, mais nous n'utiliserons que les plus courants : <code>*</code>, <code>?</code> et <code>[ ]</code>.</p> <ul> <li><code>*</code> sert \u00e0 repr\u00e9senter une cha\u00eene de caract\u00e8res \u00e9ventuellement vide, sauf si c'est le premier caract\u00e8re de la cha\u00eene et que la cha\u00eene commence par un point (<code>.</code>);</li> <li><code>[ ]</code> repr\u00e9sente un seul caract\u00e8re qui est dans l'intervalle de caract\u00e8res sp\u00e9cifi\u00e9 entre les crochets. Vous pouvez utiliser des intervalles, comme dans <code>[a-z]</code> qui repr\u00e9sente une seule lettre minuscule ou dans <code>[0-5]</code> qui repr\u00e9sente un seul chiffre entre <code>0</code> et <code>5</code>. Vous pouvez inverser la recherche en commen\u00e7ant l'intervalle par <code>^</code> : par exemple <code>[^0-9]</code> repr\u00e9sente un seul caract\u00e8re qui est tout sauf un chiffre.</li> <li><code>?</code> repr\u00e9sente un seul caract\u00e8re quelconque;</li> <li>Vous pouvez retrouver la liste des caract\u00e8res joker dans le manuel de bash, \u00e0 la section Pathname Expansion.</li> </ul> <ol> <li>Cr\u00e9ez un r\u00e9pertoire <code>tp_joker</code> dans votre r\u00e9pertoire personnel. D\u00e9placez-vous dans ce r\u00e9pertoire. Cr\u00e9ez les fichiers (vides) suivants : <code>annee1</code> <code>Annee2</code> <code>annee4</code> <code>annee45</code> <code>annee41</code> <code>annee510</code> <code>annee_saucisse</code> <code>annee_banane</code> <code>bonbon</code>.</li> <li>Dans un premier temps, sans les ex\u00e9cuter, essayez de pr\u00e9dire le r\u00e9sultat des commandes suivantes :     <pre><code>$ echo *\n$ echo *_*\n$ echo [ab]*\n$ echo [^ab]*\n$ echo c*\n$ echo ??????\n</code></pre>     Puis testez les.</li> <li>En utilisant la commande <code>ls</code>, listez tous les fichiers qui :<ul> <li>se terminent par <code>5</code></li> <li>commencent par <code>annee4</code></li> <li>commencent par <code>annee4</code> et ont au maximum 7 lettres</li> <li>commencent par <code>annee</code> et dont le sixi\u00e8me caract\u00e8re n'est pas un chiffre</li> <li>contiennent la cha\u00eene <code>ana</code></li> <li>commencent par <code>a</code> ou <code>A</code></li> <li>dont l'avant-dernier caract\u00e8re est <code>4</code> ou <code>1</code></li> </ul> </li> <li>Listez tous les fichiers cach\u00e9s de votre r\u00e9pertoire personnel (les fichiers dont le nom commence par un point).</li> <li>Listez tous les fichiers dont le nom commence par <code>std</code> et se termine par <code>.h</code> dans le r\u00e9pertoire <code>/usr/include</code> et ses sous-r\u00e9pertoires.</li> </ol>"},{"location":"contenus/tp2/","title":"TP2 - Syst\u00e8me de fichiers et permissions","text":"<p>Objectifs p\u00e9dagogiques</p> <p>\u00c0 l\u2019issue de ce TP, l\u2019\u00e9tudiant sera capable de :</p> <ul> <li>Comprendre la structure du syst\u00e8me de fichiers Linux (hi\u00e9rarchie, r\u00e9pertoires standards)</li> <li>Identifier les utilisateurs, groupes et fichiers syst\u00e8me (<code>/etc/passwd</code>, <code>id</code>)</li> <li>Lire et interpr\u00e9ter les permissions en notation symbolique et octale</li> <li>Modifier les permissions avec <code>chmod</code></li> <li>Manipuler les fichiers et r\u00e9pertoires en tenant compte des droits d'acc\u00e8s</li> <li>Comprendre la diff\u00e9rence entre permissions sur    fichiers et sur r\u00e9pertoires</li> <li>Exp\u00e9rimenter les effets du <code>PATH</code> sur la r\u00e9solution des commandes</li> <li>Identifier les permissions n\u00e9cessaires \u00e0 l\u2019ex\u00e9cution d\u2019une commande</li> <li>Comprendre et manipuler le m\u00e9canisme de <code>umask</code></li> </ul> <p>Instructions</p> <ul> <li>On rappelle que dans tous les exercices le <code>$</code> en d\u00e9but de commande repr\u00e9sente le prompt, il n'est pas \u00e0 saisir lorsque vous \u00e9crivez une ligne de commande.</li> <li>Pour chaque nouvelle commande, n'h\u00e9sitez pas \u00e0 consulter sa page de manuel avec la commande <code>man</code>, ou \u00e0 utiliser l'option <code>--help</code> (si elle est disponible) pour savoir ce qu'elle fait.</li> </ul> <p>Bar\u00e8me d\u2019interpr\u00e9tation des exercices</p> <p>\ud83d\udcda = Facile, \ud83d\udcda\ud83d\udcda = Moyenne, \ud83d\udcda\ud83d\udcda\ud83d\udcda = \u00c9lev\u00e9e  </p>"},{"location":"contenus/tp2/#systeme-de-fichiers","title":"Syst\u00e8me de fichiers","text":"<p>Le syst\u00e8me de fichiers Linux</p> <p>Le syst\u00e8me de fichiers Linux est une arborescence ou une hi\u00e9rarchie de fichiers et de r\u00e9pertoires. Le r\u00e9pertoire racine est <code>/</code> et tous les autres r\u00e9pertoires sont des sous-r\u00e9pertoires de celui-ci. Les r\u00e9pertoires sont s\u00e9par\u00e9s par des <code>/</code> et les fichiers sont des noms de fichiers. </p> <p>Quand vous lancez un shell (i.e. ouvrez un terminal), celui-ci se trouve dans un r\u00e9pertoire. Ce r\u00e9pertoire est appel\u00e9 votre r\u00e9pertoire courant ou r\u00e9pertoire de travail. </p> <p>Un syst\u00e8me Linux typique comporte des dixaines de milliers de r\u00e9pertoires syst\u00e8me et de fichiers. La plupart de ces r\u00e9pertoires et fichiers sont cach\u00e9s et ne sont pas visibles par d\u00e9faut. Ces fichiers et r\u00e9pertoires cach\u00e9s sont utilis\u00e9s par le syst\u00e8me d'exploitation pour stocker des informations de configuration et d'autres informations syst\u00e8me.</p> <p>Les sous-r\u00e9pertoires de la racine sont g\u00e9n\u00e9ralement r\u00e9serv\u00e9s aux fichiers syst\u00e8me. Les r\u00e9pertoires <code>/home</code> et <code>/tmp</code> sont utilis\u00e9s pour stocker des fichiers temporaires et des fichiers personnels.</p> <p>\u00c0 moins d'\u00eatre un administrateur syst\u00e8me, vous n'avez pas besoin de vous soucier de la plupart des fichiers et r\u00e9pertoires syst\u00e8me. Toutefois il est important de comprendre comment les r\u00e9pertoires et les fichiers sont organis\u00e9s afin de pouvoir naviguer dans le syst\u00e8me de fichiers et de pouvoir trouver les fichiers dont vous avez besoin.</p> <p>Le tableau suivant d\u00e9crit le contenu des principaux r\u00e9pertoires du syst\u00e8me de fichiers Linux.</p> R\u00e9pertoire Description <code>/</code> R\u00e9pertoire racine. Tous les autres r\u00e9pertoires sont des sous-r\u00e9pertoires de celui-ci. <code>/bin</code> Contient les programmes essentiels au fonctionnement du syst\u00e8me. <code>/boot</code> Contient les fichiers n\u00e9cessaires au d\u00e9marrage du syst\u00e8me. <code>/dev</code> Contient les fichiers repr\u00e9sentant les p\u00e9riph\u00e9riques. <code>/etc</code> Contient les fichiers de configuration du syst\u00e8me. <code>/home</code> Contient les r\u00e9pertoires personnels des utilisateurs. <code>/lib</code> Contient les biblioth\u00e8ques partag\u00e9es et les modules du noyau. <code>/media</code> Contient les points de montage des p\u00e9riph\u00e9riques amovibles. <code>/mnt</code> Contient les points de montage des syst\u00e8mes de fichiers temporaires. <code>/opt</code> Contient les logiciels additionnels. <code>/proc</code> Contient les informations sur les processus et le syst\u00e8me. <code>/root</code> R\u00e9pertoire personnel de l'administrateur. <code>/run</code> Contient les fichiers d'ex\u00e9cution des applications. <code>/sbin</code> Contient les programmes essentiels au fonctionnement du syst\u00e8me. <code>/srv</code> Contient les donn\u00e9es des services fournis par le syst\u00e8me. <code>/sys</code> Contient les informations sur les p\u00e9riph\u00e9riques. <code>/tmp</code> Contient les fichiers temporaires. <code>/usr</code> Contient les programmes, les biblioth\u00e8ques et les fichiers de configuration. <code>/var</code> Contient les fichiers variables comme les logs, les mails, les bases de donn\u00e9es, etc. <code>/lost+found</code> Contient les fichiers r\u00e9cup\u00e9r\u00e9s lors d'un crash du syst\u00e8me."},{"location":"contenus/tp2/#exercice-1-id-et-etcpasswd","title":"Exercice 1 : <code>id</code> et <code>/etc/passwd</code> \ud83d\udcda","text":"<ol> <li>Entrez les commandes suivantes dans un terminal et notez les r\u00e9sultats :    <pre><code>$ id\n</code></pre></li> <li>Ensuite tapez la m\u00eame commande, mais cette fois-ci avec l'argument <code>root</code>, notez les r\u00e9sultats.    <pre><code>$ id root\n</code></pre></li> <li>Affichez ensuite le contenu du fichier <code>/etc/passwd</code> avec la commande <code>cat</code>. </li> <li>Recherchez les lignes o\u00f9 appara\u00eessent votre nom d'utilisateur et celui de l'utilisateur <code>root</code>. Quelles sont les diff\u00e9rences ?</li> <li>Pouvez-vous d\u00e9duire \u00e0 quoi sert le fichier <code>/etc/passwd</code> ?</li> </ol>"},{"location":"contenus/tp2/#permissions-associees-aux-fichiers","title":"Permissions associ\u00e9es aux fichiers","text":"<p>Protection des fichiers</p> <p>Un syst\u00e8me Linux peut permettre \u00e0 de nombreux utilisateurs d'acc\u00e9der aux fichiers et aux r\u00e9pertoires. Pour prot\u00e9ger les fichiers et les r\u00e9pertoires, Linux utilise un syst\u00e8me de permissions. Les permissions sont des droits d'acc\u00e8s aux fichiers et aux r\u00e9pertoires. Les permissions sont associ\u00e9es \u00e0 des utilisateurs et \u00e0 des groupes. Les utilisateurs sont des personnes qui ont un compte sur le syst\u00e8me.</p> <p>Pour les fichiers normaux, les permissions sont associ\u00e9es \u00e0 trois cat\u00e9gories d'utilisateurs : le propri\u00e9taire du fichier (g\u00e9n\u00e9ralement celui qui a cr\u00e9e le fichier), le groupe propri\u00e9taire du fichier et les autres utilisateurs. </p> <p>Les cat\u00e9gories de permissions pour un fichier sont les suivantes :</p> <ul> <li>read <code>r</code>: permet de lire le contenu du fichier.</li> <li>write <code>w</code>: permet de modifier le contenu du fichier.</li> <li>execute <code>x</code>: permet d'ex\u00e9cuter le fichier (si c'est un programme ou un script).</li> </ul> <p>L'option <code>-l</code> de la commande <code>ls</code> affiche les m\u00e9ta-donn\u00e9es associ\u00e9es \u00e0 un fichier, son nom, sa taille, son propri\u00e9taire, son groupe, ... et en particuler ses permissions, par exemple :</p> <pre><code>$ ls -l fichier\n-rw-r--r-- 1 user group 0 2019-09-09 10:00 fichier\n</code></pre> <p>La cha\u00eene <code>-rw-r--r--</code> repr\u00e9sente les permissions associ\u00e9es au fichier. Le premier caract\u00e8re d\u00e9signe le type du fichier, les trois suivants repr\u00e9sentent les permissions du propri\u00e9taire, les trois suivants celles du groupe propri\u00e9taire et les trois derniers celles des autres utilisateurs. Les permissions sont repr\u00e9sent\u00e9es par les caract\u00e8res <code>r</code>, <code>w</code> et <code>x</code> pour les permissions respectivement en lecture, \u00e9criture et ex\u00e9cution. Si la permission n'est pas accord\u00e9e, le caract\u00e8re <code>-</code> est utilis\u00e9 \u00e0 la place.</p> <p>Les permissions peuvent \u00eatre repr\u00e9sent\u00e9es par des chiffres (repr\u00e9sentation en octal) ou des lettres (repr\u00e9sentation symbolique).</p> <p>Le tableau suivant donne la correspondance entre les deux repr\u00e9sentations :</p> Chiffre Lettre Description 0 <code>---</code> Aucune permission 1 <code>--x</code> Ex\u00e9cution 2 <code>-w-</code> \u00c9criture 3 <code>-wx</code> \u00c9criture et ex\u00e9cution 4 <code>r--</code> Lecture 5 <code>r-x</code> Lecture et ex\u00e9cution 6 <code>rw-</code> Lecture et \u00e9criture 7 <code>rwx</code> Lecture, \u00e9criture et ex\u00e9cution <p>C'est-\u00e0-dire que pour la cha\u00eene <code>-rw-r--r--</code> les permissions sont les suivantes :</p> Utilisateur Groupe Autres symbolique <code>rw-</code> <code>r--</code> <code>r--</code> binaire 110 100 100 octale 6 4 4"},{"location":"contenus/tp2/#exercice-2-permissions-associees-aux-fichiers","title":"Exercice 2 : Permissions associ\u00e9es aux fichiers \ud83d\udcda","text":"<ol> <li> <p>Cr\u00e9ez un r\u00e9pertoire vide et un fichier vide (ces deux derniers doivent \u00eatre au m\u00eame niveau). Utilisez la commande <code>ls</code> et les options <code>-l</code> et <code>-d</code> sur chacun de ces deux nouveaux fichiers pour d\u00e9terminer les permissions que vous (respectivement votre groupe et les autres) avez sur ces fichiers. Comment reconnaissez-vous un r\u00e9pertoire ?</p> </li> <li> <p>Les lignes suivantes donnent la r\u00e9ponse de la commande <code>ls -ld</code> sur un certain r\u00e9pertoire (pour les besoins de l'exercice nous n'avons report\u00e9 que le premier et le dernier champ du r\u00e9sultat de <code>ls -ld</code>).     <pre><code>drwxr-xr-x a\ndr-xr--r-- b\n-rw-r--r-- c.txt\n--w--w-r-- d.c\n-rwxr-xr-x op\n</code></pre>     Parmi ces fichiers, quels sont les r\u00e9pertoires ?</p> </li> <li>Pour chacun des fichiers ci-dessus, donnez les permissions associ\u00e9es \u00e0 chacun des utilisateurs (propri\u00e9taire, groupe propri\u00e9taire et autres utilisateurs) en utilisant la repr\u00e9sentation symbolique et la repr\u00e9sentation octale.</li> <li>Donnez la repr\u00e9sentation symbolique et la repr\u00e9sentation octale des permissions associ\u00e9es au fichier <code>/etc/passwd</code>, \u00e0 la commande <code>ls</code> et \u00e0 votre r\u00e9pertoire personnel.</li> </ol>"},{"location":"contenus/tp2/#exercice-3-modification-des-permissions-chmod","title":"Exercice 3 : Modification des permissions <code>chmod</code> \ud83d\udcda\ud83d\udcda","text":"<ol> <li>Testez les commandes suivantes dans un terminal et essayez de comprendre comment fonctionne la commande <code>chmod</code> (avec la repr\u00e9sentation symbolique).     <pre><code>$ touch f; ls -l f\n$ chmod a= f; ls -l f\n$ chmod o+rw f; ls -l f\n$ chmod u=o f; ls -l f\n$ chmod o-wx f; ls -l f\n$ chmod g+u f; ls -l f\n$ chmod a+x,g-w f; ls -l f\n</code></pre></li> <li>Testez la commande <code>chmod 644 f; ls -l f</code>. Que fait cette commande ?</li> <li>Avec les deux modes d'utilisation de <code>chmod</code> (octale et symbolique), modifiez les permissions du fichier <code>f</code> de la mani\u00e8re suivante :<ul> <li>ex\u00e9cution pour tous, lecture et \u00e9criture uniquement pour le propri\u00e9taire.</li> <li>lecture et ex\u00e9cution pour tous, personne ne peut \u00e9crire.</li> <li>toutes les permissions pour tous, pas d'\u00e9criture pour les autres.</li> <li>lecture et \u00e9criture pour le propri\u00e9taire, ex\u00e9cution pour le groupe et aucune pour les autres.</li> </ul> </li> </ol>"},{"location":"contenus/tp2/#exercice-4-permissions-associees-aux-fichiers-normaux","title":"Exercice 4 : Permissions associ\u00e9es aux fichiers normaux \ud83d\udcda\ud83d\udcda","text":"<ol> <li>Dans un r\u00e9pertoire de votre choix, cr\u00e9er deux fichiers <code>f</code> et <code>g</code>. Puis entrer (par exemple avec un \u00e9diteur de texte) du texte dans ces fichiers.</li> <li>Pour vous (propri\u00e9taire), retirer la permission de lire dans le fichier <code>f</code> et la permission d'\u00e9crire dans le fichier <code>g</code>.</li> <li>Testez ensuite les commandes suivantes, puis notez les r\u00e9sultats :     <pre><code>$ cat f\n$ cat g\n</code></pre></li> <li>Essayer de modifier <code>g</code> avec un \u00e9diteur de texte. Que se passe-t-il ?</li> <li>Tester les commandes:     <pre><code>$ cp f h\n$ cp g h\n</code></pre>     Puis observer le contenu du fichier <code>h</code> ainsi que les permissions associ\u00e9es \u00e0 ce fichier.</li> <li>La commande suivante permet d'\u00e9crire la cha\u00eene <code>toto</code> \u00e0 la fin du fichier <code>f</code> (nous la verrons plus en d\u00e9tail dans un prochain TP) :     <pre><code>$ echo \"toto\" &gt;&gt; f\n</code></pre>     Tester cette commande, puis redonnez-vous les droits de lecture sur le fichier <code>f</code>. Enfin affichez le contenu du fichier <code>f</code> gr\u00e2ce \u00e0 la commande <code>cat</code>.</li> <li>Tester la commande:     <pre><code>$ rm g\n</code></pre> Tapez <code>n</code> pour refuser. Enfin tester la commande suivante:     <pre><code>$ rm -f g\n</code></pre>     A-t-elle r\u00e9ussie ? Que pouvez vous en d\u00e9duire ?</li> </ol>"},{"location":"contenus/tp2/#permissions-associees-aux-repertoires","title":"Permissions associ\u00e9es aux r\u00e9pertoires","text":"<p>Qu'est-ce qu'un r\u00e9pertoire ?</p> <p>Un r\u00e9pertoire est une table de noms de fichiers associ\u00e9s \u00e0 un num\u00e9ro d'index appel\u00e9 num\u00e9ro d'inode qui permet de conna\u00eetre les informations (contenues dans l'inode) concernant ce fichier (taille, permissions, horodatage, o\u00f9 trouver le contenu du fichier, ...).</p> <p>Dans un r\u00e9pertoire, les permissions ne sont pas associ\u00e9es aux fichiers mais au r\u00e9pertoire lui-m\u00eame. Les permissions associ\u00e9es \u00e0 un r\u00e9pertoire sont :</p> <ul> <li>read <code>r</code>: permet de lister le contenu du r\u00e9pertoire.</li> <li>write <code>w</code>: permet de modifier le contenu du r\u00e9pertoire (cr\u00e9er ou supprimer des fichiers).</li> <li>execute <code>x</code>: permet d'ouvrir le r\u00e9pertoire (avec la commande <code>cd</code> par exemple).</li> </ul>"},{"location":"contenus/tp2/#exercice-5-permissions-associees-aux-repertoires","title":"Exercice 5 : Permissions associ\u00e9es aux r\u00e9pertoires \ud83d\udcda\ud83d\udcda\ud83d\udcda","text":"<ol> <li>Cr\u00e9ez un r\u00e9pertoire <code>rep</code> et deux fichiers normaux <code>a</code> et <code>b</code> \u00e0 l'int\u00e9rieur de ce r\u00e9pertoire.</li> <li>Retirez toutes les permissions sur le r\u00e9pertoire <code>rep</code> et essayez les commandes suivantes :     <pre><code>$ cd rep\n$ ls rep\n$ cat rep/a\n$ touch rep/c\n$ rm rep/a\n</code></pre></li> <li>Redonnez la permission read uniquement sur le r\u00e9pertoire <code>rep</code> et essayez les toutes les commandes de la question 2. Notez les diff\u00e9rences.</li> <li>M\u00eame question mais avec seulement la permission write sur <code>rep</code>. Notez les diff\u00e9rences.</li> <li>Cette fois-ci avec uniquement la permission execute sur <code>rep</code>. Testez les commandes suivantes :     <pre><code>$ cd rep\n$ ls rep\n$ echo \"toto\" &gt;&gt; rep/a\n$ cat rep/c\n$ ls -l rep/a\n$ touch rep/c\n$ rm rep/a\n</code></pre></li> <li> <p>Avec l'ensemble de permissions <code>-wx</code> sur <code>rep</code> pour tous les utilisateurs, essayez de:</p> <ul> <li>cr\u00e9er un fichier <code>d</code> dans <code>rep</code></li> <li>renommer le fichier <code>b</code></li> <li>retirer toutes les permissions associ\u00e9es au fichier <code>d</code></li> <li>supprimer le fichier <code>d</code></li> </ul> </li> </ol>"},{"location":"contenus/tp2/#exercice-6-les-repertoires-du-path","title":"Exercice 6 : Les r\u00e9pertoires du <code>PATH</code> \ud83d\udcda\ud83d\udcda\ud83d\udcda","text":"<p>Attention</p> <p>Cet exercice de type exp\u00e9rimentation est d\u00e9licat et important. Il faut le traiter avec un soin particulier et en prenant son temps.</p> <ol> <li>Ouvrir un nouveau terminal et entrer la commande suivante :     <pre><code>$ echo $PATH\n</code></pre>     Observer le r\u00e9sultat, \u00e0 votre avis \u00e0 quoi correspondent les \u00e9l\u00e9ments s\u00e9par\u00e9s par des <code>:</code> ?</li> <li>Cr\u00e9er un r\u00e9pertoire <code>bin</code> dans votre r\u00e9pertoire personnel et entrer les commandes suivantes:     <pre><code>$ PATH=~/bin:$PATH\n$ echo $PATH\n</code></pre>     Quelle est la diff\u00e9rence avec d'affichage avec le r\u00e9sultat de la question 1 ?</li> <li>\u00c0 l\u2019aide de la commande <code>type</code>, chercher les chemin absolus des programmes <code>cat</code> et <code>rm</code> et les noter.</li> <li>Faire une copie de <code>cat</code> dans <code>~/bin</code> en le renommant <code>rm</code>.</li> <li>Cr\u00e9er un fichier <code>fic</code>, y mettre quelques caract\u00e8res et cr\u00e9er deux copies <code>fic2</code> et <code>fic3</code> de <code>fic</code>.</li> <li>Essayer de d\u00e9truire <code>fic</code> avec la commande <code>rm</code>. Que s\u2019est-il pass\u00e9 ?</li> <li>Entrer la commande <code>$ type rm</code>.</li> <li>Lancer la commande     <pre><code>$ &lt;chemin vers rm&gt; fic\n</code></pre>     en rempla\u00e7ant <code>&lt;chemin vers rm&gt;</code> par le chemin absolu vers la commande <code>rm</code> not\u00e9 \u00e0 la question 3. Que s\u2019est-il pass\u00e9 ?</li> <li>Enlever la permission <code>x</code> sur le fichier <code>~/bin/rm</code> et essayer de supprimer <code>fic2</code>.</li> <li>Demander au shell d\u2019oublier les emplacements enregistr\u00e9s (\u00ab hach\u00e9s \u00bb) avec la commande <code>$ hash -r</code>, puis entrer les commandes     <pre><code>$ type rm\n$ rm fic2\n</code></pre></li> <li>Remettre la permission <code>x</code> sur <code>~/bin/rm</code> puis entrer les commandes suivantes (o\u00f9 <code>&lt;chemin vers rm&gt;</code> d\u00e9signe le chemin absolu not\u00e9 \u00e0 la question 3) :     <pre><code>$ ~/bin/rm fic3\n$ cd ~/bin\n$ ./rm fic3\n$ &lt;chemin vers rm&gt; rm\n$ rm fic3\n</code></pre></li> <li>Faire le bilan de cet exercice en r\u00e9pondant aux questions suivantes :<ul> <li>Qu'est-ce qui est contenu dans <code>PATH</code> ?</li> <li>Dans quel cas est-ce qu\u2019un nom de commande est cherch\u00e9 dans les r\u00e9pertoires du <code>PATH</code> ?</li> <li>S\u2019il y a plusieurs programmes correspondants dans les r\u00e9pertoires du <code>PATH</code>, lequel est choisi ?</li> </ul> </li> </ol>"},{"location":"contenus/tp2/#recapitulatif-sur-permissions-et-permissions-par-defaut","title":"R\u00e9capitulatif sur permissions et permissions par d\u00e9faut","text":""},{"location":"contenus/tp2/#exercice-7-on-lache-le-clavier","title":"Exercice 7: On lache le clavier \ud83d\udcda\ud83d\udcda","text":"<p>Consigne</p> <p>Cet exercice est \u00e0 faire \u00e0 l\u2019\u00e9crit, on l\u00e2che le clavier !</p> <p>Pour chacune des commandes suivantes, dire quelles permissions sont n\u00e9cessaires pour qu\u2019elle r\u00e9ussisse (on suppose que tous les r\u00e9pertoires et fichiers existent, sauf ceux qu\u2019on veut cr\u00e9er).</p> <pre><code>$ cat /usr/include/stdio.h\n$ cd /usr/include/\n$ ls /usr/include/\n$ echo '/* fin */' &gt;&gt; /usr/include/stdio.h\n$ rm /usr/include/stdio.h\n$ touch /usr/include/ma_bib.h\n$ chmod u+w /usr/include/stdio.h\n$ /usr/bin/uname\n</code></pre>"},{"location":"contenus/tp2/#exercice-8-permissions-par-defaut-et-umask-optionnel","title":"Exercice 8 : Permissions par d\u00e9faut et <code>umask</code> (optionnel) \ud83d\udcda\ud83d\udcda\ud83d\udcda","text":"<p>Tip</p> <p><code>umask</code> est une commande qui permet de d\u00e9finir les permissions par d\u00e9faut des fichiers et des r\u00e9pertoires que vous cr\u00e9ez. La valeur de l'umask est une valeur octale qui est soustraite des permissions par d\u00e9faut. Par exemple, si l'umask vaut 022, les permissions par d\u00e9faut sont 755 pour les r\u00e9pertoires et 644 pour les fichiers.</p> <ol> <li>Dans un terminal, tapez la commande <code>umask</code> et notez le r\u00e9sultat.</li> <li>Cr\u00e9ez un r\u00e9pertoire <code>rep</code> et un fichier <code>f</code> au m\u00eame niveau que <code>rep</code>. Affichez les permissions associ\u00e9es \u00e0 <code>rep</code> et <code>f</code> avec la commande <code>ls -ld rep f</code>. Convertissez ces permissions en repr\u00e9sentation octale et notez-les. Enfin, supprimez <code>rep</code> et <code>f</code>.</li> <li>Changez la valeur du masque avec la commande     <pre><code>$ umask 240\n</code></pre></li> <li>Changez la valeur du masque avec la commande     <pre><code>$ umask 121\n</code></pre>     puis refaites la question 2.</li> <li>Changez la valeur du masque avec la commande     <pre><code>$ umask 666\n</code></pre>     puis refaites la question 2.</li> <li>De toutes les questions pr\u00e9c\u00e9dentes, pouvez-vous d\u00e9duire comment la valeur de l'umask agit sur les permissions associ\u00e9es aux r\u00e9pertoires et aux fichiers que vous cr\u00e9ez ?</li> <li>Donnez \u00e0 l'umask sa valeur initiale.</li> </ol>"},{"location":"contenus/tp3/","title":"TP3 - Environnement de travail et Compilateur C","text":"<p>Objectifs p\u00e9dagogiques</p> <p>\u00c0 l\u2019issue de ce TP, l\u2019\u00e9tudiant sera capable de :</p> <ul> <li>Comprendre la notion de variables dans un shell et manipuler leur affectation et leur d\u00e9veloppement</li> <li>Identifier et utiliser les caract\u00e8res sp\u00e9ciaux du shell et les m\u00e9canismes d\u2019inhibition (<code>\\</code>, <code>'</code>, <code>\"</code>)</li> <li>Utiliser des expressions avec jokers (wildcards) et les extensions de chemins pour manipuler efficacement des ensembles de fichiers</li> <li>Manipuler l\u2019extension d\u2019accolades dans des expressions shell</li> <li>Utiliser la substitution de commande pour capturer dynamiquement le r\u00e9sultat d'une commande</li> <li>Savoir compiler un programme en C avec <code>gcc</code> et identifier les erreurs de compilation et les interpr\u00e9ter</li> </ul> <p>Instructions</p> <ul> <li>On rappelle que dans tous les exercices le <code>$</code> en d\u00e9but de commande repr\u00e9sente le prompt, il n'est pas \u00e0 saisir lorsque vous \u00e9crivez une ligne de commande.</li> <li>Pour chaque nouvelle commande, n'h\u00e9sitez pas \u00e0 consulter sa page de manuel avec la commande <code>man</code>, ou \u00e0 utiliser l'option <code>--help</code> (si elle est disponible) pour savoir ce qu'elle fait.</li> </ul> <p>Bar\u00e8me d\u2019interpr\u00e9tation des exercices</p> <p>\ud83d\udcda = Facile, \ud83d\udcda\ud83d\udcda = Moyenne, \ud83d\udcda\ud83d\udcda\ud83d\udcda = \u00c9lev\u00e9e </p>"},{"location":"contenus/tp3/#les-variables-du-shell","title":"Les variables du shell","text":"<p>D\u00e9finition et utilisation</p> <p>Une variable est un nom qui est associ\u00e9 \u00e0 une valeur. En shell, les variables sont des cha\u00eenes de caract\u00e8res. Le d\u00e9veloppement d\u2019une variable est le remplacement du nom de la variable par sa valeur.</p> <p>Par exemple, la variable <code>PS1</code> est la variable qui contient le prompt du shell. Lors des TP pr\u00e9c\u00e9dents, quand vous tapiez la commande <code>PS1='$ '</code>, vous avez affect\u00e9 la cha\u00eene <code>$&lt;space&gt;</code> \u00e0 la variable <code>PS1</code>. Lorsque le shell affiche le prompt, il d\u00e9veloppe la variable <code>PS1</code> et affiche la cha\u00eene <code>$&lt;space&gt;</code>. </p> <p>Les variables du shell sont des variables d\u2019environnement. Elles sont accessibles \u00e0 tous les processus lanc\u00e9s par le shell. On peut les lister avec la commande <code>env</code> ou <code>printenv</code>. On peut \u00e9galement les lister avec la commande <code>set</code> qui liste \u00e9galement les variables internes du shell (voir la page de manuel de <code>set</code> pour plus de d\u00e9tails).</p>"},{"location":"contenus/tp3/#exercice-1-les-variables-du-shell","title":"Exercice 1 : Les variables du Shell \ud83d\udcda","text":"<ol> <li>Tapez les commandes suivantes dans un terminal: <pre><code>$ nom_fich=hello.c\n$ echo nom_fich\n$ echo $nom_fich\n$ echo ${nom_fich}\n$ touch $nom_fich\n$ echo $nom_fichpp\n$ echo ${nom_fich}pp\n$ rm ${nom_fich}\n</code></pre></li> <li>Rappelez ce que fait la commande <code>echo</code>. \u00c0 votre avis, \u00e0 quoi sert le caract\u00e8re <code>$</code> devant le nom de la variable <code>nom_fich</code>?</li> <li>Que se passe-t-il si on demande au shell d'afficher le contenu d'une variable qui n'existe pas?</li> <li>Que se passe-t-il si vous mettez un espace entre le nom de la variable et le signe \u00e9gal <code>=</code>? Et entre le signe \u00e9gal et la valeur?</li> <li>Entrez les commandes suivantes et essayez de commenter leur effet: <pre><code>$ sujet=Alice verbe=aime cod=piscine\n$ phrase=\"$sujet $verbe la $cod.\"\n$ echo $phrase\n$ sujet=Bob verbe=mange cod=salade\n$ echo $phrase\n$ echo \"$sujet $verbe la $cod.\"\n</code></pre></li> </ol>"},{"location":"contenus/tp3/#caracteres-speciaux-et-inhibitions","title":"Caract\u00e8res sp\u00e9ciaux et inhibitions","text":"<p>Caract\u00e8res sp\u00e9ciaux du shell</p> <p>Certains caract\u00e8res ont une signification particuli\u00e8re pour le shell : on dit qu\u2019ils sont sp\u00e9ciaux. \u00c0 l\u2019inverse, on dit d\u2019un caract\u00e8re qui n\u2019a pas d\u2019autre signification que lui-m\u00eame, qu\u2019il a son sens litt\u00e9ral. Nous listons ci-dessous les caract\u00e8res sp\u00e9ciaux ; la plupart d\u2019entre eux seront vus en d\u00e9tail plus tard dans le cours.</p> <ul> <li><code>; &lt;newline&gt; | &amp;</code> ils mettent fin \u00e0 la commande qui les pr\u00e9c\u00e8de. On a utilis\u00e9 <code>&lt;newline&gt;</code> pour repr\u00e9senter le caract\u00e8re nouvelle ligne qu\u2019on saisit avec la touche Entr\u00e9e. Le caract\u00e8re sp\u00e9cial <code>|</code> est saisi avec la combinaison de touches <code>Alt Gr-6</code> (<code>Option-Shift-l</code> sous mac), on l\u2019appelle pipe ou conduite. Le caract\u00e8re sp\u00e9cial <code>&amp;</code> est saisi avec la combinaison de touches <code>Alt Gr-8</code> et sert \u00e0 lancer des commandes en arri\u00e8re-plan.</li> <li><code>&lt; &gt;</code> appel\u00e9s chevrons, ils permettent les redirections.</li> <li><code>( )</code> pour regrouper des commandes et les lancer dans un sous-shell.</li> <li><code>$</code> pour le d\u00e9veloppement de variables, le d\u00e9veloppement arithm\u00e9tique et la substitution de commande.</li> <li><code>`</code> l\u2019accent grave (en anglais, backtick ou backquote) pour la substitution de commandes (ancienne syntaxe). Il est saisi au clavier avec la combinaison de touches <code>Alt Gr-7</code> suivie d\u2019un espace.</li> <li><code>&lt;space&gt; &lt;tab&gt;</code> d\u00e9limitent les noms de commandes et arguments.</li> <li><code>\\ ' \"</code> la contre-oblique (aussi appel\u00e9e backslash ou antislash), l\u2019apostrophe (en anglais single quote) et le guillemet anglais (en anglais double quote) qui permettent justement d\u2019inhiber les caract\u00e8res sp\u00e9ciaux, c\u2019est-\u00e0-dire leur rendre leur sens litt\u00e9ral.</li> </ul> <p>Enfin, les caract\u00e8res suivants ont une signification particuli\u00e8re dans certains contextes et doivent donc parfois \u00eatre inhib\u00e9s:</p> <ul> <li><code>* ? ]</code> Pour le d\u00e9veloppement de noms de chemins.</li> <li><code>#</code> Pour \u00e9crire des commentaires (sauf s\u2019il est au milieu d\u2019un mot).</li> <li><code>~</code> Pour le d\u00e9veloppement du tilde (r\u00e9pertoire personnel).</li> <li><code>=</code> Pour l\u2019affectation de variables.</li> <li><code>%</code> Pour le contr\u00f4le des t\u00e2ches (job control).</li> </ul>"},{"location":"contenus/tp3/#exercice-2-inhibition-de-caracteres-speciaux-la-contre-oblique","title":"Exercice 2 : Inhibition de caract\u00e8res sp\u00e9ciaux (la contre-oblique <code>\\</code>) \ud83d\udcda","text":"<ol> <li>Testez les commandes suivantes. <pre><code>$ echo a b\n$ echo a\\ \\ \\ b\n$ touch fichier\\ vide\n$ rm fichier vide\n$ rm fichier\\ vide\n$ echo 3$canadiens\n$ echo 3\\$canadiens\n$ echo ; echo *\n$ echo \\; echo \\*\n$ echo \"salut\"\n$ echo \\\"salut\\\"\n$ echo 'salut'\n$ echo \\'salut\\'\n$ echo \\\n$ echo \\\\\n</code></pre></li> <li>En vous r\u00e9f\u00e9rent aux questions pr\u00e9c\u00e9dentes, r\u00e9pondez aux questions ci dessous:<ul> <li>Que fait le caract\u00e8re <code>\\</code> devant un autre caract\u00e8re que <code>&lt;newline&gt;</code> (on rappelle que le caract\u00e8re <code>&lt;newline&gt;</code> est celui qui r\u00e9sulte de l'appui de la touche Entr\u00e9e du clavier) ?</li> <li>\u00c0 quoi sert la cha\u00eene de caract\u00e8res <code>\\&lt;newline&gt;</code> ?</li> <li>Comment peut-on obtenir un caract\u00e8re <code>\\</code> litt\u00e9ral ? Comment afficher <code>\\\\</code> \u00e0 l'aide de la commande <code>echo</code> ?</li> </ul> </li> </ol>"},{"location":"contenus/tp3/#exercice-3-linhibition-des-caracteres-speciaux-lapostrophe","title":"Exercice 3 : L\u2019inhibition des caract\u00e8res sp\u00e9ciaux (l'apostrophe <code>'</code>) \ud83d\udcda\ud83d\udcda","text":"<p>Remarque</p> <p>L'option <code>-i</code> de la commande <code>rm</code> permet de demander une confirmation avant la suppression.</p> <ol> <li> <p>Tester les commandes suivantes : <pre><code>$ touch 'ceci est un horrible nom de fichier'\n$ rm -i ceci est un horrible nom de fichier\n$ rm -i 'ceci est un horrible nom de fichier'\n$ touch p; echo le caract\u00e8re * est-il sp\u00e9cial ? et ?\n$ echo 'le caract\u00e8re * est-il sp\u00e9cial ? et ?'\n$ echo 'en fait, m\u00eame la fin de ligne&lt;newline&gt;est un caract\u00e8re normal entre&lt;newline&gt;apostrophes'\n$ echo 'le seul caract\u00e8re sp\u00e9cial entre apostrophes n'est-il pas apostrophe ?'\n</code></pre>     o\u00f9 <code>&lt;newline&gt;</code> sera \u00e0 taper avec la touche Entr\u00e9e de votre clavier.</p> </li> <li> <p>Au vu des exp\u00e9riences pr\u00e9c\u00e9dentes (et d\u2019autres \u00e0 inventer si n\u00e9cessaire), r\u00e9pondre aux questions suivantes :</p> <ul> <li>Quels sont les caract\u00e8res qui sont sp\u00e9ciaux entre apostrophes ?</li> <li>Comment obtenir une apostrophe dans une cha\u00eene entre apostrophes (question pi\u00e8ge) ?</li> <li>Comment, avec une combinaison de cha\u00eenes entre apostrophes et d\u2019une inhibition par contre-oblique, obtenir avec <code>echo</code> l\u2019affichage suivant ? <pre><code>Un d\u00e9veloppement de variable (comme $var) peut-il s'inhiber; par exemple entre apostrophes ?\n</code></pre></li> </ul> </li> </ol>"},{"location":"contenus/tp3/#exercice-4-linhibition-des-caracteres-speciaux-les-guillemets-anglais","title":"Exercice 4 : L\u2019inhibition des caract\u00e8res sp\u00e9ciaux (les guillemets anglais <code>\"</code>) \ud83d\udcda\ud83d\udcda","text":"<ol> <li>Tester les commandes suivantes et notez vos observation: <pre><code>$ echo \"? * et [ sont utilis\u00e9s pour le d\u00e9veloppement de chemins\"\n$ echo \"~ provoque un d\u00e9veloppement du tilde\"\n$ echo \" Entre \\\" , on peut aussi &lt;newline&gt;\u00e9crire sur plusieurs&lt;newline&gt; lignes\"\n$ nom=Alice\n$ echo '$nom scripte en shell'\n$ echo \"$nom scripte en shell\"\n$ echo \"\\$nom scripte en shell\"\n$ echo \"le chemin absolu du r\u00e9pertoire courant est `pwd`\"\n$ echo \"le chemin absolu du r\u00e9pertoire courant est \\`pwd\\`\"\n$ echo \"le chemin absolu du r\u00e9pertoire courant est $(pwd)\"\n$ echo \"le chemin absolu du r\u00e9pertoire courant est \\$(pwd)\"\n$ echo \"Aussi s\u00fbr que 2 et 2 font $((2 + 2))\"\n$ echo \"Aussi s\u00fbr que 2 et 2 font \\$((2 + 2))\"\n$ echo \"\\\\\\\\\\\"\\$\\`\\*\\'\"\n</code></pre></li> <li>Testez les commande suivantes et notez vos observations: <pre><code>$ mavar=\"Alice&lt;newline&gt; et&lt;newline&gt;Bob\"\n$ echo $mavar font plein de choses\n$ echo \"$mavar font plein de choses\"\n</code></pre></li> <li>Au vu des exp\u00e9riences pr\u00e9c\u00e9dentes (et d\u2019autres \u00e0 inventer si n\u00e9cessaire), r\u00e9pondre aux questions suivantes :<ul> <li>Quels sont les caract\u00e8res qui sont sp\u00e9ciaux entre guillemets anglais ?</li> <li>Quel est le r\u00f4le du caract\u00e8re <code>\\</code> entre guillemets anglais ? Dans quel contexte est-il sp\u00e9cial, litt\u00e9ral ?</li> <li>Quels sont les d\u00e9veloppements qui n\u2019ont jamais lieu entre guillemets anglais ?</li> <li>Selon vous, pourquoi avoir cr\u00e9\u00e9 plusieurs m\u00e9canismes d\u2019inhibition ?</li> </ul> </li> </ol>"},{"location":"contenus/tp3/#extensions-de-chemins","title":"Extensions de chemins","text":"<p>Extension de chemins</p> <p>Lorsqu\u2019on saisit un chemin contenant des wildcards ou caract\u00e8res joker (Ref. dernier exo du TP1), le shell le d\u00e9veloppe en rempla\u00e7ant les caract\u00e8res sp\u00e9ciaux <code>*</code>, <code>?</code> et <code>[</code> par les noms des fichiers qui correspondent \u00e0 l\u2019expression r\u00e9guli\u00e8re qui r\u00e9sulte de l\u2019extension du chemin. On appelle ce m\u00e9canisme l\u2019extension de chemin.</p> <p>Par exemple, si le r\u00e9pertoire courant contient les fichiers <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code> et <code>e</code>, alors le chemin <code>a*</code> est d\u00e9velopp\u00e9 en <code>a</code>, le chemin <code>?</code> en <code>a b c d e</code> et le chemin <code>[a-c]</code> en <code>a b c</code>.</p> <p>L\u2019extension de chemin est effectu\u00e9e par le shell, avant que la commande ne soit ex\u00e9cut\u00e9e. Si aucun fichier ne correspond \u00e0 l\u2019expression r\u00e9guli\u00e8re, le shell laisse le chemin tel quel.</p>"},{"location":"contenus/tp3/#exercice-5-des-fichiers-et-des-images","title":"Exercice 5 : Des fichiers et des images \ud83d\udcda\ud83d\udcda","text":"<ol> <li>Cr\u00e9er un r\u00e9pertoire <code>dir</code> et y cr\u00e9er les fichiers vides <code>file-1.txt</code>, <code>file-2.txt</code>, <code>file-3.txt</code>, <code>file-4.txt</code>, <code>file-5.txt</code>, <code>file-6.txt</code>, <code>file-7.txt</code>, <code>file-8.txt</code>, <code>file-9.txt</code>, <code>config-a.txt</code>, <code>file-b.txt</code>.</li> <li>Cr\u00e9er \u00e9galement dans <code>dir</code> les fichiers vides suivants <code>img-1.png</code>, <code>img-2.png</code>, <code>img-3.png</code>, <code>img-4.png</code>, <code>img-5.png</code>, <code>img-6.png</code>, <code>img-7.png</code>, <code>img-8.png</code>, <code>img-9.png</code>.</li> <li>Cr\u00e9er ensuite dans <code>dir</code> deux sous-r\u00e9pertoires <code>files</code> et <code>imgs</code>. </li> <li>En vous aidant de l'extension de chemin et de la commande <code>mv</code>, d\u00e9placer les fichiers <code>.txt</code> dans le r\u00e9pertoire <code>files</code>. Fa\u00eetes de m\u00eame pour les fichiers <code>.png</code> dans le r\u00e9pertoire <code>imgs</code>.</li> <li>Donnez l'expression qui reconnais les fichiers <code>config-a.txt</code> et <code>file-b.txt</code>. Puis supprimez les fichiers correspondants \u00e0 cette expression. (Gr\u00e2ce \u00e0 l'extension de chemin, vous pouvez le faire en une seule commande).</li> <li>Supprimez le r\u00e9pertoire <code>dir</code> et son contenu.</li> </ol>"},{"location":"contenus/tp3/#exercice-6-extension-de-laccolade","title":"Exercice 6 : Extension de l'accolade \ud83d\udcda\ud83d\udcda","text":"<ol> <li>Testez les commandes suivantes <pre><code>$ echo {a,b,c,d}\n$ echo {a..d}\n$ echo {a..d..2}\n$ echo {1,2,3,4,5,6,7,8,9}\n$ echo {1..9}\n$ echo {1..9..2}\n</code></pre></li> <li>Que fait la commande <code>echo {a..d}</code> ? Quel est le r\u00f4le de la virgule <code>,</code> dans l'extension de l'accolade ?</li> <li>Que fait la commande <code>echo {a..d..2}</code> ? Quel est le r\u00f4le du <code>2</code> dans l'extension de l'accolade ?</li> <li>Testez les commandes suivantes, et observez leur r\u00e9sultats. <pre><code>$ echo {a..d}*\n$ echo {a..d}.*\n$ echo {a..d}.txt\n</code></pre></li> <li>Cr\u00e9er un r\u00e9pertoire <code>dir</code>. D\u00e9placez-vous y. En utilisant l'extension de l'accolade, en une seule commande, cr\u00e9er les fichiers vides <code>file-1.txt</code>, <code>file-2.txt</code>, <code>file-3.txt</code>, <code>file-4.txt</code>, <code>file-5.txt</code>, <code>file-6.txt</code>, <code>file-7.txt</code>, <code>file-8.txt</code>, <code>file-9.txt</code>. </li> <li>D\u00e9placez tous les fichiers <code>.txt</code> dans un r\u00e9pertoire <code>dir/files</code>.</li> <li>Cr\u00e9er un r\u00e9pertoire <code>dir/imgs</code>. D\u00e9placez-vous y. En utilisant l'extension de l'accolade, en une seule commande, cr\u00e9\u00e9er les fichiers vides <code>img001.png</code>, <code>img002.png</code>, <code>img003.png</code>, <code>img004.png</code>, <code>img005.png</code>, <code>img006.png</code>, <code>img007.png</code>, <code>img008.png</code>, <code>img009.png</code>.</li> <li>Supprimez le r\u00e9pertoire <code>dir</code> et tout son contenu.</li> </ol>"},{"location":"contenus/tp3/#substitution-de-commande","title":"Substitution de commande","text":"<p>Substitution de commande</p> <p>La substitution de commanande est un m\u00e9canisme qui permet d\u2019ins\u00e9rer le r\u00e9sultat d\u2019une commande dans une cha\u00eene de caract\u00e8res. </p> <p>La substitution de commandes dans une cha\u00eene de caract\u00e8res est une autre facilit\u00e9 offerte par le shell. Elle permet de capturer la sortie d'une commande et de l'assigner \u00e0 une variable ou de l'utiliser comme un argument d'une autre commande. Comme beaucoup de commandes Linux g\u00e9n\u00e8rent une sortie, la substitution de commandes peut \u00eatre tr\u00e8s int\u00e9ressante. </p> <p>Il existe deux syntaxes pour la substitution de commande : la syntaxe ancienne avec les accents graves (<code>`</code>) et la syntaxe moderne avec les parenth\u00e8ses <code>$(...)</code>. L'ancienne syntaxe est d\u00e9conseill\u00e9e car elle ne permet pas d\u2019imbriquer les substitutions de commande. Nous ne la pr\u00e9senterons donc pas ici.</p>"},{"location":"contenus/tp3/#exercice-7-substitution-de-commande-simple","title":"Exercice 7 : Substitution de commande simple \ud83d\udcda","text":"<ol> <li>Testez les commandes suivantes et observez leur r\u00e9sultat: <pre><code>$ date\n$ echo date\n$ echo $(date)\n$ aujourdhui=$(date)\n$ echo $aujourdhui\n$ echo \"Nous sommes le $(date)\"\n</code></pre></li> <li>Que fait la commande <code>echo $(date)</code> ? Quel est le r\u00f4le du <code>$</code> devant la parenth\u00e8se ouvrante <code>(</code> ?</li> <li>Tapez ensuite les commandes suivantes et observez leur r\u00e9sultat: <pre><code>$ prefix=\"Nous sommes le\"\n$ echo $prefix $(date)\n$ echo $prefix $aujourdhui\n$ echo ${prefix} ${aujourdhui}\n$ phrase=${prefix} ${aujourdhui}\n$ phrase=\"${prefix} ${aujourdhui}\"\n$ echo $phrase\n$ echo \"$phrase\"\n</code></pre></li> <li>Pouvez-vous d\u00e9duire le r\u00f4le des guillemets anglais dans la substitution de commande ?</li> <li>Quelle est la diff\u00e9rence entre <code>$(...)</code> et <code>${...}</code> ?</li> </ol>"},{"location":"contenus/tp3/#exercice-8-substitution-de-commande-imbriquee","title":"Exercice 8 : Substitution de commande imbriqu\u00e9e \ud83d\udcda\ud83d\udcda\ud83d\udcda","text":"<ol> <li>Testez les commandes suivantes et observez leur r\u00e9sultat: <pre><code>$ echo $(echo $(date))\n$ echo $(echo $(echo $(date)))\n$ echo $(echo $(echo $(echo $(date))))\n$ echo $(echo $(echo $(echo $(echo $(date)))))\n</code></pre></li> <li>Testez ensuite la commande suivante: <pre><code>$ echo\n</code></pre>     Sans ex\u00e9cuter la commande qui suit saurez vous pr\u00e9dire son r\u00e9sultat ?     <pre><code>$ echo $(echo $(echo $(echo $(echo))))\n</code></pre></li> </ol>"},{"location":"contenus/tp3/#compilation-de-programme-c","title":"Compilation de programme C","text":"<p>Le compilateur C de Linux</p> <p><code>gcc</code> est le compilateur C de Linux. Il permet de compiler du code C. Il est tr\u00e8s utilis\u00e9 par les d\u00e9veloppeurs. Il est tr\u00e8s complet et poss\u00e8de de nombreuses fonctionnalit\u00e9s. Nous allons voir un aper\u00e7u de son utilisation.</p> <p>La compilation d'un programme en C passe par plusieurs \u00e9tapes, qui sont essentiellement les suivantes:</p> <ul> <li>La pr\u00e9compilation : elle permet de transformer le code source en un code interm\u00e9diaire.</li> <li>La compilation : elle permet de transformer le code interm\u00e9diaire en code machine.</li> <li>L'\u00e9dition des liens : elle permet de lier le code machine avec les biblioth\u00e8ques utilis\u00e9es.</li> <li>La cr\u00e9ation de l'ex\u00e9cutable : elle permet de cr\u00e9er l'ex\u00e9cutable.</li> </ul>"},{"location":"contenus/tp3/#exercice-9-le-compilateur-gcc","title":"Exercice 9 - Le compilateur <code>gcc</code> \ud83d\udcda\ud83d\udcda","text":"<ol> <li>Cr\u00e9er un fichier <code>hello.c</code> dont le contenu est le suivant:     <pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    printf(\"Hello world !\\n\");\n    return 0;\n}\n</code></pre></li> <li> <p>Placez-vous ensuite dans le r\u00e9pertoire contenant votre fichier <code>hello.c</code> et tapez la commande <code>gcc hello.c</code>. Cette commande va compiler votre programme et cr\u00e9er un fichier <code>a.out</code> qui est l'ex\u00e9cutable de votre programme. Tapez enfin la commande <code>./a.out</code> pour ex\u00e9cuter votre programme.</p> <p>Attention</p> <ul> <li>Si vous avez d\u00e9j\u00e0 un fichier <code>a.out</code> dans votre r\u00e9pertoire, il sera \u00e9cras\u00e9 par la commande <code>gcc hello.c</code>.</li> <li><code>a.out</code> est le nom par d\u00e9faut de l'ex\u00e9cutable cr\u00e9\u00e9 par <code>gcc</code>. Vous pouvez changer ce nom en utilisant l'option <code>-o</code> de <code>gcc</code>. Par exemple, <code>gcc hello.c -o hello</code> va cr\u00e9er un ex\u00e9cutable <code>hello</code> au lieu de <code>a.out</code>.</li> </ul> </li> <li> <p>R\u00e9cup\u00e9rez ensuite cette archive hello.tar.gz.</p> </li> <li>Extraire les fichiers de cet archive et d\u00e9placez vos dans le r\u00e9pertoire <code>hello</code> qui en sera extrait. Vous pouvez le faire grace \u00e0 la commande suivate: <pre><code>$ tar -xvf hello.tar.gz\n</code></pre></li> <li>Tapez la commande  <pre><code>$ gcc main.c hello.c -o run\n</code></pre> pour compiler votre programme. Cette commande va compiler votre programme et cr\u00e9er un fichier <code>run</code> qui est l'ex\u00e9cutable de votre programme. Ex\u00e9cutez enfin votre programme avec la commande <code>./run</code>. </li> <li>Supprimer le fichier <code>run</code> et modifier ensuite le fichier <code>hello.c</code> de tel sorte \u00e0 avoir volontairement une erreur : supprimer l'accolade fermante de la fonction <code>void hello()</code>. R\u00e9ex\u00e9cutez ensuite les commandes de la question 5. Que remarquez-vous ?</li> <li>Remodifier ensuite le fichier <code>hello.c</code> en remettant l'accolade fermante mais rajouter un <code>return 1</code> dans la d\u00e9finition de la fonction (avant l'accolade fermante). R\u00e9ex\u00e9cutez ensuite les commandes de la question 5. Que remarquez-vous ?</li> <li>Conclure sur la gestion des erreurs et des warnings sur <code>gcc</code>.</li> </ol>"},{"location":"contenus/tp3/#exercice-10-compilation-separee-et-edition-des-liens","title":"Exercice 10 - Compilation s\u00e9par\u00e9e et \u00e9dition des liens \ud83d\udcda\ud83d\udcda\ud83d\udcda","text":"<p>Tip</p> <p>Pour compiler un programme en C, il est possible de le faire en plusieurs \u00e9tapes. On peut d'abord compiler chaque fichier source en un fichier objet, puis \u00e9diter les liens pour cr\u00e9er l'ex\u00e9cutable. Cela permet de gagner du temps lors de la compilation de gros projets.</p> <p>En effet si un seul fichier source est modifi\u00e9, il n'est pas n\u00e9cessaire de recompiler tous les fichiers sources. Il suffit de recompiler le fichier source modifi\u00e9 et de r\u00e9\u00e9diter les liens.</p> <ul> <li>L'option <code>-c</code> de <code>gcc</code> permet de compiler un fichier source en un fichier objet. L'option <code>-o</code> permet de sp\u00e9cifier le nom du fichier objet \u00e0 cr\u00e9er.</li> <li>L'\u00e9dition des liens se fait avec la commande <code>gcc</code> en sp\u00e9cifiant les fichiers objets \u00e0 lier. L'option <code>-o</code> permet de sp\u00e9cifier le nom de l'ex\u00e9cutable \u00e0 cr\u00e9er.</li> </ul> <p>Dans cette configuration, imaginons que nous avons un fichier <code>main.c</code> qui contient la fonction <code>main</code> et un fichier <code>hello.c</code> qui contient la fonction <code>hello</code>. Pour compiler ces deux fichiers en un ex\u00e9cutable <code>run</code>, on peut proc\u00e9der comme suit: <pre><code>$ gcc -c main.c -o main.o # Compilation du fichier main.c en main.o\n$ gcc -c hello.c -o hello.o # Compilation du fichier hello.c en hello.o\n$ gcc main.o hello.o -o run # Edition des liens pour cr\u00e9er l'ex\u00e9cutable run\n</code></pre></p> <ol> <li>Dans le r\u00e9pertoire <code>hello</code>, de l'exercice pr\u00e9c\u00e9dent, cr\u00e9er deux fichiers <code>bye.c</code> et <code>bye.h</code>, en utilisant l'extension de l'accolade, dont les contenus sont les suivants:<ul> <li><code>bye.h</code>: <pre><code>#ifndef BYE_H\n#define BYE_H\n\nvoid bye();\n\n#endif\n</code></pre></li> <li><code>bye.c</code>: <pre><code>#include &lt;stdio.h&gt;\n#include \"bye.h\"\n\nvoid bye()\n{\n    printf(\"I'm done, bye !\\n\");\n}\n</code></pre></li> </ul> </li> <li>Toujours en utilisant l'extension de l'accolade, compiler les deux fichiers <code>hello.c</code> et <code>bye.c</code> en deux fichiers objets <code>hello.o</code> et <code>bye.o</code>. Assurez-vous que le compilateur ne renvoie pas d'erreurs. (Par d\u00e9faut si on ne sp\u00e9cifie pas le nom du fichier de sortie, les fichiers <code>.c</code> sont compil\u00e9s en des fichiers objets de m\u00eame nom)</li> <li>Modifier ensuite le fichier <code>main.c</code> pour afin d'inclure le fichier <code>bye.h</code> et appeler la fonction <code>bye</code> \u00e0 la fin de la fonction <code>main</code>. Le contenu du fichier <code>main.c</code> doit \u00eatre le suivant:     <pre><code>#include &lt;stdio.h&gt;\n#include \"hello.h\"\n#include \"bye.h\"\n\nint main()\n{\n    hello();\n    bye();\n    return 0;\n}\n</code></pre></li> <li>Compiler le fichier <code>main.c</code> en un fichier objet <code>main.o</code>. Assurez-vous que le compilateur ne renvoie pas d'erreurs.</li> <li>En utilisant l'extention de chemin avec le caract\u00e8re <code>*</code>, \u00e9diter les liens pour tous vos fichiers objets afin cr\u00e9er l'ex\u00e9cutable <code>run</code>. Ex\u00e9cutez ensuite votre programme avec la commande <code>./run</code>.</li> </ol>"},{"location":"contenus/tp4-exo/","title":"Exercices en plus (TP4)","text":"<p>Objectifs p\u00e9dagogiques</p> <p>\u00c0 l\u2019issue de ce TP, l\u2019\u00e9tudiant sera capable de :</p> <ul> <li>Renforcer la ma\u00eetrise des redirections et tubes dans le shell.</li> <li>Utiliser les filtres textuels classiques (<code>grep</code>, <code>sort</code>, <code>cut</code>, <code>uniq</code>, <code>tr</code>, <code>head</code>, <code>tail</code>, etc.).</li> <li>Encha\u00eener plusieurs commandes avec des redirections et des tubes.</li> <li>Appliquer des filtres sur des fichiers textuels en combinant des options.</li> <li>Manipuler efficacement les entr\u00e9es/sorties dans des sc\u00e9narios concrets.</li> <li>Approfondir l\u2019utilisation de <code>grep</code> pour rechercher dans des arborescences de fichiers.</li> <li>Apprendre \u00e0 extraire des informations sp\u00e9cifiques de fichiers syst\u00e8me (<code>/etc</code>, <code>/usr/include</code>, etc.).</li> </ul> <p>Indications</p> <p>Les exercices suivants sont des exercices suppl\u00e9mentaires pour vous entra\u00eener et voir d'autres utilisations des tubes et des redirections. </p> <p>Bar\u00e8me d\u2019interpr\u00e9tation des exercices</p> <p>\ud83d\udcda = Facile, \ud83d\udcda\ud83d\udcda = Moyenne, \ud83d\udcda\ud83d\udcda\ud83d\udcda = \u00c9lev\u00e9e </p> <p>Filtres textuels</p> <p>Les filtres textuel sont des commandes qui lisent ou peuvent lire depuis leur entr\u00e9e standard et \u00e9crivent des donn\u00e9es modifi\u00e9es sur leur sortie standard. </p> <p>En voici quelques-uns parmi les plus courants :</p> <ul> <li><code>head</code> : affiche les premi\u00e8res lignes de son entr\u00e9e ;</li> <li><code>tail</code> : affiche les derni\u00e8res lignes de son entr\u00e9e. Avec l\u2019option -f (pour follow, continuer \u00e0 afficher la fin du fichier quand il est mis \u00e0 jour) c\u2019est l\u2019une des commandes pr\u00e9f\u00e9r\u00e9es des administrateurs syst\u00e8mes ;</li> <li><code>grep</code> : une des commandes les plus connues, affiche des lignes correspondant \u00e0 une cha\u00eene, ou plus g\u00e9n\u00e9ralement une expression rationnelle dans son entr\u00e9e ;</li> <li><code>cut</code> : s\u00e9lectionne des champs ou des caract\u00e8res dans chaque ligne de l\u2019entr\u00e9e standard ;</li> <li><code>sort</code> : trie son entr\u00e9e standard suivant des crit\u00e8res.</li> <li><code>tr</code> : remplace des caract\u00e8res dans son entr\u00e9e standard.</li> <li><code>uniq</code> : supprime les lignes cons\u00e9cutives identiques dans son entr\u00e9e standard.</li> </ul>"},{"location":"contenus/tp4-exo/#exercice-1-frere-jacques","title":"Exercice 1 : Fr\u00e8re Jacques \ud83d\udcda","text":"<ol> <li>Cr\u00e9er un fichier <code>fj</code> contenant ces lignes :     <pre><code>Fr\u00e8re Jaques, \nFr\u00e8re Jacques,                    \nDormez-vous,\nDormez-vous,\nSonnez les matines,\nSonnez les matines !\nDing !\nDing ! \nDong !\n</code></pre>     avec la commande <code>echo</code> (le caract\u00e8re <code>&lt;newline&gt;</code> correspond \u00e0 la touche entr\u00e9e de votre clavier):     <pre><code>$ echo 'Fr\u00e8re Jaques,&lt;newline&gt; \n&gt; Fr\u00e8re Jacques,&lt;newline&gt;                     \n&gt; Dormez-vous,&lt;newline&gt; \n&gt; Dormez-vous,&lt;newline&gt; \n&gt; Sonnez les matines,&lt;newline&gt; \n&gt; Sonnez les matines !&lt;newline&gt; \n&gt; Ding !&lt;newline&gt; \n&gt; Ding !&lt;newline&gt; \n&gt; Dong !' &gt; fj\n</code></pre></li> <li>Testez ensuite les commandes suivantes et observez leur r\u00e9sultats:     <pre><code>$ cat fj \n$ head fj\n$ tail fj\n$ head -n 2 fj\n$ tail -n 3 fj\n$ grep \"Dormez\" fj\n$ grep -v \"Dormez\" fj\n$ grep \"dormez\" fj\n$ grep -i \"dormez\" fj\n$ sort fj \n$ uniq fj\n$ cut -c 1 fj\n$ cut -c 2 fj\n$ cut -c 1-3 fj\n$ cut -d ' ' -f 1 fj\n$ cut -d ' ' -f 1,2 fj\n</code></pre><ul> <li>O\u00f9 sont affich\u00e9s les r\u00e9sultats ?</li> <li>\u00c0 quoi servent les options <code>-n</code> de <code>head</code> et <code>tail</code> ? </li> <li>\u00c0 quoi sert l'option <code>-v</code> de <code>grep</code> ? \u00c0 quoi sert l'option <code>-i</code> de <code>grep</code> ?</li> <li>\u00c0 quoi servent les options <code>-c</code> et <code>-d</code> de <code>cut</code> ?</li> </ul> </li> </ol>"},{"location":"contenus/tp4-exo/#exercice-2-trier-les-fichiers","title":"Exercice 2 : Trier les fichiers \ud83d\udcda\ud83d\udcda\ud83d\udcda","text":"<p>Nom de base</p> <p>Le nom de base d'un fichier est le nom du fichier sans son extension. Par exemple le nom de base du fichier <code>/usr/include/stdio.h</code> est <code>stdio</code>.</p> <p>Dans cet exercice, nous voudrions afficher sur le terminal le nom de base des 10 fichiers les plus l\u00e9gers (en taille en octets) parmi les fichier <code>.h</code> du r\u00e9pertoire <code>/usr/include</code>.</p> <p>En utilisant les commandes <code>wc</code>, <code>sort</code>, <code>cut</code>, <code>head</code> (ou \u00e9ventuellement <code>tail</code>), et les redirections par tube, \u00e9crivez une commande qui affiche le nom de base des 10 fichiers les plus l\u00e9gers parmi les fichiers <code>.h</code> du r\u00e9pertoire <code>/usr/include</code>.</p> <p>Indication</p> <ul> <li>L'option <code>-c</code> de <code>wc</code> vous donne le nombre d'octets d'un fichier.</li> <li>L'option <code>-n</code> de <code>sort</code> vous permet de trier les lignes d'un fichier par ordre num\u00e9rique.</li> <li>L'option <code>-d</code> de <code>tr</code> supprime les caract\u00e8res re\u00e7us en premiers argument au lieu de les remplacer.</li> </ul> <p>Si vous avez install\u00e9 <code>gcc</code>, vous devriez avoir : <pre><code>pool\nwait\nsyslog\nsyscall\nlastlog\ntermio\nstab\nmemory\nre_comp\nalloca\n</code></pre></p>"},{"location":"contenus/tp4-exo/#exercice-3-plus-sur-grep","title":"Exercice 3 : Plus sur <code>grep</code> \ud83d\udcda\ud83d\udcda","text":"<p>Passer un r\u00e9pertoire en argument de <code>grep</code></p> <ul> <li>L'option <code>-r</code> de <code>grep</code> permet de passer un r\u00e9pertoire en argument. Et lui demande de chercher dans tous les fichiers de ce r\u00e9pertoire.</li> <li>L'option <code>-l</code> de <code>grep</code> permet de n'afficher que le nom des fichiers qui contiennent la cha\u00eene recherch\u00e9e.</li> </ul> <p>En utilisant <code>grep</code> et \u00e9ventuellement d'autres commandes, trouvez une ligne de commande qui permet de:</p> <ol> <li>Afficher la valeur de <code>RAND_MAX</code> (c'est une constante de la librairie standard de C). </li> <li>Afficher le chemin absolu des fichiers qui contiennent de la cha\u00eene <code>127.0.0.1</code> dans les fichiers de <code>/etc</code>.</li> <li>Afficher uniquement le nom des fichiers qui contiennent de la cha\u00eene <code>127.0.0.1</code> dans les fichiers de <code>/etc</code>. (indice : il existe une commande qui s'appelle <code>rev</code>).</li> <li>Affiche le chemin du r\u00e9pertoire personnel de l'utilisateur <code>games</code>.</li> </ol>"},{"location":"contenus/tp4/","title":"TP4 - Canaux standards et redirections | Processus et t\u00e2ches | Signaux","text":"<p>Objectifs p\u00e9dagogiques</p> <p>\u00c0 l\u2019issue de ce TP, l\u2019\u00e9tudiant sera capable de :</p> <ul> <li>Rediriger les flux standards (entr\u00e9e, sortie, erreur) d\u2019un programme via les op\u00e9rateurs <code>&gt;</code>, <code>&gt;&gt;</code>, <code>&lt;</code>, <code>1&gt;</code>, <code>2&gt;</code>, <code>0&lt;</code></li> <li>Combiner les redirections pour manipuler finement les donn\u00e9es entrantes/sortantes dans le terminal et les fichiers</li> <li>Utiliser les tubes (<code>|</code>) pour encha\u00eener les commandes et automatiser des traitements</li> <li>Observer et analyser les processus via les commandes <code>ps</code>, <code>jobs</code>, <code>top</code>, <code>fg</code>, <code>bg</code>, <code>kill</code>, et comprendre la notion de t\u00e2che dans un shell</li> <li>Distinguer les processus en avant-plan et en arri\u00e8re-plan, les interrompre temporairement ou d\u00e9finitivement</li> <li>Comprendre la notion de signal envoy\u00e9 \u00e0 un processus, son r\u00f4le, son effet, et les diff\u00e9rences entre <code>SIGINT</code>, <code>SIGTERM</code>, <code>SIGTSTP</code>, <code>SIGCONT</code>, <code>SIGKILL</code></li> <li>Identifier un processus \u00e0 partir de son PID ou de son identifiant de t\u00e2che pour interagir avec lui via <code>kill</code></li> <li>Conna\u00eetre les bonnes pratiques pour terminer proprement ou forcer l\u2019arr\u00eat d\u2019un processus</li> <li>D\u00e9velopper un petit programme en C r\u00e9actif aux signaux (via <code>ctrl+C</code>, <code>ctrl+Z</code>, etc.) pour observer en pratique l\u2019effet de ces signaux syst\u00e8me</li> </ul> <p>Instructions</p> <ul> <li>On rappelle que dans tous les exercices le <code>$</code> en d\u00e9but de commande repr\u00e9sente le prompt, il n'est pas \u00e0 saisir lorsque vous \u00e9crivez une ligne de commande.</li> <li>Pour chaque nouvelle commande, n'h\u00e9sitez pas \u00e0 consulter sa page de manuel avec la commande <code>man</code>, ou \u00e0 utiliser l'option <code>--help</code> (si elle est disponible) pour savoir ce qu'elle fait.</li> <li>N'h\u00e9sitez pas \u00e0 reconsulter les anciens TP pour vous aider.</li> </ul> <p>Bar\u00e8me d\u2019interpr\u00e9tation des exercices</p> <p>\ud83d\udcda = Facile, \ud83d\udcda\ud83d\udcda = Moyenne, \ud83d\udcda\ud83d\udcda\ud83d\udcda = \u00c9lev\u00e9e </p>"},{"location":"contenus/tp4/#canaux-standards-et-redirections","title":"Canaux standards et redirections","text":"<p>Redirection de la sortie standard</p> <p>La plupart des commandes que nous avons \u00e9tudi\u00e9es \u00e9crivent leur r\u00e9sultat sur le terminal. Par exemple <code>ls, echo, cat,...</code>. On dit que ces commandes \u00e9crivent sur la sortie standard (qui est connect\u00e9e au terminal) </p> <p>Il est possible de rediriger la sortie standard vers un fichier en utilisant le caract\u00e8re <code>&gt;</code>. Par exemple : <pre><code>$ ls ~ # affiche le contenu du r\u00e9pertoire personnel sur la sortie standard\n$ ls ~ &gt; list_files.txt # redirige la sortie standard vers le fichier list_files\n</code></pre></p> <p>Attention</p> <p>La redirection de la sortie standard va cr\u00e9er le fichier <code>list_files.txt</code> s'il n'existe pas.</p> <p>La redirection \u00e9crase le contenu d'un fichier existant. Si on veut ajouter le r\u00e9sultat \u00e0 la fin du fichier, on utilise le caract\u00e8re <code>&gt;&gt;</code>.</p>"},{"location":"contenus/tp4/#exercice-1-redirection-de-la-sortie-standard","title":"Exercice 1 : Redirection de la sortie standard \ud83d\udcda","text":"<ol> <li>Testez les commandes suivantes et observez leur r\u00e9sultats. <pre><code>$ echo \"Est-ce que j'apparais sur le terminal ?\"\n$ echo \"Ou bien dans le fichier ?\" &gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Et moi ?\" &gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je ne veux pas vider le fichier\" &gt;&gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je veux vider le fichier\" 1&gt; fichier.txt\n$ cat fichier.txt\n$ echo \"Je m'ajoute en fin de ligne\" 1&gt;&gt; fichier.txt\n</code></pre></li> <li> <p>Rappeler ce que fait la commande <code>cat</code> (man <code>cat</code>) puis \u00e0 partir des r\u00e9sultats des commandes pr\u00e9c\u00e9dentes:</p> <ul> <li>Quelle est la diff\u00e9rence entre <code>&gt;</code> et <code>&gt;&gt;</code> ?</li> <li>Quelle est la diff\u00e9rence entre <code>1&gt;</code> et <code>&gt;</code> ?</li> <li>Quelle est la diff\u00e9rence entre <code>1&gt;&gt;</code> et <code>&gt;&gt;</code> ?</li> </ul> </li> <li> <p>Placez-vous dans votre r\u00e9pertoire personnel et ex\u00e9cutez la commande suivante :     <pre><code>$ ls &gt; list_files.txt; cat list_files.txt\n</code></pre></p> <ul> <li>Que fait cette commande ?</li> <li>Pouvez-vous expliquer pourquoi la cha\u00eene <code>list_files.txt</code> appara\u00eet dans le fichier <code>list_files.txt</code> ?</li> </ul> </li> </ol>"},{"location":"contenus/tp4/#exercice-2-compter-les-entetes-1","title":"Exercice 2 : Compter les ent\u00eates (1) \ud83d\udcda\ud83d\udcda","text":"<ol> <li>En vous aidant de la redirection de la sortie standard, cr\u00e9er un fichier <code>include_files.txt</code> qui liste tous les fichiers du r\u00e9pertoire <code>/usr/include</code> dont le nom se termine par <code>.h</code>.</li> <li>Compter le nombre de fichiers <code>.h</code> dans le r\u00e9pertoire <code>/usr/include</code> (indice : <code>wc</code>).</li> <li>Enfin ajouter la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire /usr/include</code> \u00e0 la fin du fichier <code>include_files.txt</code>.</li> </ol>"},{"location":"contenus/tp4/#exercice-3-redirection-de-lerreur-standard","title":"Exercice 3 : Redirection de l'erreur standard \ud83d\udcda\ud83d\udcda","text":"<ol> <li>Dans un r\u00e9pertoire <code>dir</code> cr\u00e9er un fichier <code>file-1.txt</code> dont le contenu est <code>Hello world !</code>.</li> <li>Cr\u00e9er ensuite une copie de <code>file-1.txt</code> nomm\u00e9e <code>file-2.txt</code>. Retirez toutes les permissions de lecture sur <code>file-2.txt</code>.</li> <li>Tapez ensuite la commande suivante et notez les r\u00e9sultats (on va avoir des erreur !) :     <pre><code>$ cat file-1.txt file-2.txt file-3.txt\n</code></pre></li> <li>Quelles commande a r\u00e9ussi ? et quelles commandes ont \u00e9chou\u00e9 et pourquoi ?</li> <li>Faites ensuite une redirection de la sortie standard de la commande pr\u00e9c\u00e9dente vers un fichier <code>result.txt</code>. Observez le ce qui est affich\u00e9 sur le terminal, et observer le contenu du fichier <code>result.txt</code>.</li> <li>Tapez ensuite la commande suivante et notez les r\u00e9sultats :     <pre><code>$ cat file-1.txt file-2.txt file-3.txt 1&gt; result.txt 2&gt; error.txt\n</code></pre></li> <li>Observez les contenus de <code>result.txt</code> et <code>error.txt</code>. Que contiennent-ils ? \u00c0 votre avis que signifie <code>1&gt;</code> et <code>2&gt;</code> ? Tirez-en une conclusion sur la diff\u00e9rence entre la sortie standard et l'erreur standard.</li> </ol> <p>Redirection de l'entr\u00e9e standard</p> <p>Certaines commandes lisent des informations sur le terminal. Par exemple <code>tr, read,...</code>. On dit que ces commandes lisent sur l'entr\u00e9e standard (qui est aussi connect\u00e9e au terminal).</p> <p>Mais beaucoup de commandes lisent \u00e9galement sue le terminal si aucun nom de fichier leur est donn\u00e9 en argument. Par exemple <code>cat, grep, sort,...</code>.</p> <p>Il est possible de rediriger l'entr\u00e9e standard d'une commande vers un fichier en utilisant le caract\u00e8re <code>&lt;</code>. Par exemple : <pre><code>$ cat &lt; fichier.txt\n</code></pre> Cette commande affiche le contenu du fichier <code>fichier.txt</code> sur la sortie standard. On dit que le fichier <code>fichier.txt</code> est connect\u00e9 \u00e0 l'entr\u00e9e standard de la commande <code>cat</code>.</p> <p>Attention</p> <p>Il faut que le fichier <code>fichier.txt</code> existe et qu'on ait la permission <code>read</code> sinon la commande <code>cat</code> va \u00e9chouer.</p>"},{"location":"contenus/tp4/#exercice-4-retour-sur-la-commande-cat","title":"Exercice 4 : Retour sur la commande <code>cat</code> \ud83d\udcda\ud83d\udcda","text":"<ol> <li>Revoyez le manuel de la commande <code>cat</code> et trouvez comment elle fonctionne lorsque l'on ne lui donne pas de fichier en argument.</li> <li> <p>Testez ensuite la commande suivante:    <pre><code>$ cat\nhello&lt;newline&gt;\nworld&lt;newline&gt;\nC-d # appuyer sur la touche Ctrl et la touche d en m\u00eame temps\n</code></pre>     Combien d'argument la commande <code>cat</code> a-t-elle re\u00e7u ? Qu'a-t-elle affich\u00e9 ? Pourquoi ?</p> </li> <li> <p>Testez ensuite la commande suivante:    <pre><code>$ cat &gt; catout.txt\nhello&lt;newline&gt;\nworld&lt;newline&gt;\nC-d # appuyer sur la touche Ctrl et la touche d en m\u00eame temps\n</code></pre>     Puis affichez le contenu du fichier <code>catout.txt</code>. Que contient-il ? Pourquoi ?</p> </li> <li>Tapez enfin la commande suivante :     <pre><code>$ cat &lt; catout.txt\n$ cat 0&lt; catout.txt\n</code></pre><ul> <li>Combien d'argument la commande <code>cat</code> a-t-elle re\u00e7u ? Qu'a-t-elle affich\u00e9 ?</li> <li>Quelle est la diff\u00e9rence entre <code>&lt;</code> et <code>0&lt;</code> ?</li> </ul> </li> </ol>"},{"location":"contenus/tp4/#exercice-5-compter-les-entetes-2","title":"Exercice 5 : Compter les ent\u00eates (2) \ud83d\udcda\ud83d\udcda\ud83d\udcda","text":"<p>Nous allons refaire le m\u00eame exercice que l'exercice 2 mais cette fois-ci en utilisant la redirection de l'entr\u00e9e standard.</p> <ol> <li>Cr\u00e9er un fichier <code>include_files.txt</code> qui liste tous les fichiers du r\u00e9pertoire <code>/usr/include</code> dont le nom se termine par <code>.h</code>.</li> <li>Tapez ensuite la commande suivante et commentez son r\u00e9sultat:     <pre><code>$ wc -l &lt; include_files.txt\n</code></pre></li> <li>Entrez ensuite la commande suivante et commentez son r\u00e9sultat:     <pre><code>$ wc -l &lt; include_files.txt &gt;&gt; include_files.txt\n</code></pre>     et observez la derni\u00e8re ligne du fichier <code>include_files.txt</code>.</li> <li> <p>Nous voudrions enfin que la derni\u00e8re ligne du fichier <code>include_files.txt</code> soit la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire /usr/include</code>. O\u00f9 <code>&lt;nombre&gt;</code> est le r\u00e9sultat de <code>wc -l &lt; include_files.txt</code>.</p> <p>Trouvez une commande qui permet de faire cela en utilisant \u00e0 la fois la redirection de la sortie standard et de l'entr\u00e9e standard.</p> <p>Indice</p> <ul> <li>Pour retirer la derni\u00e8re ligne, on peut refaire la commande de la premi\u00e8re question.</li> <li>Ensuite pensez \u00e0 la commande <code>echo</code> et la subsutitution de commande.</li> </ul> </li> </ol>"},{"location":"contenus/tp4/#les-tubes","title":"Les tubes","text":"<p>Tubes</p> <p>Un tube (pipe en anglais) est un m\u00e9canisme qui permet de connecter la sortie standard d'une commande \u00e0 l'entr\u00e9e standard d'une autre commande. On utilise le caract\u00e8re <code>|</code> pour cr\u00e9er un tube.</p> <p>C'est-\u00e0-dire que pour <pre><code>$ cmd1 | cmd2\n</code></pre> La sortie standard de <code>cmd1</code> est connect\u00e9e \u00e0 l'entr\u00e9e standard de <code>cmd2</code>.</p>"},{"location":"contenus/tp4/#exercice-6-compter-les-entetes-promis-cest-la-derniere-fois","title":"Exercice 6 : Compter les ent\u00eates (promis c'est la derni\u00e8re fois) \ud83d\udcda\ud83d\udcda","text":"<ol> <li>Testez la commande suivante et commentez son r\u00e9sultat :     <pre><code>$ ls /usr/include/*.h | wc -l\n</code></pre>     O\u00f9 est redirig\u00e9 le r\u00e9sultat de la commande <code>ls</code> ? O\u00f9 est redirig\u00e9 l'entr\u00e9e standard de la commande <code>wc</code> ? O\u00f9 est affich\u00e9 le r\u00e9sultat de <code>wc</code>?</li> <li>Affichez ensuite sur le terminal la phrase <code>Il y a &lt;nombre&gt; fichiers .h dans le r\u00e9pertoire /usr/include</code> en utilisant la commande <code>echo</code> et la substitution de commande (indice la commande \u00e0 utiliser et celle de la question 1).    </li> <li>Enfin, entrez la commande suivante et commentez son r\u00e9sultat :     <pre><code>wc -l $(ls /usr/include/*.h)\n</code></pre></li> <li>\u00c0 votre avis pourquoi le r\u00e9sultat de la derni\u00e8re commande est-il diff\u00e9rent de celui de la question 1 ?</li> </ol>"},{"location":"contenus/tp4/#processus-et-taches","title":"Processus et t\u00e2ches","text":"<p>Processus et t\u00e2ches</p> <p>Un processus est une unit\u00e9 de travail sur un syst\u00e8me d'exploitation. Il peut s'agir d'un programme, d'un script, ou d'un service. Chaque programme que vous ex\u00e9cutez repr\u00e9sente un ou plusieurs processus. Chaque processus est identifi\u00e9 par un num\u00e9ro unique appel\u00e9 PID (Process IDentifier). </p> <p>Linux nous offre plusieurs commandes pour visualiser les processus en cours d'ex\u00e9cution.</p> <ul> <li><code>ps</code> permet d'afficher les processus en cours d'ex\u00e9cution. Par d\u00e9faut, <code>ps</code> n'affiche que les processus lanc\u00e9s par l'utilisateur courant. Pour afficher tous les processus, on utilise l'option <code>-e</code> (ou <code>-A</code>).</li> <li><code>top</code> permet d'afficher les processus en cours d'ex\u00e9cution. Il peut s'utiliser de mani\u00e8re interactive notamment les trier par utilisation du CPU. On peut quitter <code>top</code> avec la touche <code>q</code>.</li> </ul> <p>Une t\u00e2che par contre est une unit\u00e9 de travail du shell. Une t\u00e2che peut \u00eatre un processus, ou un groupe de processus mais il faut qu'il ait \u00e9t\u00e9 lanc\u00e9 par le shell. Le shell a un syst\u00e8me de contr\u00f4le de t\u00e2ches : c'est la capacit\u00e9 \u00e0 ex\u00e9cuter plusieurs commandes en m\u00eame temps. On peut lancer une commande en arri\u00e8re-plan et en avant-plan. </p> <p>La commande <code>jobs</code> permet d'afficher les t\u00e2ches en cours d'ex\u00e9cution.</p> <p>En somme</p> <p>Une t\u00e2che est un processus, mais un processus n'est pas forc\u00e9ment une t\u00e2che.</p>"},{"location":"contenus/tp4/#exercice-7-processus-et-taches","title":"Exercice 7 - Processus et t\u00e2ches \ud83d\udcda\ud83d\udcda\ud83d\udcda","text":"<ol> <li> <p>Dans cet exercice nous allons simuler l'ex\u00e9cution d'un processus long. Pour cela, nous allons utiliser la commande <code>sleep</code> qui permet de mettre en pause l'ex\u00e9cution d'un script pendant un certain temps. Tapez la commande <code>sleep 10</code> et observez ce qu'il se passe.</p> <p>Informations de la commande <code>ps</code><p>La commande <code>ps</code> retourne la liste des processus en cours d'ex\u00e9cution. Cette liste contient quatre colonnes par d\u00e9faut.</p> <ul> <li>La premi\u00e8re colonne correspond au PID (Process IDentifier) du processus.</li> <li>La deuxi\u00e8me colonne correspond au TTY (TeleTYpewriter) sur lequel le processus est lanc\u00e9. C'est le type de terminal utilis\u00e9 pour lancer le processus. Ici <code>pts/1</code> (pseudo-terminal slave) signifie que le processus a \u00e9t\u00e9 lanc\u00e9 dans un pseudo-terminal. Le chiffre renseign\u00e9 correspond au num\u00e9ro du terminal (par exemple si vous avez plusieurs instances du terminal ouverts).</li> <li>La troisi\u00e8me colonne correspond au TIME (temps) d'ex\u00e9cution du processus.</li> <li>La quatri\u00e8me colonne correspond \u00e0 la CMD (CoMmanDe) qui a lanc\u00e9 le processus.</li> </ul> </p> </li> <li> <p>Ensuite testez les commandes suivantes et commentez les r\u00e9sultats:     <pre><code>$ ps\n$ sleep 240\n$ C-z # Control + z\n$ ps\n$ fg %1 # fg %&lt;num\u00e9ro de la t\u00e2che&gt;\n$ C-c # Control + c\n$ ps\n</code></pre></p> <ul> <li>\u00c0 votre avis que fait le raccourci clavier <code>C-z</code> ? et le raccourci clavier <code>C-c</code> ?</li> <li>Refaites les commandes en tapant des commandes (ou tout autre chose dans le terminal) entre le <code>sleep 240</code> et le <code>C-z</code>. Que remarquez-vous ?</li> <li>Sans passer par <code>help fg</code>, pouvez-vous deviner ce que fait la commande <code>fg %1</code> ? et la commande <code>fg</code> de mani\u00e8re g\u00e9n\u00e9rale ?</li> <li>Refaites les commandes en notant \u00e0 chaque fois le PID du processus <code>sleep 240</code> dans les sorties de <code>ps</code>. Que remarquez-vous ?</li> </ul> </li> <li> <p>Ecrire un programme en C qui incr\u00e9mente ind\u00e9finiment une variable <code>i</code>, et affiche sa valeur sur la sortie standard \u00e0 chaque fois que <code>i</code> est un multiple de 100. Pensez \u00e0 utiliser la commande <code>sleep</code> pour ralentir l'ex\u00e9cution du programme et voir quelque chose sur le terminal. </p> <p>O\u00f9 est sleep ?</p> <p>Tapez la commande <code>man 3 sleep</code> pour voir o\u00f9 se trouve la fonction <code>sleep</code> dans la biblioth\u00e8que standard de C.</p> </li> <li> <p>Compilez le programme et nommer votre ex\u00e9cutable <code>compteur</code>. Puis testez les commandes suivantes et commentez les r\u00e9sultats:</p> <pre><code>$ ./compteur\n$ C-z\n$ jobs \n$ jobs -p # Notez le PID \n$ ps\n$ fg %1\n$ C-z\n$ bg %1\n$ fg %1 # Ne vous inqui\u00e9tez pas, tapez tout simplement la commande correctement\n$ C-z\n$ jobs\n% fg %1\n$ C-c\n$ jobs\n</code></pre> <ul> <li>Quels proc\u00e9d\u00e9s permettent de placer un processus en arri\u00e8re-plan ? et en avant-plan ?</li> <li>Quelle est la diff\u00e9rence entre <code>C-z</code> et <code>C-c</code> ?</li> <li>\u00c0 quoi sert l'option <code>-p</code> de la commande <code>jobs</code> ?</li> <li>Sans passer par <code>help bg</code>, pouvez-vous deviner ce que fait la commande <code>bg</code> de mani\u00e8re g\u00e9n\u00e9rale ?</li> <li>Quels sont les diff\u00e9rents \u00e9tats des t\u00e2ches que vous avez observ\u00e9 ?</li> </ul> </li> </ol>"},{"location":"contenus/tp4/#envoyer-des-signaux-a-un-processus","title":"Envoyer des signaux \u00e0 un processus","text":"<p>Communiquer avec les processus</p> <p>Lorsque des processus ont \u00e9t\u00e9 lanc\u00e9s, nous avons remarqu\u00e9 qu'ils peuvent \u00eatre arr\u00eates, red\u00e9marr\u00e9s et tu\u00e9s. Pour cela, nous avons utilis\u00e9 les commandes <code>C-z</code>, <code>C-c</code>, <code>fg</code> et <code>bg</code>. Ces commandes permettent de communiquer avec les processus en cours d'ex\u00e9cution. En r\u00e9alit\u00e9, ces derni\u00e8res envoient ce qu'on appelle des signaux aux processus. Un signal est un message envoy\u00e9 \u00e0 un processus pour lui demander de faire quelque chose. </p> <p>La commande qui permet d'envoyer des signaux \u00e0 un processus est <code>kill</code>. Cette commande n\u00e9cessite le PID du processus \u00e0 qui envoyer le signal (ou son num\u00e9ro de t\u00e2che si c'en est une). Ainsi <code>C-z</code>, <code>C-c</code>, <code>fg</code> et <code>bg</code> font donc appel \u00e0 la commande <code>kill</code> pour envoyer des signaux aux processus.</p> <p>Il existe plusieurs signaux, les plus courants sont les suivants:</p> <ul> <li><code>SIGINT</code> : signal envoy\u00e9 par la combinaison de touches <code>C-c</code>. Il demande au processus de s'arr\u00eater.</li> <li><code>SIGTSTP</code> : signal envoy\u00e9 par la combinaison de touches <code>C-z</code>. Il demande au processus de se mettre en pause.</li> <li><code>SIGCONT</code> : signal envoy\u00e9 par les commandes <code>bg</code> et <code>fg</code>. Il demande au processus de reprendre son ex\u00e9cution.</li> <li><code>SIGTERM</code> : signal envoy\u00e9 par la commande <code>kill</code> par d\u00e9faut. Il demande au processus de s'arr\u00eater.</li> <li><code>SIGKILL</code> : Il demande au processus de s'arr\u00eater imm\u00e9diatement et provoque son arr\u00eat brutal, comprenez par l\u00e0 que le processus n'a pas le temps de se terminer correctement. Il est donc d\u00e9conseill\u00e9 d'utiliser ce signal.</li> </ul> <p>La liste exhaustive des signaux est disponible est obtenu avec commande <code>kill -L</code>.</p> <p>Qui a le droit d'envoyer des signaux \u00e0 un processus ?</p> <p>Pour pouvoir affecter un processus, vous devez biensur en \u00eatre le prorpi\u00e9taire ou \u00eatre root.</p>"},{"location":"contenus/tp4/#exercice-8-la-commande-kill","title":"Exercice 8 - La commande <code>kill</code> \ud83d\udcda\ud83d\udcda\ud83d\udcda","text":"<ol> <li> <p>Tapez la commande <code>kill -L</code> et notez les num\u00e9ros associ\u00e9s aux signaux <code>SIGINT</code>, <code>SIGTSTP</code>, <code>SIGCONT</code>, <code>SIGTERM</code> et <code>SIGKILL</code>.</p> </li> <li> <p>On peut utiliser le caract\u00e8re <code>&amp;</code> \u00e0 la fin de la commande pour directement lancer les t\u00e2ches en arri\u00e8re-plan. Lancez alors 3 processus <code>./compteur</code> en arri\u00e8re-plan et testez les commandes suivantes:</p> <pre><code>$ ./compteur 1 &amp; # ce sera notre processus 1\n$ ./compteur 2 &amp; # ce sera notre processus 2\n$ ./compteur 3 &amp; # ce sera notre processus 3\n$ jobs -p # notez les PID des processus, mais ils ont d\u00fb \u00eatre affich\u00e9s \u00e0 l'\u00e9cran lors de leur lancement\n$ kill -SIGTSTP &lt;PID du processus 1&gt;\n$ jobs\n$ kill -SIGINT %2\n$ jobs\n$ jobs # oui une deuxi\u00e8me fois\n$ kill -SIGCONT %1\n$ jobs\n$ kill -s SIGTERM &lt;PID processus 1&gt;\n$ jobs\n$ kill -9 &lt;PID du processus 3&gt;\n$ jobs\n$ jobs # pour voir dispara\u00eetre la t\u00e2che [3]\n</code></pre> </li> <li> <p>Selon vous quel est la diff\u00e9rence entre <code>SIGINT</code> et <code>SIGTSTP</code> ? et entre <code>SIGTSTP</code> et <code>SIGTERM</code> ?</p> </li> <li>D'apr\u00e8s vos observations sur les r\u00e9sultats de la question 2, de combien de mani\u00e8re diff\u00e9rente peut-on utiliser la commande <code>kill</code> pour arriver au m\u00eame r\u00e9sultat ?</li> </ol>"}]}