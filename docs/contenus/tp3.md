---
title: TP3 - Environnement de travail et Compilateur C
---

# TP3 - Environnement de travail et Compilateur C

!!! objectifs "Objectifs pÃ©dagogiques"

    Ã€ lâ€™issue de ce TP, lâ€™Ã©tudiant sera capable de :

    - Comprendre la notion de **variables dans un shell** et manipuler leur affectation et leur dÃ©veloppement
    - Identifier et utiliser les **caractÃ¨res spÃ©ciaux** du shell et les **mÃ©canismes dâ€™inhibition** (`\`, `'`, `"`)
    - Utiliser des **expressions avec jokers (wildcards)** et les extensions de chemins pour manipuler efficacement des ensembles de fichiers
    - Manipuler lâ€™**extension dâ€™accolades** dans des expressions shell
    - Utiliser la **substitution de commande** pour capturer dynamiquement le rÃ©sultat d'une commande
    - Savoir compiler un programme en C avec `gcc` et identifier les **erreurs de compilation** et les interprÃ©ter


!!! info "Instructions"
    - On rappelle que dans tous les exercices le `$` en dÃ©but de commande reprÃ©sente le prompt, il n'est pas Ã  saisir lorsque vous Ã©crivez une ligne de commande.
    - Pour chaque nouvelle commande, n'hÃ©sitez pas Ã  consulter sa page de manuel avec la commande `man`, ou Ã  utiliser l'option `--help` (si elle est disponible) pour savoir ce qu'elle fait.


!!! tip "BarÃ¨me dâ€™interprÃ©tation des exercices"

    > ğŸ“š = Facile, ğŸ“šğŸ“š = Moyenne, ğŸ“šğŸ“šğŸ“š = Ã‰levÃ©e 


## Les variables du shell

!!! tip "DÃ©finition et utilisation"
    
    Une variable est un nom qui est associÃ© Ã  une valeur. En shell, les variables sont des chaÃ®nes de caractÃ¨res.
    Le **dÃ©veloppement** dâ€™une variable est le remplacement du nom de la variable par sa valeur.

    Par exemple, la variable `PS1` est la variable qui contient le prompt du shell. Lors des TP prÃ©cÃ©dents, quand vous tapiez
    la commande `PS1='$ '`, vous avez affectÃ© la chaÃ®ne `$<space>` Ã  la variable `PS1`. Lorsque le shell affiche le prompt, il dÃ©veloppe la variable `PS1` et affiche la chaÃ®ne `$<space>`. 
    
    Les variables du shell sont des variables dâ€™environnement. Elles sont accessibles Ã  tous les processus lancÃ©s par le shell. On peut les lister avec la commande `env` ou `printenv`. On peut Ã©galement les lister avec la commande `set` qui liste Ã©galement les variables internes du shell (voir la page de manuel de `set` pour plus de dÃ©tails).
---
### Exercice 1 : Les variables du Shell ğŸ“š
1. Tapez les commandes suivantes dans un terminal:
```bash
$ nom_fich=hello.c
$ echo nom_fich
$ echo $nom_fich
$ echo ${nom_fich}
$ touch $nom_fich
$ echo $nom_fichpp
$ echo ${nom_fich}pp
$ rm ${nom_fich}
```
1. Rappelez ce que fait la commande `echo`. Ã€ votre avis, Ã  quoi sert le caractÃ¨re `$` devant le nom de la variable `nom_fich`?
2. Que se passe-t-il si on demande au shell d'afficher le contenu d'une variable qui n'existe pas?
3. Que se passe-t-il si vous mettez un espace entre le nom de la variable et le signe Ã©gal `=`? Et entre le signe Ã©gal et la valeur?
4. Entrez les commandes suivantes et essayez de commenter leur effet:
```bash
$ sujet=Alice verbe=aime cod=piscine
$ phrase="$sujet $verbe la $cod."
$ echo $phrase
$ sujet=Bob verbe=mange cod=salade
$ echo $phrase
$ echo "$sujet $verbe la $cod."
```

## CaractÃ¨res spÃ©ciaux et inhibitions
!!! tip "CaractÃ¨res spÃ©ciaux du shell"
    Certains caractÃ¨res ont une signification particuliÃ¨re pour le shell : on dit quâ€™ils sont *spÃ©ciaux*. Ã€ lâ€™inverse, on dit dâ€™un caractÃ¨re qui nâ€™a pas dâ€™autre signification que lui-mÃªme, quâ€™il a son sens *littÃ©ral*. Nous listons ci-dessous les caractÃ¨res spÃ©ciaux ; la plupart dâ€™entre eux seront vus en dÃ©tail plus tard dans le cours.
    
    - `; <newline> | &` ils mettent fin Ã  la commande qui les prÃ©cÃ¨de. On a utilisÃ© `<newline>` pour reprÃ©senter le caractÃ¨re *nouvelle ligne* quâ€™on saisit avec la touche EntrÃ©e. Le caractÃ¨re spÃ©cial `|` est saisi avec la combinaison de touches `Alt Gr-6` (`Option-Shift-l` sous mac), on lâ€™appelle *pipe* ou *conduite*. Le caractÃ¨re spÃ©cial `&` est saisi avec la combinaison de touches `Alt Gr-8` et sert Ã  lancer des commandes en arriÃ¨re-plan.
    - `< >` appelÃ©s chevrons, ils permettent les *redirections*.
    - `( )` pour regrouper des commandes et les lancer dans un sous-shell.
    - `$` pour le dÃ©veloppement de variables, le dÃ©veloppement arithmÃ©tique et la substitution de commande.
    - `` ` `` lâ€™accent grave (en anglais, *backtick* ou *backquote*) pour la substitution de commandes (ancienne syntaxe). Il est saisi au clavier avec la combinaison de touches `Alt Gr-7` suivie dâ€™un espace.
    - `<space> <tab>` dÃ©limitent les noms de commandes et arguments.
    - `\ ' "` la contre-oblique (aussi appelÃ©e *backslash* ou *antislash*), lâ€™apostrophe (en anglais *single quote*) et le guillemet anglais (en anglais *double quote*) qui permettent justement dâ€™inhiber les caractÃ¨res spÃ©ciaux, câ€™est-Ã -dire leur rendre leur sens littÃ©ral.

    Enfin, les caractÃ¨res suivants ont une signification particuliÃ¨re dans certains contextes et doivent donc parfois Ãªtre inhibÃ©s:

    -  `* ? ]` Pour le dÃ©veloppement de noms de chemins.
    - `#` Pour Ã©crire des commentaires (sauf sâ€™il est au milieu dâ€™un mot).
    - `~` Pour le dÃ©veloppement du tilde (rÃ©pertoire personnel).
    - `=` Pour lâ€™affectation de variables.
    - `%` Pour le contrÃ´le des tÃ¢ches (job control).
---

### Exercice 2 : Inhibition de caractÃ¨res spÃ©ciaux (la contre-oblique `\`) ğŸ“š
1. Testez les commandes suivantes.
```bash
$ echo a b
$ echo a\ \ \ b
$ touch fichier\ vide
$ rm fichier vide
$ rm fichier\ vide
$ echo 3$canadiens
$ echo 3\$canadiens
$ echo ; echo *
$ echo \; echo \*
$ echo "salut"
$ echo \"salut\"
$ echo 'salut'
$ echo \'salut\'
$ echo \
$ echo \\
```
2. En vous rÃ©fÃ©rent aux questions prÃ©cÃ©dentes, rÃ©pondez aux questions ci dessous:
    - Que fait le caractÃ¨re `\` devant un autre caractÃ¨re que `<newline>` (on rappelle que le caractÃ¨re `<newline>` est celui qui rÃ©sulte de l'appui de la touche EntrÃ©e du clavier) ?
    - Ã€ quoi sert la chaÃ®ne de caractÃ¨res `\<newline>` ?
    - Comment peut-on obtenir un caractÃ¨re `\` littÃ©ral ? Comment afficher `\\` Ã  l'aide de la commande `echo` ?

### Exercice 3 : Lâ€™inhibition des caractÃ¨res spÃ©ciaux (l'apostrophe `'`) ğŸ“šğŸ“š
!!! info "Remarque"
    L'option `-i` de la commande `rm` permet de demander une confirmation avant la suppression.

1. Tester les commandes suivantes :  
```bash
$ touch 'ceci est un horrible nom de fichier'
$ rm -i ceci est un horrible nom de fichier
$ rm -i 'ceci est un horrible nom de fichier'
$ touch p; echo le caractÃ¨re * est-il spÃ©cial ? et ?
$ echo 'le caractÃ¨re * est-il spÃ©cial ? et ?'
$ echo 'en fait, mÃªme la fin de ligne<newline>est un caractÃ¨re normal entre<newline>apostrophes'
$ echo 'le seul caractÃ¨re spÃ©cial entre apostrophes n'est-il pas apostrophe ?'
```
    oÃ¹ `<newline>` sera Ã  taper avec la touche EntrÃ©e de votre clavier.

2. Au vu des expÃ©riences prÃ©cÃ©dentes (et dâ€™autres Ã  inventer si nÃ©cessaire), rÃ©pondre aux questions suivantes :
    - Quels sont les caractÃ¨res qui sont spÃ©ciaux entre apostrophes ?
    - Comment obtenir une apostrophe dans une chaÃ®ne entre apostrophes (question piÃ¨ge) ?
    - Comment, avec une combinaison de chaÃ®nes entre apostrophes et dâ€™une inhibition par contre-oblique, obtenir avec `echo` lâ€™affichage suivant ?
    ```bash
    Un dÃ©veloppement de variable (comme $var) peut-il s'inhiber; par exemple entre apostrophes ?
    ```

### Exercice 4 : Lâ€™inhibition des caractÃ¨res spÃ©ciaux (les guillemets anglais `"`) ğŸ“šğŸ“š

1. Tester les commandes suivantes et notez vos observation:
```bash
$ echo "? * et [ sont utilisÃ©s pour le dÃ©veloppement de chemins"
$ echo "~ provoque un dÃ©veloppement du tilde"
$ echo " Entre \" , on peut aussi <newline>Ã©crire sur plusieurs<newline> lignes"
$ nom=Alice
$ echo '$nom scripte en shell'
$ echo "$nom scripte en shell"
$ echo "\$nom scripte en shell"
$ echo "le chemin absolu du rÃ©pertoire courant est `pwd`"
$ echo "le chemin absolu du rÃ©pertoire courant est \`pwd\`"
$ echo "le chemin absolu du rÃ©pertoire courant est $(pwd)"
$ echo "le chemin absolu du rÃ©pertoire courant est \$(pwd)"
$ echo "Aussi sÃ»r que 2 et 2 font $((2 + 2))"
$ echo "Aussi sÃ»r que 2 et 2 font \$((2 + 2))"
$ echo "\\\\\"\$\`\*\'"
```
2. Testez les commande suivantes et notez vos observations:
```bash
$ mavar="Alice<newline> et<newline>Bob"
$ echo $mavar font plein de choses
$ echo "$mavar font plein de choses"
```
3. Au vu des expÃ©riences prÃ©cÃ©dentes (et dâ€™autres Ã  inventer si nÃ©cessaire), rÃ©pondre aux questions suivantes :
    - Quels sont les caractÃ¨res qui sont spÃ©ciaux entre guillemets anglais ?
    - Quel est le rÃ´le du caractÃ¨re `\` entre guillemets anglais ? Dans quel contexte est-il spÃ©cial, littÃ©ral ?
    - Quels sont les dÃ©veloppements qui nâ€™ont jamais lieu entre guillemets anglais ?
    - Selon vous, pourquoi avoir crÃ©Ã© plusieurs mÃ©canismes dâ€™inhibition ?

## Extensions de chemins
!!! tip "Extension de chemins"
    Lorsquâ€™on saisit un chemin contenant des *wildcards* ou *caractÃ¨res joker* (Ref. dernier exo du TP1), le shell le dÃ©veloppe en remplaÃ§ant les caractÃ¨res spÃ©ciaux `*`, `?` et `[` par les noms des fichiers qui correspondent Ã  lâ€™expression rÃ©guliÃ¨re qui rÃ©sulte de lâ€™extension du chemin. On appelle ce mÃ©canisme lâ€™*extension de chemin*.

    Par exemple, si le rÃ©pertoire courant contient les fichiers `a`, `b`, `c`, `d` et `e`, alors le chemin `a*` est dÃ©veloppÃ© en `a`, le chemin `?` en `a b c d e` et le chemin `[a-c]` en `a b c`.

    Lâ€™extension de chemin est effectuÃ©e par le shell, avant que la commande ne soit exÃ©cutÃ©e. Si aucun fichier ne correspond Ã  lâ€™expression rÃ©guliÃ¨re, le shell laisse le chemin tel quel.
---

### Exercice 5 : Des fichiers et des images ğŸ“šğŸ“š
1. CrÃ©er un rÃ©pertoire `dir` et y crÃ©er les fichiers vides `file-1.txt`, `file-2.txt`, `file-3.txt`, `file-4.txt`, `file-5.txt`, `file-6.txt`, `file-7.txt`, `file-8.txt`, `file-9.txt`, `config-a.txt`, `file-b.txt`.
2. CrÃ©er Ã©galement dans `dir` les fichiers vides suivants `img-1.png`, `img-2.png`, `img-3.png`, `img-4.png`, `img-5.png`, `img-6.png`, `img-7.png`, `img-8.png`, `img-9.png`.
3. CrÃ©er ensuite dans `dir` deux sous-rÃ©pertoires `files` et `imgs`. 
4. En vous aidant de l'extension de chemin et de la commande `mv`, dÃ©placer les fichiers `.txt` dans le rÃ©pertoire `files`. FaÃ®tes de mÃªme pour les fichiers `.png` dans le rÃ©pertoire `imgs`.
5. Donnez l'expression qui reconnais les fichiers `config-a.txt` et `file-b.txt`. Puis supprimez les fichiers correspondants Ã  cette expression. (GrÃ¢ce Ã  l'extension de chemin, vous pouvez le faire en une seule commande).
6. Supprimez le rÃ©pertoire `dir` et son contenu.

### Exercice 6 : Extension de l'accolade ğŸ“šğŸ“š
1. Testez les commandes suivantes
```bash
$ echo {a,b,c,d}
$ echo {a..d}
$ echo {a..d..2}
$ echo {1,2,3,4,5,6,7,8,9}
$ echo {1..9}
$ echo {1..9..2}
```
2. Que fait la commande `echo {a..d}` ? Quel est le rÃ´le de la virgule `,` dans l'extension de l'accolade ?
3. Que fait la commande `echo {a..d..2}` ? Quel est le rÃ´le du `2` dans l'extension de l'accolade ?
4. Testez les commandes suivantes, et observez leur rÃ©sultats.
```bash
$ echo {a..d}*
$ echo {a..d}.*
$ echo {a..d}.txt
```
6. CrÃ©er un rÃ©pertoire `dir`. DÃ©placez-vous y. En utilisant l'extension de l'accolade, en une seule commande, crÃ©er les fichiers vides `file-1.txt`, `file-2.txt`, `file-3.txt`, `file-4.txt`, `file-5.txt`, `file-6.txt`, `file-7.txt`, `file-8.txt`, `file-9.txt`. 
7. DÃ©placez tous les fichiers `.txt` dans un rÃ©pertoire `dir/files`.
8. CrÃ©er un rÃ©pertoire `dir/imgs`. DÃ©placez-vous y. En utilisant l'extension de l'accolade, en une seule commande, crÃ©Ã©er les fichiers vides `img001.png`, `img002.png`, `img003.png`, `img004.png`, `img005.png`, `img006.png`, `img007.png`, `img008.png`, `img009.png`.
9. Supprimez le rÃ©pertoire `dir` et tout son contenu.

## Substitution de commande
!!! tip "Substitution de commande"
    La substitution de commanande est un mÃ©canisme qui permet dâ€™insÃ©rer le rÃ©sultat dâ€™une commande dans une chaÃ®ne de caractÃ¨res. 
    
    La substitution de commandes dans une chaÃ®ne de caractÃ¨res est une autre facilitÃ© offerte par le shell. Elle permet de capturer la sortie d'une commande et de l'assigner Ã  une variable ou de l'utiliser comme un argument d'une autre commande. Comme beaucoup de commandes Linux gÃ©nÃ¨rent une sortie, la substitution de commandes peut Ãªtre trÃ¨s intÃ©ressante. 
    
    Il existe deux syntaxes pour la substitution de commande : la syntaxe ancienne avec les accents graves (`` ` ``) et la syntaxe moderne avec les parenthÃ¨ses `$(...)`. L'ancienne syntaxe est dÃ©conseillÃ©e car elle ne permet pas dâ€™imbriquer les substitutions de commande. Nous ne la prÃ©senterons donc pas ici.
---
### Exercice 7 : Substitution de commande simple ğŸ“š
1. Testez les commandes suivantes et observez leur rÃ©sultat:
```bash
$ date
$ echo date
$ echo $(date)
$ aujourdhui=$(date)
$ echo $aujourdhui
$ echo "Nous sommes le $(date)"
```
2. Que fait la commande `echo $(date)` ? Quel est le rÃ´le du `$` devant la parenthÃ¨se ouvrante `(` ?
3. Tapez ensuite les commandes suivantes et observez leur rÃ©sultat:
```bash
$ prefix="Nous sommes le"
$ echo $prefix $(date)
$ echo $prefix $aujourdhui
$ echo ${prefix} ${aujourdhui}
$ phrase=${prefix} ${aujourdhui}
$ phrase="${prefix} ${aujourdhui}"
$ echo $phrase
$ echo "$phrase"
```
4. Pouvez-vous dÃ©duire le rÃ´le des guillemets anglais dans la substitution de commande ?
5. Quelle est la diffÃ©rence entre `$(...)` et `${...}` ?

### Exercice 8 : Substitution de commande imbriquÃ©e ğŸ“šğŸ“šğŸ“š
1. Testez les commandes suivantes et observez leur rÃ©sultat:
```bash
$ echo $(echo $(date))
$ echo $(echo $(echo $(date)))
$ echo $(echo $(echo $(echo $(date))))
$ echo $(echo $(echo $(echo $(echo $(date)))))
```
2. Testez ensuite la commande suivante:
```bash
$ echo
```
    Sans exÃ©cuter la commande qui suit saurez vous prÃ©dire son rÃ©sultat ?
    ```bash
    $ echo $(echo $(echo $(echo $(echo))))
    ```

## Compilation de programme C

!!! tip "Le compilateur C de Linux"
    `gcc` est le compilateur C de Linux. Il permet de compiler du code C. Il est trÃ¨s utilisÃ© par les dÃ©veloppeurs. Il est trÃ¨s complet et possÃ¨de de nombreuses fonctionnalitÃ©s. Nous allons voir un aperÃ§u de son utilisation.

    La compilation d'un programme en C passe par plusieurs Ã©tapes, qui sont essentiellement les suivantes:
    
    - La prÃ©compilation : elle permet de transformer le code source en un code intermÃ©diaire.
    - La compilation : elle permet de transformer le code intermÃ©diaire en code machine.
    - L'Ã©dition des liens : elle permet de lier le code machine avec les bibliothÃ¨ques utilisÃ©es.
    - La crÃ©ation de l'exÃ©cutable : elle permet de crÃ©er l'exÃ©cutable.

---

### Exercice 9 - Le compilateur `gcc` ğŸ“šğŸ“š

1. CrÃ©er un fichier `hello.c` dont le contenu est le suivant:
    ```c
    #include <stdio.h>

    int main()
    {
        printf("Hello world !\n");
        return 0;
    }
    ```
2. Placez-vous ensuite dans le rÃ©pertoire contenant votre fichier `hello.c` et tapez la commande `gcc hello.c`. Cette commande va compiler votre programme et crÃ©er un fichier `a.out` qui est l'exÃ©cutable de votre programme. Tapez enfin la commande `./a.out` pour exÃ©cuter votre programme.
    
    !!! warning "Attention"
        - Si vous avez dÃ©jÃ  un fichier `a.out` dans votre rÃ©pertoire, il sera Ã©crasÃ© par la commande `gcc hello.c`.
        - `a.out` est le nom par dÃ©faut de l'exÃ©cutable crÃ©Ã© par `gcc`. Vous pouvez changer ce nom en utilisant l'option `-o` de `gcc`. Par exemple, `gcc hello.c -o hello` va crÃ©er un exÃ©cutable `hello` au lieu de `a.out`.

3. RÃ©cupÃ©rez ensuite cette archive [hello.tar.gz](../assets/files/hello.tar.gz).
4. Extraire les fichiers de cet archive et dÃ©placez vos dans le rÃ©pertoire `hello` qui en sera extrait. Vous pouvez le faire grace Ã  la commande suivate:
```bash
$ tar -xvf hello.tar.gz
```
5. Tapez la commande 
```bash
$ gcc main.c hello.c -o run
```
pour compiler votre programme. Cette commande va compiler votre programme et crÃ©er un fichier `run` qui est l'exÃ©cutable de votre programme. ExÃ©cutez enfin votre programme avec la commande `./run`. 
6. Supprimer le fichier `run` et modifier ensuite le fichier `hello.c` de tel sorte Ã  avoir volontairement une erreur : supprimer l'accolade fermante de la fonction `void hello()`. RÃ©exÃ©cutez ensuite les commandes de la question 5. Que remarquez-vous ?
7. Remodifier ensuite le fichier `hello.c` en remettant l'accolade fermante mais rajouter un `return 1` dans la dÃ©finition de la fonction (avant l'accolade fermante). RÃ©exÃ©cutez ensuite les commandes de la question 5. Que remarquez-vous ?
8. Conclure sur la gestion des erreurs et des warnings sur `gcc`.

### Exercice 10 - Compilation sÃ©parÃ©e et Ã©dition des liens ğŸ“šğŸ“šğŸ“š

!!! tip
    Pour compiler un programme en C, il est possible de le faire en plusieurs Ã©tapes. On peut d'abord compiler chaque fichier source en un fichier objet, puis Ã©diter les liens pour crÃ©er l'exÃ©cutable. Cela permet de gagner du temps lors de la compilation de gros projets.

    En effet si un seul fichier source est modifiÃ©, il n'est pas nÃ©cessaire de recompiler tous les fichiers sources. Il suffit de recompiler le fichier source modifiÃ© et de rÃ©Ã©diter les liens.

    - L'option `-c` de `gcc` permet de compiler un fichier source en un fichier objet. L'option `-o` permet de spÃ©cifier le nom du fichier objet Ã  crÃ©er.
    - L'Ã©dition des liens se fait avec la commande `gcc` en spÃ©cifiant les fichiers objets Ã  lier. L'option `-o` permet de spÃ©cifier le nom de l'exÃ©cutable Ã  crÃ©er.
    
    Dans cette configuration, imaginons que nous avons un fichier `main.c` qui contient la fonction `main` et un fichier `hello.c` qui contient la fonction `hello`. Pour compiler ces deux fichiers en un exÃ©cutable `run`, on peut procÃ©der comme suit:
    ```bash
    $ gcc -c main.c -o main.o # Compilation du fichier main.c en main.o
    $ gcc -c hello.c -o hello.o # Compilation du fichier hello.c en hello.o
    $ gcc main.o hello.o -o run # Edition des liens pour crÃ©er l'exÃ©cutable run
    ```

1. Dans le rÃ©pertoire `hello`, de l'exercice prÃ©cÃ©dent, crÃ©er deux fichiers `bye.c` et `bye.h`, **en utilisant l'extension de l'accolade**, dont les contenus sont les suivants:
    - `bye.h`:
    ```c
    #ifndef BYE_H
    #define BYE_H

    void bye();

    #endif
    ```
    - `bye.c`:
    ```c
    #include <stdio.h>
    #include "bye.h"

    void bye()
    {
        printf("I'm done, bye !\n");
    }
    ```
2. Toujours en utilisant l'extension de l'accolade, compiler les deux fichiers `hello.c` et `bye.c` en deux fichiers objets `hello.o` et `bye.o`. Assurez-vous que le compilateur ne renvoie pas d'erreurs. (**Par dÃ©faut si on ne spÃ©cifie pas le nom du fichier de sortie, les fichiers `.c` sont compilÃ©s en des fichiers objets de mÃªme nom**)
3. Modifier ensuite le fichier `main.c` pour afin d'inclure le fichier `bye.h` et appeler la fonction `bye` Ã  la fin de la fonction `main`. Le contenu du fichier `main.c` doit Ãªtre le suivant:
    ```c
    #include <stdio.h>
    #include "hello.h"
    #include "bye.h"

    int main()
    {
        hello();
        bye();
        return 0;
    }
    ```
4. Compiler le fichier `main.c` en un fichier objet `main.o`. Assurez-vous que le compilateur ne renvoie pas d'erreurs.
5. En utilisant l'extention de chemin avec le caractÃ¨re `*`, Ã©diter les liens pour tous vos fichiers objets afin crÃ©er l'exÃ©cutable `run`. ExÃ©cutez ensuite votre programme avec la commande `./run`.
 

